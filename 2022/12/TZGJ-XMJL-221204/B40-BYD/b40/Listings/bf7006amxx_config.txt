; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave --gnu -o.\obj\bf7006amxx_config.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\obj\bf7006amxx_config.d --cpu=Cortex-M0 --apcs=interwork -Otime --diag_suppress=9931 -I.\src\pt -I.\src -I.\config -I.\RTE\CMSIS\BF7006AM64 -I.\RTE\Device\BF7006AM64 -I.\RTE\SEGGER -I.\RTE\Startup\BF7006AM64 -I.\RTE\_b40 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\BYD\BYDMicro_DFP\1.1.0\Device\Include\BF7006AMxx -D__UVISION_VERSION=536 -D_RTE_ -D_RTE_ --omf_browse=.\obj\bf7006amxx_config.crf RTE\Startup\BF7006AM64\BF7006AMxx_config.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  can_config PROC
;;;257    #ifdef BF7x06AMxx_CAN_DRIVER_PRESENT
;;;258    void can_config(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;259    {
000002  b08d              SUB      sp,sp,#0x34
;;;260    //  <e>CAN
;;;261    #define CAN_CONFIG_EN 1
;;;262    #if CAN_CONFIG_EN == 1
;;;263    //    <o>CAN source clock select
;;;264    //      <0x0=>XTAL
;;;265    //      <0x1=>PLL
;;;266        can_clock_sel(0x0);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       can_clock_sel
;;;267    
;;;268        can_parameter_struct can_parameter_init = 
00000a  48a7              LDR      r0,|L1.680|
00000c  6842              LDR      r2,[r0,#4]  ; <Data1>
00000e  6801              LDR      r1,[r0,#0]  ; <Data1>
;;;269        {
;;;270    //    <o>Work mode select
;;;271    //      <0x0=>Normal
;;;272    //      <0x1=>Listen only
;;;273    //      <0x2=>Self test
;;;274    //      <0x3=>Self receive
;;;275    //    <i>CAN work mode select
;;;276            .working_mode = (can_work_mode_enum)0,
;;;277    
;;;278    //    <o>Synchronlzation jump width
;;;279    //      <0x0=>0
;;;280    //      <0x40=>1
;;;281    //      <0x80=>2
;;;282    //      <0xC0=>3
;;;283    //    <i>Synchronlzation jump width
;;;284            .resync_jump_width = 0xC0,
;;;285    
;;;286    //    <o>CAN module clock select
;;;287    //      <0x0=>32MHz
;;;288    //      <0x1=>16MHz
;;;289    //      <0x2=>8MHz
;;;290    //    <i>CAN module clock select
;;;291            .can_clk = (can_clk_enum)2,
;;;292    
;;;293    //    <o>CAN baud rate
;;;294    //      <0x0=>50K
;;;295    //      <0x1=>100K
;;;296    //      <0x2=>125K
;;;297    //      <0x3=>200K
;;;298    //      <0x4=>250K
;;;299    //      <0x5=>400K
;;;300    //      <0x6=>500K
;;;301    //      <0x7=>800K
;;;302    //      <0x8=>1M
;;;303    //    <i>CAN baud rate config
;;;304            .can_baud = (can_baud_enum)0x2,
;;;305    
;;;306    //    <o>Sampling times
;;;307    //      <0x0=>1 time
;;;308    //      <0x80=>3 time
;;;309    //     <i>Sampling times
;;;310            .sampling_times = 0x80,
;;;311    
;;;312    //    <o>Error alarm count <0x0-0xFF:0x1><#/0x1>
;;;313    //    <i>Error alarm count (8 bits)
;;;314            .error_alarm_count = 100,
;;;315    
;;;316    //    <h>Interrupt Enable
;;;317    //      <q0.7>Bus error interrupt enable
;;;318    //      <q0.6>Arbitration lost interrupt enable
;;;319    //      <q0.5>Error passive interrupt enable
;;;320    //      <q0.4>Wake up interrupt enable
;;;321    //      <q0.3>Data overflow interrupt enable
;;;322    //      <q0.2>Error interrupt enable
;;;323    //      <q0.1>Tx interrupt enable
;;;324    //      <q0.0>Rx interrupt enable
;;;325    //    </h>
;;;326            .int_enable = 0x01,
;;;327    
;;;328    //    <h>NVIC Enable
;;;329    //      <q0.3>Wake up nvic interrupt enable
;;;330    //      <q0.2>Error nvic interrupt enable
;;;331    //      <q0.1>Rx nvic interrupt enable
;;;332    //      <q0.0>Tx nvic interrupt enable
;;;333    //    </h>
;;;334            .nvic_int_enable = 0x0F
;;;335        };
;;;336    //    <h>CAN filter config
;;;337        can_filter_parameter_struct can_filter_parameter = 
000010  920a              STR      r2,[sp,#0x28]
000012  910c              STR      r1,[sp,#0x30]
000014  68c3              LDR      r3,[r0,#0xc]  ; <Data2>
000016  6884              LDR      r4,[r0,#8]  ; <Data2>
000018  6942              LDR      r2,[r0,#0x14]  ; <Data2>
00001a  6901              LDR      r1,[r0,#0x10]  ; <Data2>
00001c  9409              STR      r4,[sp,#0x24]
00001e  469e              MOV      lr,r3
000020  6a43              LDR      r3,[r0,#0x24]  ; <Data2>
000022  6a87              LDR      r7,[r0,#0x28]  ; <Data2>
000024  469c              MOV      r12,r3
000026  6a06              LDR      r6,[r0,#0x20]  ; <Data2>
000028  69c5              LDR      r5,[r0,#0x1c]  ; <Data2>
00002a  6984              LDR      r4,[r0,#0x18]  ; <Data2>
00002c  6ac3              LDR      r3,[r0,#0x2c]  ; <Data2>
00002e  6b00              LDR      r0,[r0,#0x30]  ; <Data2>
;;;338        {
;;;339    //      <o>Filter mode
;;;340    //        <0x0=>Double filter
;;;341    //        <0x1=>Single filter
;;;342    //      <i>CAN filter mode select
;;;343            .filter_mode = (CAN_FILTER_MODE)0x1,
;;;344    
;;;345    //      <o>Frame format
;;;346    //        <0x0=>Standard frame
;;;347    //        <0x1=>Extended frame
;;;348    //      <i>CAN filter frame format 
;;;349            .filter_frame = (CAN_FRAME_FORMAT)0x0,
;;;350    
;;;351    //      <o>Frame type
;;;352    //        <0x0=>Data frame
;;;353    //        <0x1=>Remote frame
;;;354    //      <i>Frame type
;;;355            .filter_RTR = (CAN_FRAME_TYPE)0x0,
;;;356    
;;;357    //      <o>RTR mask
;;;358    //        <0x0=>Disable
;;;359    //        <0x1=>Enable
;;;360    //      <i>RTR mask
;;;361            .filter_mask_RTR = (FunctionalState)0,
;;;362    
;;;363    //      <h>Single filter config
;;;364    //        <o>id <0x0-0x1FFFFFFF:0x1><#/0x1>
;;;365    //        <i> Standard frame : lower 11 bits valid
;;;366    //        <i> Extended frame : lower 29 bits valid
;;;367            .filter_single_id = 0xFFFF,
;;;368            
;;;369    //        <o>data 0 <0x0-0xFF:0x1><#/0x1>
;;;370    //        <i> Standard frame : lower 8 bits valid
;;;371    //        <i> Extended frame : invalid
;;;372            .filter_data0 = 0xff,
;;;373            
;;;374    //        <o>data 1 <0x0-0xFF:0x1><#/0x1>
;;;375    //        <i> Standard frame : lower 8 bits valid
;;;376    //        <i> Extended frame : invalid
;;;377            .filter_data1 = 0xff,
;;;378            
;;;379    //        <o>id mask <0x0-0x7FF:0x1><#/0x1>
;;;380    //        <i> Standard frame : lower 11 bits valid
;;;381    //        <i> Extended frame : lower 29 bits valid
;;;382            .filter_mask_single_id  = 0xffff,
;;;383            
;;;384    //        <o>data 0 mask <0x0-0xFF:0x1><#/0x1>
;;;385    //        <i> Standard frame : lower 8 bits valid
;;;386    //        <i> Extended frame : invalid
;;;387            .filter_mask_data0      = 0xff,
;;;388            
;;;389    //        <o>data 1 mask <0x0-0xFF:0x1><#/0x1>
;;;390    //        <i> Standard frame : lower 8 bits valid
;;;391    //        <i> Extended frame : invalid
;;;392            .filter_mask_data1      = 0xff,
;;;393    //      </h>
;;;394    
;;;395    //      <h>Double filter config
;;;396    //        <o>id 0 <0x0-0x1FFFFFFF:0x1><#/0x1>
;;;397    //        <i> Standard frame: Bit 10 ~ 0 valid
;;;398    //        <i> Extended frame: Bit 28 ~ 13 valid
;;;399            .filter_double_id0      = 0xFFFFU,
;;;400            
;;;401    //        <o>id 1 <0x0-0xFFFFFFFF:0x1><#/0x1>
;;;402    //        <i> Standard frame: Bit 10 ~ 0 valid
;;;403    //        <i> Extended frame: Bit 28 ~ 13 valid
;;;404            .filter_double_id1      = 0xFFFFU,
;;;405            
;;;406    //        <o>std frame data 0 <0x0-0xFF:0x1><#/0x1>
;;;407    //        <i> Standard frame: lower 8 bits valid
;;;408    //        <i> Extended frame: invalid
;;;409            .filter_data0_std       = 0xff,
;;;410            
;;;411    //        <o>id 0 mask<0x0-0xFFFF:0x1><#/0x1>
;;;412    //        <i> Standard frame: lower 11 bits valid
;;;413    //        <i> Extended frame: lower 16 bits valid
;;;414            .filter_mask_double_id0 = 0xffff,
;;;415            
;;;416            
;;;417    //        <o>id 1 mask<0x0-0xFFFF:0x1><#/0x1>
;;;418    //        <i> Standard frame: lower 11 bits valid
;;;419    //        <i> Extended frame: lower 16 bits valid
;;;420            .filter_mask_double_id1 = 0xffff,
;;;421            
;;;422    //        <o>std frame data 0 mask<0x0-0xFF:0x1><#/0x1>
;;;423    //        <i> Standard frame: lower 8 bits valid
;;;424    //        <i> Extended frame: invalid
;;;425            .filter_mask_data0_std  = 0xff
;;;426    //      </h>
;;;427    //    </h>
;;;428    //  </e>
;;;429        };
;;;430    
;;;431        (void)can_init(can_parameter_init,can_filter_parameter);
000030  9100              STR      r1,[sp,#0]
000032  4661              MOV      r1,r12
000034  9307              STR      r3,[sp,#0x1c]
000036  9008              STR      r0,[sp,#0x20]
000038  9706              STR      r7,[sp,#0x18]
00003a  9105              STR      r1,[sp,#0x14]
00003c  a801              ADD      r0,sp,#4
00003e  c074              STM      r0!,{r2,r4-r6}
000040  4673              MOV      r3,lr
000042  9a09              LDR      r2,[sp,#0x24]
000044  990a              LDR      r1,[sp,#0x28]
000046  980c              LDR      r0,[sp,#0x30]
000048  f7fffffe          BL       can_init
;;;432    		
;;;433    //		extern void Can_Send_Strand_Buff_X (uint16_t id, uint8_t *buf, uint8_t len);
;;;434    //		uint8_t data[8] = {1};
;;;435    //		Can_Send_Strand_Buff_X(0x123,data,8);
;;;436    		
;;;437    #endif
;;;438    }
00004c  b00d              ADD      sp,sp,#0x34
00004e  bdf0              POP      {r4-r7,pc}
;;;439    #endif
                          ENDP

                  adc_config PROC
;;;441    #ifdef BF7x06AMxx_ADC_DRIVER_PRESENT
;;;442    void adc_config(void)
000050  b5f0              PUSH     {r4-r7,lr}
;;;443    {
;;;444    //  <e> ADC
;;;445    #define ADC_CONFIG_EN 1
;;;446    #if ADC_CONFIG_EN == 1
;;;447        adc_parameter_struct adc_init_para = 
000052  4c95              LDR      r4,|L1.680|
000054  b085              SUB      sp,sp,#0x14           ;443
000056  4620              MOV      r0,r4
000058  3034              ADDS     r0,r0,#0x34
00005a  c80f              LDM      r0,{r0-r3}
00005c  4684              MOV      r12,r0
00005e  3444              ADDS     r4,r4,#0x44
000060  ccf1              LDM      r4,{r0,r4-r7}
;;;448        {
;;;449    //    <o>Clock divide parameter
;;;450    //      <0x0=> SysClk / 1
;;;451    //      <0x10=>SysClk / 2
;;;452    //      <0x70=>SysClk / 3
;;;453    //      <0x20=>SysClk / 4
;;;454    //      <0x30=>SysClk / 6
;;;455    //      <0x40=>SysClk / 8
;;;456    //      <0x50=>SysClk / 10
;;;457    //      <0x60=>SysClk / 12
;;;458    //    <i>ADC clock divide parameter
;;;459            .adc_clk = 0x10,
;;;460    
;;;461    //    <o>Data width
;;;462    //      <0x0=>8 bits
;;;463    //      <0x1=>12 bits
;;;464    //    <i>adc data width
;;;465            .data_width = 0x1,
;;;466    
;;;467    //    <o>Sample clock number<0x0-0x3FF:0x1><#/0x1>
;;;468            .sample_clk_num = 50,
;;;469    
;;;470    //    <h>Channel enable
;;;471    //      <q0.23>CH 23  //cs7-1  null
;;;472    //      <q0.22>CH 22  //ad_r1
;;;473    //      <q0.21>CH 21  //cs14
;;;474    //      <q0.20>CH 20  //cs9
;;;475    
;;;476    //      <q0.19>CH 19  //cs4
;;;477    //      <q0.18>CH 18
;;;478    //      <q0.17>CH 17
;;;479    //      <q0.16>CH 16
;;;480    
;;;481    //      <q0.15>CH 15  //ad_r2
;;;482    //      <q0.14>CH 14  //cs13
;;;483    //      <q0.13>CH 13  //cs11
;;;484    //      <q0.12>CH 12  //cs8
;;;485    
;;;486    //      <q0.11>CH 11  //cs5
;;;487    //      <q0.10>CH 10  //cs2
;;;488    //      <q0.9>CH 9
;;;489    //      <q0.8>CH 8
;;;490    
;;;491    //      <q0.7>CH 7   //cs15
;;;492    //      <q0.6>CH 6   //cs12
;;;493    //      <q0.5>CH 5   //cs10
;;;494    //      <q0.4>CH 4   //cs7
;;;495    
;;;496    //      <q0.3>CH 3   //cs6
;;;497    //      <q0.2>CH 2   //cs3
;;;498    //      <q0.1>CH 1   //cs1
;;;499    //      <q0.0>CH 0
;;;500    //    </h>
;;;501            .channel_en = 0x78FCFEU, 
;;;502    
;;;503    //    <q0.0>Continuous convert enable
;;;504    //    <i>Continuous convert enable
;;;505            .adco_en = (FunctionalState)0,
;;;506    
;;;507    //    <q0.0>Interrupt enable
;;;508    //    <i>Interrupt enable
;;;509            .int_en = (FunctionalState)0,
;;;510    
;;;511    //    <o>Trigger Mode
;;;512    //      <0x0=>software trigger
;;;513    //      <0x1=>hardware trigger
;;;514    //    <i>adc trigger mode select
;;;515            .trigger.trigger_mode = 0x0,
;;;516    
;;;517    //    <o>Trigger source
;;;518    //      <0x1=>NMI
;;;519    //      <0x2=>PWM
;;;520    //      <0x3=>RTC
;;;521    //    <i>adc hardware trigger source
;;;522            .trigger.trigger_source = 0x3,
;;;523    
;;;524    //    <o>PWM trigger delay<0x0-0xFFFF:0x1><#/0x1>
;;;525            .trigger.pwm_trigger_delay = 100,
;;;526    
;;;527    //    <h>Compare config
;;;528    //      <q0.0>Compare enable
;;;529    //      <i>Compare enable
;;;530            .compare.compare_en = (FunctionalState)0x0,
;;;531    
;;;532    //      <o>Compare condition
;;;533    //        <0x0=>less
;;;534    //        <0x1=>larger
;;;535    //        <0x2=>between
;;;536    //      <i>ADC compare condition select
;;;537            .compare.compare_condition = 2,
;;;538    
;;;539    //      <o>Lower limit<0x0-0xFFF:0x1><#/0x1>
;;;540            .compare.lower_limit_val = 100,
;;;541            
;;;542    //      <o>Higher limit<0x0-0xFFF:0x1><#/0x1>
;;;543            .compare.higher_limit_val = 3500
;;;544    //    </h>
;;;545    //  </e>
;;;546        };
;;;547    
;;;548        adc_init(adc_init_para);
000062  9704              STR      r7,[sp,#0x10]
000064  466f              MOV      r7,sp
000066  c771              STM      r7!,{r0,r4-r6}
000068  4660              MOV      r0,r12
00006a  f7fffffe          BL       adc_init
;;;549    #endif
;;;550    }
00006e  b005              ADD      sp,sp,#0x14
000070  bdf0              POP      {r4-r7,pc}
;;;551    #endif
                          ENDP

                  pwm_config PROC
;;;553    #ifdef BF7x06AMxx_PWM_DRIVER_PRESENT
;;;554    void pwm_config(void)
000072  4770              BX       lr
;;;555    {
;;;556    //  <e>PWM
;;;557    #define PWM_CONFIG_EN 0
;;;558    #if PWM_CONFIG_EN == 1
;;;559    //    <e0>Channel 0
;;;560    #define PWM_CH0_EN 0
;;;561    #if PWM_CH0_EN == 1
;;;562    //      <q0.6>Interrupt enable
;;;563    //      <i>Channel interrupt enable
;;;564    
;;;565    //      <o0.2..5>Mode select
;;;566    //        <0x1=>Input Capture Mode  --  Rising Edge
;;;567    //        <0x2=>Input Capture Mode  --  Falling Edge
;;;568    //        <0x3=>Input Capture Mode  --  Rising / Falling Edge
;;;569    //        <0x5=>Output Compare Mode  --  Toggle
;;;570    //        <0x6=>Output Compare Mode  --  Clear
;;;571    //        <0x7=>Output Compare Mode  --  Set
;;;572    //        <0xA=>Edge / Center Aligned Mode  --  High-true pulse
;;;573    //        <0x9=>Edge / Center Aligned Mode  --  Low-true pulse
;;;574    //      <i>Channel mode select
;;;575    
;;;576    //      <o1>Channel value<0x0-0xFFFF:0x1><#/0x1>
;;;577    //    </e>
;;;578        pwm_ch0_init(0x28,0x0);
;;;579    #endif
;;;580    
;;;581    //    <e0>Channel 1
;;;582    #define PWM_CH1_EN 0
;;;583    #if PWM_CH1_EN == 1
;;;584    //      <q0.6>Interrupt enable
;;;585    //      <i>Channel interrupt enable
;;;586    
;;;587    //      <o0.2..5>Mode select
;;;588    //        <0x1=>Input Capture Mode  --  Rising Edge
;;;589    //        <0x2=>Input Capture Mode  --  Falling Edge
;;;590    //        <0x3=>Input Capture Mode  --  Rising / Falling Edge
;;;591    //        <0x5=>Output Compare Mode  --  Toggle
;;;592    //        <0x6=>Output Compare Mode  --  Clear
;;;593    //        <0x7=>Output Compare Mode  --  Set
;;;594    //        <0xA=>Edge / Center Aligned Mode  --  High-true pulse
;;;595    //        <0x9=>Edge / Center Aligned Mode  --  Low-true pulse
;;;596    //      <i>Channel mode select
;;;597    
;;;598    //      <o1>Channel value<0x0-0xFFFF:0x1><#/0x1>
;;;599    //    </e>
;;;600        pwm_ch1_init(0x28,0x0);
;;;601    #endif
;;;602    
;;;603    //    <e0>Channel 2
;;;604    #define PWM_CH2_EN 0
;;;605    #if PWM_CH2_EN == 1
;;;606    //      <q0.6>Interrupt enable
;;;607    //      <i>Channel interrupt enable
;;;608    
;;;609    //      <o0.2..5>Mode select
;;;610    //        <0x1=>Input Capture Mode  --  Rising Edge
;;;611    //        <0x2=>Input Capture Mode  --  Falling Edge
;;;612    //        <0x3=>Input Capture Mode  --  Rising / Falling Edge
;;;613    //        <0x5=>Output Compare Mode  --  Toggle
;;;614    //        <0x6=>Output Compare Mode  --  Clear
;;;615    //        <0x7=>Output Compare Mode  --  Set
;;;616    //        <0xA=>Edge / Center Aligned Mode  --  High-true pulse
;;;617    //        <0x9=>Edge / Center Aligned Mode  --  Low-true pulse
;;;618    //      <i>Channel mode select
;;;619    
;;;620    //      <o1>Channel value<0x0-0xFFFF:0x1><#/0x1>
;;;621    //    </e>
;;;622        pwm_ch2_init(0x28,0x0);
;;;623    #endif
;;;624    
;;;625    //    <e0>Channel 3
;;;626    #define PWM_CH3_EN 0
;;;627    #if PWM_CH3_EN == 1
;;;628    //      <q0.6>Interrupt enable
;;;629    //      <i>Channel interrupt enable
;;;630    
;;;631    //      <o0.2..5>Mode select
;;;632    //        <0x1=>Input Capture Mode  --  Rising Edge
;;;633    //        <0x2=>Input Capture Mode  --  Falling Edge
;;;634    //        <0x3=>Input Capture Mode  --  Rising / Falling Edge
;;;635    //        <0x5=>Output Compare Mode  --  Toggle
;;;636    //        <0x6=>Output Compare Mode  --  Clear
;;;637    //        <0x7=>Output Compare Mode  --  Set
;;;638    //        <0xA=>Edge / Center Aligned Mode  --  High-true pulse
;;;639    //        <0x9=>Edge / Center Aligned Mode  --  Low-true pulse
;;;640    //      <i>Channel mode select
;;;641    
;;;642    //      <o1>Channel value<0x0-0xFFFF:0x1><#/0x1>
;;;643    //    </e>
;;;644        pwm_ch3_init(0x28,0x0);
;;;645    #endif
;;;646    
;;;647    //    <e0>Channel 4
;;;648    #define PWM_CH4_EN 0
;;;649    #if PWM_CH4_EN == 1
;;;650    //      <q0.6>Interrupt enable
;;;651    //      <i>Channel interrupt enable
;;;652    
;;;653    //      <o0.2..5>Mode select
;;;654    //        <0x1=>Input Capture Mode  --  Rising Edge
;;;655    //        <0x2=>Input Capture Mode  --  Falling Edge
;;;656    //        <0x3=>Input Capture Mode  --  Rising / Falling Edge
;;;657    //        <0x5=>Output Compare Mode  --  Toggle
;;;658    //        <0x6=>Output Compare Mode  --  Clear
;;;659    //        <0x7=>Output Compare Mode  --  Set
;;;660    //        <0xA=>Edge / Center Aligned Mode  --  High-true pulse
;;;661    //        <0x9=>Edge / Center Aligned Mode  --  Low-true pulse
;;;662    //      <i>Channel mode select
;;;663    
;;;664    //      <o1>Channel value<0x0-0xFFFF:0x1><#/0x1>
;;;665    //    </e>
;;;666        pwm_ch4_init(0x28,0x0);
;;;667    #endif
;;;668    
;;;669    //    <e0>Channel 5
;;;670    #define PWM_CH5_EN 0
;;;671    #if PWM_CH5_EN == 1
;;;672    //      <q0.6>Interrupt enable
;;;673    //      <i>Channel interrupt enable
;;;674    
;;;675    //      <o0.2..5>Mode select
;;;676    //        <0x1=>Input Capture Mode  --  Rising Edge
;;;677    //        <0x2=>Input Capture Mode  --  Falling Edge
;;;678    //        <0x3=>Input Capture Mode  --  Rising / Falling Edge
;;;679    //        <0x5=>Output Compare Mode  --  Toggle
;;;680    //        <0x6=>Output Compare Mode  --  Clear
;;;681    //        <0x7=>Output Compare Mode  --  Set
;;;682    //        <0xA=>Edge / Center Aligned Mode  --  High-true pulse
;;;683    //        <0x9=>Edge / Center Aligned Mode  --  Low-true pulse
;;;684    //      <i>Channel mode select
;;;685    
;;;686    //      <o1>Channel value<0x0-0xFFFF:0x1><#/0x1>
;;;687    //    </e>
;;;688        pwm_ch5_init(0x28,0x0);
;;;689    #endif
;;;690    //    <h> PWM counter
;;;691    //      <o0.3..4>Clock select
;;;692    //        <0x0=>Off
;;;693    //        <0x1=>System Clock
;;;694    //        <0x2=>System Clock
;;;695    //        <0x3=>External input clock
;;;696    //      <i>PWM clock select
;;;697    
;;;698    //      <o0.0..2>Clock divide parameter
;;;699    //        <0x0=> / 1
;;;700    //        <0x1=> / 2
;;;701    //        <0x2=> / 4
;;;702    //        <0x3=> / 8
;;;703    //        <0x4=> / 16
;;;704    //        <0x5=> / 32
;;;705    //        <0x6=> / 64
;;;706    //        <0x7=> / 128
;;;707    //      <i>PWM clock divide parameter
;;;708    
;;;709    //      <o0.5>Count direction
;;;710    //        <0x0=>Up Counting
;;;711    //        <0x1=>Up-Down Counting
;;;712    //      <i>PWM count direction select
;;;713    
;;;714    //      <q0.6>Interrupt enable
;;;715    //      <i>PWM overflow interrupt enable
;;;716    
;;;717    //      <o1>Modulo<0x0-0xFFFF:0x1><#/0x1>
;;;718    //    </h>
;;;719    //  </e>
;;;720        pwm_init(0x09,0x4000);
;;;721    #endif
;;;722    }
;;;723    #endif
                          ENDP

                  wdt_cfg PROC
;;;725    #ifdef BF7x06AMxx_WDT_DRIVER_PRESENT
;;;726    void wdt_cfg(void)
000074  b510              PUSH     {r4,lr}
;;;727    {
;;;728    //  <e>WDT
;;;729    #define WDT_CONFIG_EN 1
;;;730    #if WDT_CONFIG_EN == 1
;;;731    //    <o0.8>Clock select
;;;732    //      <0x0=>1KHz internal clock
;;;733    //      <0x1=>32KHz internal clock
;;;734    //    <i>WDT clock select
;;;735    
;;;736    //    <q0.15>Window mode enable
;;;737    //    <i>WDT window mode enable
;;;738    
;;;739    //    <q0.7>WDT enable
;;;740    //    <i>WDT enable
;;;741    
;;;742    //    <q0.5>Update enable
;;;743    //    <i>WDT update enable
;;;744    
;;;745    //    <q0.1>Enable in sleep mode
;;;746    //    <i>WDT enable in sleep mode
;;;747    
;;;748    //    <q0.0>Enable in deep sleep mode
;;;749    //    <i>WDT enable in deep sleep mode
;;;750        wdt_config(0x180);//0b0000 0001 1000 0000
000076  20ff              MOVS     r0,#0xff
000078  3081              ADDS     r0,r0,#0x81
00007a  f7fffffe          BL       wdt_config
;;;751    
;;;752    //    <o>Overflow count<0x0-0xFFFF:0x1><#/0x1>
;;;753        wdt_overflow_count(16000); //32KHz 0.5s
00007e  207d              MOVS     r0,#0x7d
000080  01c0              LSLS     r0,r0,#7
000082  f7fffffe          BL       wdt_overflow_count
;;;754    //    <o>Window mode overflow count<0x0-0xFFFF:0x1><#/0x1>
;;;755        wdt_overflow_count_win(0x0);
000086  2000              MOVS     r0,#0
000088  f7fffffe          BL       wdt_overflow_count_win
;;;756    //  </e>
;;;757    #endif
;;;758    }
00008c  bd10              POP      {r4,pc}
;;;759    #endif
                          ENDP

                  timer_config PROC
;;;761    #ifdef BF7x06AMxx_TIMER_DRIVER_PRESENT
;;;762    void timer_config(void)
00008e  b510              PUSH     {r4,lr}
;;;763    {
;;;764    //  <e>Timer
;;;765    #define TIMER_CONFIG_EN 1
;;;766    #if TIMER_CONFIG_EN == 1
;;;767    //    <e0>Timer 0
;;;768    #define TIMER0_EN 1
;;;769    #if TIMER0_EN == 1
;;;770    //      <o0.2>Clock select
;;;771    //        <0x0=>System clock
;;;772    //        <0x1=>RC32KHz
;;;773    //      <i>TIMER clock select
;;;774    
;;;775    //      <o0.3..4>Clock divide
;;;776    //        <0x0=>System clock / 1
;;;777    //        <0x1=>System clock / 2
;;;778    //        <0x2=>System clock / 4
;;;779    //        <0x3=>System clock / 8
;;;780    //      <i>TIMER clock divide parameter (only when using system clock)
;;;781    
;;;782    //      <o0.1>Auto reload mode select
;;;783    //        <0x0=>Manual reload
;;;784    //        <0x1=>Auto reload
;;;785    //      <i>Timer auto reload mode select
;;;786    
;;;787    //      <q0.5>Interrupt enable
;;;788    //      <i>TIMER interrupt enable
;;;789    
;;;790    //      <q0.0>Enable
;;;791    //      <i>TIMER enable
;;;792    
;;;793    //      <o1>Modulo<0x0-0xFFFF:0x1><#/0x1>
;;;794    //    </e>
;;;795        timer_init(TIMER0,0x7B,4000); // 0111 1010  32MHz/8/4000 = 1000Hz --> 1ms
000090  227d              MOVS     r2,#0x7d
000092  0152              LSLS     r2,r2,#5
000094  217b              MOVS     r1,#0x7b
000096  4885              LDR      r0,|L1.684|
000098  f7fffffe          BL       timer_init
;;;796    #endif
;;;797    
;;;798    //    <e>Timer 1
;;;799    #define TIMER1_EN 1
;;;800    #if TIMER1_EN == 1
;;;801    //      <o0.2>Clock select
;;;802    //        <0x0=>System clock
;;;803    //        <0x1=>RC32KHz
;;;804    //      <i>TIMER clock select
;;;805    
;;;806    //      <o0.3..4>Clock divide
;;;807    //        <0x0=>System clock / 1
;;;808    //        <0x1=>System clock / 2
;;;809    //        <0x2=>System clock / 4
;;;810    //        <0x3=>System clock / 8
;;;811    //      <i>TIMER clock divide parameter (only when using system clock)
;;;812    
;;;813    //      <o0.1>Auto reload mode select
;;;814    //        <0x0=>Manual reload
;;;815    //        <0x1=>Auto reload
;;;816    //      <i>Timer auto reload mode select
;;;817    
;;;818    //      <q0.5>Interrupt enable
;;;819    //      <i>TIMER interrupt enable
;;;820    
;;;821    //      <q0.0>Enable
;;;822    //      <i>TIMER enable
;;;823    
;;;824    //      <o1>Modulo<0x0-0xFFFF:0x1><#/0x1>
;;;825    //    </e>
;;;826    //  </e>
;;;827        timer_init(TIMER1,0x7B,400); // 0111 1011  32MHz/8/400 = 10KHz  //start
00009c  22ff              MOVS     r2,#0xff
00009e  3291              ADDS     r2,r2,#0x91
0000a0  217b              MOVS     r1,#0x7b
0000a2  4883              LDR      r0,|L1.688|
0000a4  f7fffffe          BL       timer_init
;;;828    #endif
;;;829    #endif
;;;830    }
0000a8  bd10              POP      {r4,pc}
;;;831    #endif
                          ENDP

                  rtc_config PROC
;;;833    #ifdef BF7x06AMxx_RTC_DRIVER_PRESENT
;;;834    void rtc_config(void)
0000aa  b510              PUSH     {r4,lr}
;;;835    {
;;;836    //  <e>RTC
;;;837    #define RTC_CONFIG_EN 1
;;;838    #if RTC_CONFIG_EN == 1
;;;839    //    <o0.5..6>Clock select
;;;840    //      <0x0=>1KHz
;;;841    //      <0x1=>XTAL / 32
;;;842    //      <0x2=>Internal 32KHz clock
;;;843    //      <0x3=>Internal 32KHz clock
;;;844    //    <i>RTC clock select
;;;845    
;;;846    //    <q0.4>Interrupt enable
;;;847    //    <i>TIMER interrupt enable
;;;848    
;;;849    //    <q0.9>Enable
;;;850    //    <i>TIMER enable
;;;851    
;;;852    //    <o1>Modulo<0x0-0xFFFFFFFF:0x1><#/0x1>
;;;853    //    <i>RTC mod should not be set less than 3
;;;854    //  </e>
;;;855    	rtc_init(0x230,25000); //0000_0010_0011_0000 10Hz = 8M/32/25000;
0000ac  2023              MOVS     r0,#0x23
0000ae  4981              LDR      r1,|L1.692|
0000b0  0100              LSLS     r0,r0,#4
0000b2  f7fffffe          BL       rtc_init
;;;856    #endif
;;;857    }
0000b6  bd10              POP      {r4,pc}
;;;858    #endif
                          ENDP

                  gpio_config PROC
;;;860    #ifdef BF7x06AMxx_GPIO_DRIVER_PRESENT
;;;861    void gpio_config(void)
0000b8  b510              PUSH     {r4,lr}
;;;862    {
;;;863    #define ONE_BIT(x) (0x1 << x)
;;;864    
;;;865    //  <e> GPIO
;;;866    #define GPIO_CONFIG_EN 1
;;;867    #if GPIO_CONFIG_EN == 1
;;;868    //    <e0>NMI
;;;869    #define NMI_EN 0
;;;870    #if NMI_EN == 1
;;;871    //      <o0>Trigger Mode
;;;872    //        <0x00=>Falling edge
;;;873    //        <0x20=>Rising edge
;;;874    //        <0x21=>High level
;;;875    //        <0x01=>Low level
;;;876    //      <i>Configure NMI triggermode
;;;877    //    </e>
;;;878        nmi_init(0x20,ENABLE);
;;;879    #endif
;;;880    
;;;881    //    <e0>PA
;;;882    #define PA_EN 1
;;;883    #if PA_EN == 1
;;;884    //      <e16.7>PIN 7
;;;885    //        <o>Mode
;;;886    //          <0x0=>Floating
;;;887    //          <0x1=>Pull up
;;;888    //          <0x2=>Out
;;;889    //        <i>Configure GPIO inout mode
;;;890    #define PA_7_INOUT_MODE 2
;;;891    
;;;892    //        <q16.7>Interrup enable
;;;893    //        <o>Trigger mode
;;;894    //          <0x0=>High level
;;;895    //          <0x1=>Low level
;;;896    //          <0x2=>Rising edge
;;;897    //          <0x3=>Falling edge
;;;898    //        <i>Configure GPIO trigger mode
;;;899    #define PA_7_TRIGGER_MODE 2
;;;900    //      </e>
;;;901    
;;;902    //      <e14.6>PIN 6
;;;903    //        <o>Mode
;;;904    //          <0x0=>Floating
;;;905    //          <0x1=>Pull up
;;;906    //          <0x2=>Out
;;;907    //        <i>Configure GPIO inout mode
;;;908    #define PA_6_INOUT_MODE 2
;;;909    
;;;910    //        <q14.6>Interrup enable
;;;911    //        <o>Trigger mode
;;;912    //          <0x0=>High level
;;;913    //          <0x1=>Low level
;;;914    //          <0x2=>Rising edge
;;;915    //          <0x3=>Falling edge
;;;916    //        <i>Configure GPIO trigger mode
;;;917    #define PA_6_TRIGGER_MODE 2
;;;918    //      </e>
;;;919    
;;;920    //      <e12.5>PIN 5
;;;921    //        <o>Mode
;;;922    //          <0x0=>Floating
;;;923    //          <0x1=>Pull up
;;;924    //          <0x2=>Out
;;;925    //        <i>Configure GPIO inout mode
;;;926    #define PA_5_INOUT_MODE 2
;;;927    
;;;928    //        <q12.5>Interrup enable
;;;929    //        <o>Trigger mode
;;;930    //          <0x0=>High level
;;;931    //          <0x1=>Low level
;;;932    //          <0x2=>Rising edge
;;;933    //          <0x3=>Falling edge
;;;934    //        <i>Configure GPIO trigger mode
;;;935    #define PA_5_TRIGGER_MODE 2
;;;936    //      </e>
;;;937    
;;;938    //      <e10.4>PIN 4
;;;939    //        <o>Mode
;;;940    //          <0x0=>Floating
;;;941    //          <0x1=>Pull up
;;;942    //          <0x2=>Out
;;;943    //        <i>Configure GPIO inout mode
;;;944    #define PA_4_INOUT_MODE 2
;;;945    
;;;946    //        <q10.4>Interrup enable
;;;947    //        <o>Trigger mode
;;;948    //          <0x0=>High level
;;;949    //          <0x1=>Low level
;;;950    //          <0x2=>Rising edge
;;;951    //          <0x3=>Falling edge
;;;952    //        <i>Configure GPIO trigger mode
;;;953    #define PA_4_TRIGGER_MODE 2
;;;954    //      </e>
;;;955    
;;;956    //      <e8.3>PIN 3
;;;957    //        <o>Mode
;;;958    //          <0x0=>Floating
;;;959    //          <0x1=>Pull up
;;;960    //          <0x2=>Out
;;;961    //        <i>Configure GPIO inout mode
;;;962    #define PA_3_INOUT_MODE 2
;;;963    
;;;964    //        <q8.3>Interrup enable
;;;965    //        <o>Trigger mode
;;;966    //          <0x0=>High level
;;;967    //          <0x1=>Low level
;;;968    //          <0x2=>Rising edge
;;;969    //          <0x3=>Falling edge
;;;970    //        <i>Configure GPIO trigger mode
;;;971    #define PA_3_TRIGGER_MODE 2
;;;972    //      </e>
;;;973    
;;;974    //      <e6.2>PIN 2
;;;975    //        <o>Mode
;;;976    //          <0x0=>Floating
;;;977    //          <0x1=>Pull up
;;;978    //          <0x2=>Out
;;;979    //        <i>Configure GPIO inout mode
;;;980    #define PA_2_INOUT_MODE 2
;;;981    
;;;982    //        <q6.2>Interrup enable
;;;983    //        <o>Trigger mode
;;;984    //          <0x0=>High level
;;;985    //          <0x1=>Low level
;;;986    //          <0x2=>Rising edge
;;;987    //          <0x3=>Falling edge
;;;988    //        <i>Configure GPIO trigger mode
;;;989    #define PA_2_TRIGGER_MODE 2
;;;990    //      </e>
;;;991    
;;;992    //      <e4.1>PIN 1
;;;993    //        <o>Mode
;;;994    //          <0x0=>Floating
;;;995    //          <0x1=>Pull up
;;;996    //          <0x2=>Out
;;;997    //        <i>Configure GPIO inout mode
;;;998    #define PA_1_INOUT_MODE 2
;;;999    
;;;1000   //        <q4.1>Interrup enable
;;;1001   //        <o>Trigger mode
;;;1002   //          <0x0=>High level
;;;1003   //          <0x1=>Low level
;;;1004   //          <0x2=>Rising edge
;;;1005   //          <0x3=>Falling edge
;;;1006   //        <i>Configure GPIO trigger mode
;;;1007   #define PA_1_TRIGGER_MODE 2
;;;1008   //      </e>
;;;1009   
;;;1010   //      <e2.0>PIN 0
;;;1011   //        <o>Mode
;;;1012   //          <0x0=>Floating
;;;1013   //          <0x1=>Pull up
;;;1014   //          <0x2=>Out
;;;1015   //        <i>Configure GPIO inout mode
;;;1016   #define PA_0_INOUT_MODE 2
;;;1017   
;;;1018   //        <q2.0>Interrup enable
;;;1019   //        <o>Trigger mode
;;;1020   //          <0x0=>High level
;;;1021   //          <0x1=>Low level
;;;1022   //          <0x2=>Rising edge
;;;1023   //          <0x3=>Falling edge
;;;1024   //        <i>Configure GPIO trigger mode
;;;1025   #define PA_0_TRIGGER_MODE 2
;;;1026   //      </e>
;;;1027   //    </e>
;;;1028   #define PA_PIN 0x01
;;;1029   #define PA_IE 0x00
;;;1030   
;;;1031   // init PA group
;;;1032   #if PA_PIN & ONE_BIT(7)         //PIN7
;;;1033       gpio_init(GPIOA,(GPIO_MODE)PA_7_INOUT_MODE,GPIO_PIN_7);
;;;1034   #endif
;;;1035   #if PA_PIN & ONE_BIT(6)         //PIN6
;;;1036       gpio_init(GPIOA,(GPIO_MODE)PA_6_INOUT_MODE,GPIO_PIN_6);
;;;1037   #endif
;;;1038   #if PA_PIN & ONE_BIT(5)         //PIN5
;;;1039       gpio_init(GPIOA,(GPIO_MODE)PA_5_INOUT_MODE,GPIO_PIN_5);
;;;1040   #endif
;;;1041   #if PA_PIN & ONE_BIT(4)         //PIN4
;;;1042       gpio_init(GPIOA,(GPIO_MODE)PA_4_INOUT_MODE,GPIO_PIN_4);
;;;1043   #endif
;;;1044   #if PA_PIN & ONE_BIT(3)         //PIN3
;;;1045       gpio_init(GPIOA,(GPIO_MODE)PA_3_INOUT_MODE,GPIO_PIN_3);
;;;1046   #endif
;;;1047   #if PA_PIN & ONE_BIT(2)         //PIN2
;;;1048       gpio_init(GPIOA,(GPIO_MODE)PA_2_INOUT_MODE,GPIO_PIN_2);
;;;1049   #endif
;;;1050   #if PA_PIN & ONE_BIT(1)         //PIN1
;;;1051       gpio_init(GPIOA,(GPIO_MODE)PA_1_INOUT_MODE,GPIO_PIN_1);
;;;1052   #endif
;;;1053   #if PA_PIN & ONE_BIT(0)         //PIN0
;;;1054       gpio_init(GPIOA,(GPIO_MODE)PA_0_INOUT_MODE,GPIO_PIN_0);
0000ba  2201              MOVS     r2,#1
0000bc  2102              MOVS     r1,#2
0000be  487e              LDR      r0,|L1.696|
0000c0  f7fffffe          BL       gpio_init
;;;1055   #endif
;;;1056   
;;;1057   // Interrupt enable
;;;1058   #if PA_IE & ONE_BIT(7)         //PIN7
;;;1059       gpio_trigge_mode(GPIOA,(GPIO_TRG_MODE)PA_7_TRIGGER_MODE,GPIO_PIN_7);
;;;1060       gpio_interrupt_set(GPIOA,GPIO_PIN_7,ENABLE);
;;;1061   #endif
;;;1062   #if PA_IE & ONE_BIT(6)         //PIN6
;;;1063       gpio_trigge_mode(GPIOA,(GPIO_TRG_MODE)PA_6_TRIGGER_MODE,GPIO_PIN_6);
;;;1064       gpio_interrupt_set(GPIOA,GPIO_PIN_6,ENABLE);
;;;1065   #endif
;;;1066   #if PA_IE & ONE_BIT(5)         //PIN5
;;;1067       gpio_trigge_mode(GPIOA,(GPIO_TRG_MODE)PA_5_TRIGGER_MODE,GPIO_PIN_5);
;;;1068       gpio_interrupt_set(GPIOA,GPIO_PIN_5,ENABLE);
;;;1069   #endif
;;;1070   #if PA_IE & ONE_BIT(4)         //PIN4
;;;1071       gpio_trigge_mode(GPIOA,(GPIO_TRG_MODE)PA_4_TRIGGER_MODE,GPIO_PIN_4);
;;;1072       gpio_interrupt_set(GPIOA,GPIO_PIN_4,ENABLE);
;;;1073   #endif
;;;1074   #if PA_IE & ONE_BIT(3)         //PIN3
;;;1075       gpio_trigge_mode(GPIOA,(GPIO_TRG_MODE)PA_3_TRIGGER_MODE,GPIO_PIN_3);
;;;1076       gpio_interrupt_set(GPIOA,GPIO_PIN_3,ENABLE);
;;;1077   #endif
;;;1078   #if PA_IE & ONE_BIT(2)         //PIN2
;;;1079       gpio_trigge_mode(GPIOA,(GPIO_TRG_MODE)PA_2_TRIGGER_MODE,GPIO_PIN_2);
;;;1080       gpio_interrupt_set(GPIOA,GPIO_PIN_2,ENABLE);
;;;1081   #endif
;;;1082   #if PA_IE & ONE_BIT(1)         //PIN1
;;;1083       gpio_trigge_mode(GPIOA,(GPIO_TRG_MODE)PA_1_TRIGGER_MODE,GPIO_PIN_1);
;;;1084       gpio_interrupt_set(GPIOA,GPIO_PIN_1,ENABLE);
;;;1085   #endif
;;;1086   #if PA_IE & ONE_BIT(0)         //PIN0
;;;1087       gpio_trigge_mode(GPIOA,(GPIO_TRG_MODE)PA_0_TRIGGER_MODE,GPIO_PIN_0);
;;;1088       gpio_interrupt_set(GPIOA,GPIO_PIN_0,ENABLE);
;;;1089   #endif
;;;1090   #endif  // #if PA_EN == 1
;;;1091   
;;;1092   
;;;1093   //    <e0>PB
;;;1094   #define PB_EN 1
;;;1095   #if PB_EN == 1
;;;1096   //      <e16.7>PIN 7
;;;1097   //        <o>Mode
;;;1098   //          <0x0=>Floating
;;;1099   //          <0x1=>Pull up
;;;1100   //          <0x2=>Out
;;;1101   //        <i>Configure GPIO inout mode
;;;1102   #define PB_7_INOUT_MODE 2
;;;1103   
;;;1104   //        <q16.7>Interrup enable
;;;1105   //        <o>Trigger mode
;;;1106   //          <0x0=>High level
;;;1107   //          <0x1=>Low level
;;;1108   //          <0x2=>Rising edge
;;;1109   //          <0x3=>Falling edge
;;;1110   //        <i>Configure GPIO trigger mode
;;;1111   #define PB_7_TRIGGER_MODE 2
;;;1112   //      </e>
;;;1113   
;;;1114   //      <e14.6>PIN 6
;;;1115   //        <o>Mode
;;;1116   //          <0x0=>Floating
;;;1117   //          <0x1=>Pull up
;;;1118   //          <0x2=>Out
;;;1119   //        <i>Configure GPIO inout mode
;;;1120   #define PB_6_INOUT_MODE 2
;;;1121   
;;;1122   //        <q14.6>Interrup enable
;;;1123   //        <o>Trigger mode
;;;1124   //          <0x0=>High level
;;;1125   //          <0x1=>Low level
;;;1126   //          <0x2=>Rising edge
;;;1127   //          <0x3=>Falling edge
;;;1128   //        <i>Configure GPIO trigger mode
;;;1129   #define PB_6_TRIGGER_MODE 2
;;;1130   //      </e>
;;;1131   
;;;1132   //      <e12.5>PIN 5
;;;1133   //        <o>Mode
;;;1134   //          <0x0=>Floating
;;;1135   //          <0x1=>Pull up
;;;1136   //          <0x2=>Out
;;;1137   //        <i>Configure GPIO inout mode
;;;1138   #define PB_5_INOUT_MODE 2
;;;1139   
;;;1140   //        <q12.5>Interrup enable
;;;1141   //        <o>Trigger mode
;;;1142   //          <0x0=>High level
;;;1143   //          <0x1=>Low level
;;;1144   //          <0x2=>Rising edge
;;;1145   //          <0x3=>Falling edge
;;;1146   //        <i>Configure GPIO trigger mode
;;;1147   #define PB_5_TRIGGER_MODE 2
;;;1148   //      </e>
;;;1149   
;;;1150   //      <e10.4>PIN 4
;;;1151   //        <o>Mode
;;;1152   //          <0x0=>Floating
;;;1153   //          <0x1=>Pull up
;;;1154   //          <0x2=>Out
;;;1155   //        <i>Configure GPIO inout mode
;;;1156   #define PB_4_INOUT_MODE 2
;;;1157   
;;;1158   //        <q10.4>Interrup enable
;;;1159   //        <o>Trigger mode
;;;1160   //          <0x0=>High level
;;;1161   //          <0x1=>Low level
;;;1162   //          <0x2=>Rising edge
;;;1163   //          <0x3=>Falling edge
;;;1164   //        <i>Configure GPIO trigger mode
;;;1165   #define PB_4_TRIGGER_MODE 2
;;;1166   //      </e>
;;;1167   
;;;1168   //      <e8.3>PIN 3
;;;1169   //        <o>Mode
;;;1170   //          <0x0=>Floating
;;;1171   //          <0x1=>Pull up
;;;1172   //          <0x2=>Out
;;;1173   //        <i>Configure GPIO inout mode
;;;1174   #define PB_3_INOUT_MODE 0
;;;1175   
;;;1176   //        <q8.3>Interrup enable
;;;1177   //        <o>Trigger mode
;;;1178   //          <0x0=>High level
;;;1179   //          <0x1=>Low level
;;;1180   //          <0x2=>Rising edge
;;;1181   //          <0x3=>Falling edge
;;;1182   //        <i>Configure GPIO trigger mode
;;;1183   #define PB_3_TRIGGER_MODE 0
;;;1184   //      </e>
;;;1185   
;;;1186   //      <e6.2>PIN 2
;;;1187   //        <o>Mode
;;;1188   //          <0x0=>Floating
;;;1189   //          <0x1=>Pull up
;;;1190   //          <0x2=>Out
;;;1191   //        <i>Configure GPIO inout mode
;;;1192   #define PB_2_INOUT_MODE 2
;;;1193   
;;;1194   //        <q6.2>Interrup enable
;;;1195   //        <o>Trigger mode
;;;1196   //          <0x0=>High level
;;;1197   //          <0x1=>Low level
;;;1198   //          <0x2=>Rising edge
;;;1199   //          <0x3=>Falling edge
;;;1200   //        <i>Configure GPIO trigger mode
;;;1201   #define PB_2_TRIGGER_MODE 2
;;;1202   //      </e>
;;;1203   
;;;1204   //      <e4.1>PIN 1
;;;1205   //        <o>Mode
;;;1206   //          <0x0=>Floating
;;;1207   //          <0x1=>Pull up
;;;1208   //          <0x2=>Out
;;;1209   //        <i>Configure GPIO inout mode
;;;1210   #define PB_1_INOUT_MODE 2
;;;1211   
;;;1212   //        <q4.1>Interrup enable
;;;1213   //        <o>Trigger mode
;;;1214   //          <0x0=>High level
;;;1215   //          <0x1=>Low level
;;;1216   //          <0x2=>Rising edge
;;;1217   //          <0x3=>Falling edge
;;;1218   //        <i>Configure GPIO trigger mode
;;;1219   #define PB_1_TRIGGER_MODE 2
;;;1220   //      </e>
;;;1221   
;;;1222   //      <e2.0>PIN 0
;;;1223   //        <o>Mode
;;;1224   //          <0x0=>Floating
;;;1225   //          <0x1=>Pull up
;;;1226   //          <0x2=>Out
;;;1227   //        <i>Configure GPIO inout mode
;;;1228   #define PB_0_INOUT_MODE 2
;;;1229   
;;;1230   //        <q2.0>Interrup enable
;;;1231   //        <o>Trigger mode
;;;1232   //          <0x0=>High level
;;;1233   //          <0x1=>Low level
;;;1234   //          <0x2=>Rising edge
;;;1235   //          <0x3=>Falling edge
;;;1236   //        <i>Configure GPIO trigger mode
;;;1237   #define PB_0_TRIGGER_MODE 2
;;;1238   //      </e>
;;;1239   //    </e>
;;;1240   #define PB_PIN 0x03
;;;1241   #define PB_IE 0x00
;;;1242   
;;;1243   // init PB group
;;;1244   #if PB_PIN & ONE_BIT(7)         //PIN7
;;;1245       gpio_init(GPIOB,(GPIO_MODE)PB_7_INOUT_MODE,GPIO_PIN_7);
;;;1246   #endif
;;;1247   #if PB_PIN & ONE_BIT(6)         //PIN6
;;;1248       gpio_init(GPIOB,(GPIO_MODE)PB_6_INOUT_MODE,GPIO_PIN_6);
;;;1249   #endif
;;;1250   #if PB_PIN & ONE_BIT(5)         //PIN5
;;;1251       gpio_init(GPIOB,(GPIO_MODE)PB_5_INOUT_MODE,GPIO_PIN_5);
;;;1252   #endif
;;;1253   #if PB_PIN & ONE_BIT(4)         //PIN4
;;;1254       gpio_init(GPIOB,(GPIO_MODE)PB_4_INOUT_MODE,GPIO_PIN_4);
;;;1255   #endif
;;;1256   #if PB_PIN & ONE_BIT(3)         //PIN3
;;;1257       gpio_init(GPIOB,(GPIO_MODE)PB_3_INOUT_MODE,GPIO_PIN_3);
;;;1258   #endif
;;;1259   #if PB_PIN & ONE_BIT(2)         //PIN2
;;;1260       gpio_init(GPIOB,(GPIO_MODE)PB_2_INOUT_MODE,GPIO_PIN_2);
;;;1261   #endif
;;;1262   #if PB_PIN & ONE_BIT(1)         //PIN1
;;;1263       gpio_init(GPIOB,(GPIO_MODE)PB_1_INOUT_MODE,GPIO_PIN_1);
0000c4  4c7d              LDR      r4,|L1.700|
0000c6  2202              MOVS     r2,#2
0000c8  4611              MOV      r1,r2
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       gpio_init
;;;1264   #endif
;;;1265   #if PB_PIN & ONE_BIT(0)         //PIN0
;;;1266       gpio_init(GPIOB,(GPIO_MODE)PB_0_INOUT_MODE,GPIO_PIN_0);
0000d0  2201              MOVS     r2,#1
0000d2  2102              MOVS     r1,#2
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       gpio_init
;;;1267   #endif
;;;1268   
;;;1269   // Interrupt enable
;;;1270   #if PB_IE & ONE_BIT(7)         //PIN7
;;;1271       gpio_trigge_mode(GPIOB,(GPIO_TRG_MODE)PB_7_TRIGGER_MODE,GPIO_PIN_7);
;;;1272       gpio_interrupt_set(GPIOB,GPIO_PIN_7,ENABLE);
;;;1273   #endif
;;;1274   #if PB_IE & ONE_BIT(6)         //PIN6
;;;1275       gpio_trigge_mode(GPIOB,(GPIO_TRG_MODE)PB_6_TRIGGER_MODE,GPIO_PIN_6);
;;;1276       gpio_interrupt_set(GPIOB,GPIO_PIN_6,ENABLE);
;;;1277   #endif
;;;1278   #if PB_IE & ONE_BIT(5)         //PIN5
;;;1279       gpio_trigge_mode(GPIOB,(GPIO_TRG_MODE)PB_5_TRIGGER_MODE,GPIO_PIN_5);
;;;1280       gpio_interrupt_set(GPIOB,GPIO_PIN_5,ENABLE);
;;;1281   #endif
;;;1282   #if PB_IE & ONE_BIT(4)         //PIN4
;;;1283       gpio_trigge_mode(GPIOB,(GPIO_TRG_MODE)PB_4_TRIGGER_MODE,GPIO_PIN_4);
;;;1284       gpio_interrupt_set(GPIOB,GPIO_PIN_4,ENABLE);
;;;1285   #endif
;;;1286   #if PB_IE & ONE_BIT(3)         //PIN3
;;;1287       gpio_trigge_mode(GPIOB,(GPIO_TRG_MODE)PB_3_TRIGGER_MODE,GPIO_PIN_3);
;;;1288       gpio_interrupt_set(GPIOB,GPIO_PIN_3,ENABLE);
;;;1289   #endif
;;;1290   #if PB_IE & ONE_BIT(2)         //PIN2
;;;1291       gpio_trigge_mode(GPIOB,(GPIO_TRG_MODE)PB_2_TRIGGER_MODE,GPIO_PIN_2);
;;;1292       gpio_interrupt_set(GPIOB,GPIO_PIN_2,ENABLE);
;;;1293   #endif
;;;1294   #if PB_IE & ONE_BIT(1)         //PIN1
;;;1295       gpio_trigge_mode(GPIOB,(GPIO_TRG_MODE)PB_1_TRIGGER_MODE,GPIO_PIN_1);
;;;1296       gpio_interrupt_set(GPIOB,GPIO_PIN_1,ENABLE);
;;;1297   #endif
;;;1298   #if PB_IE & ONE_BIT(0)         //PIN0
;;;1299       gpio_trigge_mode(GPIOB,(GPIO_TRG_MODE)PB_0_TRIGGER_MODE,GPIO_PIN_0);
;;;1300       gpio_interrupt_set(GPIOB,GPIO_PIN_0,ENABLE);
;;;1301   #endif
;;;1302   #endif  // #if PB_EN == 1
;;;1303   
;;;1304   
;;;1305   //    <e0>PC
;;;1306   #define PC_EN 1
;;;1307   #if PC_EN == 1
;;;1308   //      <e8.7>PIN 7
;;;1309   //        <o>Mode
;;;1310   //          <0x0=>Floating
;;;1311   //          <0x1=>Pull up
;;;1312   //          <0x2=>Out
;;;1313   //        <i>Configure GPIO inout mode
;;;1314   //      </e>
;;;1315   #define PC_7_INOUT_MODE 2
;;;1316   
;;;1317   //      <e7.6>PIN 6
;;;1318   //        <o>Mode
;;;1319   //          <0x0=>Floating
;;;1320   //          <0x1=>Pull up
;;;1321   //          <0x2=>Out
;;;1322   //        <i>Configure GPIO inout mode
;;;1323   //      </e>
;;;1324   #define PC_6_INOUT_MODE 2
;;;1325   
;;;1326   //      <e6.5>PIN 5
;;;1327   //        <o>Mode
;;;1328   //          <0x0=>Floating
;;;1329   //          <0x1=>Pull up
;;;1330   //          <0x2=>Out
;;;1331   //        <i>Configure GPIO inout mode
;;;1332   //      </e>
;;;1333   #define PC_5_INOUT_MODE 2
;;;1334   
;;;1335   //      <e5.4>PIN 4
;;;1336   //        <o>Mode
;;;1337   //          <0x0=>Floating
;;;1338   //          <0x1=>Pull up
;;;1339   //          <0x2=>Out
;;;1340   //        <i>Configure GPIO inout mode
;;;1341   //      </e>
;;;1342   #define PC_4_INOUT_MODE 2
;;;1343   
;;;1344   //      <e4.3>PIN 3
;;;1345   //        <o>Mode
;;;1346   //          <0x0=>Floating
;;;1347   //          <0x1=>Pull up
;;;1348   //          <0x2=>Out
;;;1349   //        <i>Configure GPIO inout mode
;;;1350   //      </e>
;;;1351   #define PC_3_INOUT_MODE 2
;;;1352   
;;;1353   //      <e3.2>PIN 2
;;;1354   //        <o>Mode
;;;1355   //          <0x0=>Floating
;;;1356   //          <0x1=>Pull up
;;;1357   //          <0x2=>Out
;;;1358   //        <i>Configure GPIO inout mode
;;;1359   //      </e>
;;;1360   #define PC_2_INOUT_MODE 2
;;;1361   
;;;1362   
;;;1363   //      <e2.1>PIN 1
;;;1364   //        <o>Mode
;;;1365   //          <0x0=>Floating
;;;1366   //          <0x1=>Pull up
;;;1367   //          <0x2=>Out
;;;1368   //        <i>Configure GPIO inout mode
;;;1369   //      </e>
;;;1370   #define PC_1_INOUT_MODE 2
;;;1371   
;;;1372   //      <e1.0>PIN 0
;;;1373   //        <o>Mode
;;;1374   //          <0x0=>Floating
;;;1375   //          <0x1=>Pull up
;;;1376   //          <0x2=>Out
;;;1377   //        <i>Configure GPIO inout mode
;;;1378   //      </e>
;;;1379   //    </e>
;;;1380   #define PC_0_INOUT_MODE 2
;;;1381   
;;;1382   #define PC_PIN 0x87
;;;1383   
;;;1384   // init PC group
;;;1385   #if PC_PIN & ONE_BIT(7)         //PIN7
;;;1386       gpio_init(GPIOC,(GPIO_MODE)PC_7_INOUT_MODE,GPIO_PIN_7);
0000da  4c79              LDR      r4,|L1.704|
0000dc  2280              MOVS     r2,#0x80
0000de  2102              MOVS     r1,#2
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       gpio_init
;;;1387   #endif
;;;1388   #if PC_PIN & ONE_BIT(6)         //PIN6
;;;1389       gpio_init(GPIOC,(GPIO_MODE)PC_6_INOUT_MODE,GPIO_PIN_6);
;;;1390   #endif
;;;1391   #if PC_PIN & ONE_BIT(5)         //PIN5
;;;1392       gpio_init(GPIOC,(GPIO_MODE)PC_5_INOUT_MODE,GPIO_PIN_5);
;;;1393   #endif
;;;1394   #if PC_PIN & ONE_BIT(4)         //PIN4
;;;1395       gpio_init(GPIOC,(GPIO_MODE)PC_4_INOUT_MODE,GPIO_PIN_4);
;;;1396   #endif
;;;1397   #if PC_PIN & ONE_BIT(3)         //PIN3
;;;1398       gpio_init(GPIOC,(GPIO_MODE)PC_3_INOUT_MODE,GPIO_PIN_3);
;;;1399   #endif
;;;1400   #if PC_PIN & ONE_BIT(2)         //PIN2
;;;1401       gpio_init(GPIOC,(GPIO_MODE)PC_2_INOUT_MODE,GPIO_PIN_2);
0000e6  2204              MOVS     r2,#4
0000e8  2102              MOVS     r1,#2
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       gpio_init
;;;1402   #endif
;;;1403   #if PC_PIN & ONE_BIT(1)         //PIN1
;;;1404       gpio_init(GPIOC,(GPIO_MODE)PC_1_INOUT_MODE,GPIO_PIN_1);
0000f0  2202              MOVS     r2,#2
0000f2  4611              MOV      r1,r2
0000f4  4620              MOV      r0,r4
0000f6  f7fffffe          BL       gpio_init
;;;1405   #endif
;;;1406   #if PC_PIN & ONE_BIT(0)         //PIN0
;;;1407       gpio_init(GPIOC,(GPIO_MODE)PC_0_INOUT_MODE,GPIO_PIN_0);
0000fa  2201              MOVS     r2,#1
0000fc  2102              MOVS     r1,#2
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       gpio_init
;;;1408   #endif
;;;1409   #endif  // #if PC_EN == 1
;;;1410   
;;;1411   
;;;1412   //    <e0>PD
;;;1413   #define PD_EN 1
;;;1414   #if PD_EN == 1
;;;1415   //      <e16.7>PIN 7
;;;1416   //        <o>Mode
;;;1417   //          <0x0=>Floating
;;;1418   //          <0x1=>Pull up
;;;1419   //          <0x2=>Out
;;;1420   //        <i>Configure GPIO inout mode
;;;1421   #define PD_7_INOUT_MODE 2
;;;1422   
;;;1423   //        <q16.7>Interrup enable
;;;1424   //        <o>Trigger mode
;;;1425   //          <0x0=>High level
;;;1426   //          <0x1=>Low level
;;;1427   //          <0x2=>Rising edge
;;;1428   //          <0x3=>Falling edge
;;;1429   //        <i>Configure GPIO trigger mode
;;;1430   #define PD_7_TRIGGER_MODE 2
;;;1431   //      </e>
;;;1432   
;;;1433   //      <e14.6>PIN 6
;;;1434   //        <o>Mode
;;;1435   //          <0x0=>Floating
;;;1436   //          <0x1=>Pull up
;;;1437   //          <0x2=>Out
;;;1438   //        <i>Configure GPIO inout mode
;;;1439   #define PD_6_INOUT_MODE 2
;;;1440   
;;;1441   //        <q14.6>Interrup enable
;;;1442   //        <o>Trigger mode
;;;1443   //          <0x0=>High level
;;;1444   //          <0x1=>Low level
;;;1445   //          <0x2=>Rising edge
;;;1446   //          <0x3=>Falling edge
;;;1447   //        <i>Configure GPIO trigger mode
;;;1448   #define PD_6_TRIGGER_MODE 2
;;;1449   //      </e>
;;;1450   
;;;1451   //      <e12.5>PIN 5
;;;1452   //        <o>Mode
;;;1453   //          <0x0=>Floating
;;;1454   //          <0x1=>Pull up
;;;1455   //          <0x2=>Out
;;;1456   //        <i>Configure GPIO inout mode
;;;1457   #define PD_5_INOUT_MODE 2
;;;1458   
;;;1459   //        <q12.5>Interrup enable
;;;1460   //        <o>Trigger mode
;;;1461   //          <0x0=>High level
;;;1462   //          <0x1=>Low level
;;;1463   //          <0x2=>Rising edge
;;;1464   //          <0x3=>Falling edge
;;;1465   //        <i>Configure GPIO trigger mode
;;;1466   #define PD_5_TRIGGER_MODE 2
;;;1467   //      </e>
;;;1468   
;;;1469   //      <e10.4>PIN 4
;;;1470   //        <o>Mode
;;;1471   //          <0x0=>Floating
;;;1472   //          <0x1=>Pull up
;;;1473   //          <0x2=>Out
;;;1474   //        <i>Configure GPIO inout mode
;;;1475   #define PD_4_INOUT_MODE 2
;;;1476   
;;;1477   //        <q10.4>Interrup enable
;;;1478   //        <o>Trigger mode
;;;1479   //          <0x0=>High level
;;;1480   //          <0x1=>Low level
;;;1481   //          <0x2=>Rising edge
;;;1482   //          <0x3=>Falling edge
;;;1483   //        <i>Configure GPIO trigger mode
;;;1484   #define PD_4_TRIGGER_MODE 2
;;;1485   //      </e>
;;;1486   
;;;1487   //      <e8.3>PIN 3
;;;1488   //        <o>Mode
;;;1489   //          <0x0=>Floating
;;;1490   //          <0x1=>Pull up
;;;1491   //          <0x2=>Out
;;;1492   //        <i>Configure GPIO inout mode
;;;1493   #define PD_3_INOUT_MODE 2
;;;1494   
;;;1495   //        <q8.3>Interrup enable
;;;1496   //        <o>Trigger mode
;;;1497   //          <0x0=>High level
;;;1498   //          <0x1=>Low level
;;;1499   //          <0x2=>Rising edge
;;;1500   //          <0x3=>Falling edge
;;;1501   //        <i>Configure GPIO trigger mode
;;;1502   #define PD_3_TRIGGER_MODE 2
;;;1503   //      </e>
;;;1504   
;;;1505   //      <e6.2>PIN 2
;;;1506   //        <o>Mode
;;;1507   //          <0x0=>Floating
;;;1508   //          <0x1=>Pull up
;;;1509   //          <0x2=>Out
;;;1510   //        <i>Configure GPIO inout mode
;;;1511   #define PD_2_INOUT_MODE 2
;;;1512   
;;;1513   //        <q6.2>Interrup enable
;;;1514   //        <o>Trigger mode
;;;1515   //          <0x0=>High level
;;;1516   //          <0x1=>Low level
;;;1517   //          <0x2=>Rising edge
;;;1518   //          <0x3=>Falling edge
;;;1519   //        <i>Configure GPIO trigger mode
;;;1520   #define PD_2_TRIGGER_MODE 2
;;;1521   //      </e>
;;;1522   
;;;1523   //      <e4.1>PIN 1
;;;1524   //        <o>Mode
;;;1525   //          <0x0=>Floating
;;;1526   //          <0x1=>Pull up
;;;1527   //          <0x2=>Out
;;;1528   //        <i>Configure GPIO inout mode
;;;1529   #define PD_1_INOUT_MODE 2
;;;1530   
;;;1531   //        <q4.1>Interrup enable
;;;1532   //        <o>Trigger mode
;;;1533   //          <0x0=>High level
;;;1534   //          <0x1=>Low level
;;;1535   //          <0x2=>Rising edge
;;;1536   //          <0x3=>Falling edge
;;;1537   //        <i>Configure GPIO trigger mode
;;;1538   #define PD_1_TRIGGER_MODE 2
;;;1539   //      </e>
;;;1540   
;;;1541   //      <e2.0>PIN 0
;;;1542   //        <o>Mode
;;;1543   //          <0x0=>Floating
;;;1544   //          <0x1=>Pull up
;;;1545   //          <0x2=>Out
;;;1546   //        <i>Configure GPIO inout mode
;;;1547   #define PD_0_INOUT_MODE 1
;;;1548   
;;;1549   //        <q2.0>Interrup enable
;;;1550   //        <o>Trigger mode
;;;1551   //          <0x0=>High level
;;;1552   //          <0x1=>Low level
;;;1553   //          <0x2=>Rising edge
;;;1554   //          <0x3=>Falling edge
;;;1555   //        <i>Configure GPIO trigger mode
;;;1556   #define PD_0_TRIGGER_MODE 2
;;;1557   //      </e>
;;;1558   //    </e>
;;;1559   #define PD_PIN 0xFF
;;;1560   #define PD_IE 0x01
;;;1561   
;;;1562   // init PD group
;;;1563   #if PD_PIN & ONE_BIT(7)         //PIN7
;;;1564       gpio_init(GPIOD,(GPIO_MODE)PD_7_INOUT_MODE,GPIO_PIN_7);
000104  4c6f              LDR      r4,|L1.708|
000106  2280              MOVS     r2,#0x80
000108  2102              MOVS     r1,#2
00010a  4620              MOV      r0,r4
00010c  f7fffffe          BL       gpio_init
;;;1565   #endif
;;;1566   #if PD_PIN & ONE_BIT(6)         //PIN6
;;;1567       gpio_init(GPIOD,(GPIO_MODE)PD_6_INOUT_MODE,GPIO_PIN_6);
000110  2240              MOVS     r2,#0x40
000112  2102              MOVS     r1,#2
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       gpio_init
;;;1568   #endif
;;;1569   #if PD_PIN & ONE_BIT(5)         //PIN5
;;;1570       gpio_init(GPIOD,(GPIO_MODE)PD_5_INOUT_MODE,GPIO_PIN_5);
00011a  2220              MOVS     r2,#0x20
00011c  2102              MOVS     r1,#2
00011e  4620              MOV      r0,r4
000120  f7fffffe          BL       gpio_init
;;;1571   #endif
;;;1572   #if PD_PIN & ONE_BIT(4)         //PIN4
;;;1573       gpio_init(GPIOD,(GPIO_MODE)PD_4_INOUT_MODE,GPIO_PIN_4);
000124  2210              MOVS     r2,#0x10
000126  2102              MOVS     r1,#2
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       gpio_init
;;;1574   #endif
;;;1575   #if PD_PIN & ONE_BIT(3)         //PIN3
;;;1576       gpio_init(GPIOD,(GPIO_MODE)PD_3_INOUT_MODE,GPIO_PIN_3);
00012e  2208              MOVS     r2,#8
000130  2102              MOVS     r1,#2
000132  4620              MOV      r0,r4
000134  f7fffffe          BL       gpio_init
;;;1577   #endif
;;;1578   #if PD_PIN & ONE_BIT(2)         //PIN2
;;;1579       gpio_init(GPIOD,(GPIO_MODE)PD_2_INOUT_MODE,GPIO_PIN_2);
000138  2204              MOVS     r2,#4
00013a  2102              MOVS     r1,#2
00013c  4620              MOV      r0,r4
00013e  f7fffffe          BL       gpio_init
;;;1580   #endif
;;;1581   #if PD_PIN & ONE_BIT(1)         //PIN1
;;;1582       gpio_init(GPIOD,(GPIO_MODE)PD_1_INOUT_MODE,GPIO_PIN_1);
000142  2202              MOVS     r2,#2
000144  4611              MOV      r1,r2
000146  4620              MOV      r0,r4
000148  f7fffffe          BL       gpio_init
;;;1583   #endif
;;;1584   #if PD_PIN & ONE_BIT(0)         //PIN0
;;;1585       gpio_init(GPIOD,(GPIO_MODE)PD_0_INOUT_MODE,GPIO_PIN_0);
00014c  2201              MOVS     r2,#1
00014e  4611              MOV      r1,r2
000150  4620              MOV      r0,r4
000152  f7fffffe          BL       gpio_init
;;;1586   #endif
;;;1587   
;;;1588   // Interrupt enable
;;;1589   #if PD_IE & ONE_BIT(7)         //PIN7
;;;1590       gpio_trigge_mode(GPIOD,(GPIO_TRG_MODE)PD_7_TRIGGER_MODE,GPIO_PIN_7);
;;;1591       gpio_interrupt_set(GPIOD,GPIO_PIN_7,ENABLE);
;;;1592   #endif
;;;1593   #if PD_IE & ONE_BIT(6)         //PIN6
;;;1594       gpio_trigge_mode(GPIOD,(GPIO_TRG_MODE)PD_6_TRIGGER_MODE,GPIO_PIN_6);
;;;1595       gpio_interrupt_set(GPIOD,GPIO_PIN_6,ENABLE);
;;;1596   #endif
;;;1597   #if PD_IE & ONE_BIT(5)         //PIN5
;;;1598       gpio_trigge_mode(GPIOD,(GPIO_TRG_MODE)PD_5_TRIGGER_MODE,GPIO_PIN_5);
;;;1599       gpio_interrupt_set(GPIOD,GPIO_PIN_5,ENABLE);
;;;1600   #endif
;;;1601   #if PD_IE & ONE_BIT(4)         //PIN4
;;;1602       gpio_trigge_mode(GPIOD,(GPIO_TRG_MODE)PD_4_TRIGGER_MODE,GPIO_PIN_4);
;;;1603       gpio_interrupt_set(GPIOD,GPIO_PIN_4,ENABLE);
;;;1604   #endif
;;;1605   #if PD_IE & ONE_BIT(3)         //PIN3
;;;1606       gpio_trigge_mode(GPIOD,(GPIO_TRG_MODE)PD_3_TRIGGER_MODE,GPIO_PIN_3);
;;;1607       gpio_interrupt_set(GPIOD,GPIO_PIN_3,ENABLE);
;;;1608   #endif
;;;1609   #if PD_IE & ONE_BIT(2)         //PIN2
;;;1610       gpio_trigge_mode(GPIOD,(GPIO_TRG_MODE)PD_2_TRIGGER_MODE,GPIO_PIN_2);
;;;1611       gpio_interrupt_set(GPIOD,GPIO_PIN_2,ENABLE);
;;;1612   #endif
;;;1613   #if PD_IE & ONE_BIT(1)         //PIN1
;;;1614       gpio_trigge_mode(GPIOD,(GPIO_TRG_MODE)PD_1_TRIGGER_MODE,GPIO_PIN_1);
;;;1615       gpio_interrupt_set(GPIOD,GPIO_PIN_1,ENABLE);
;;;1616   #endif
;;;1617   #if PD_IE & ONE_BIT(0)         //PIN0
;;;1618       gpio_trigge_mode(GPIOD,(GPIO_TRG_MODE)PD_0_TRIGGER_MODE,GPIO_PIN_0);
000156  2201              MOVS     r2,#1
000158  2102              MOVS     r1,#2
00015a  4620              MOV      r0,r4
00015c  f7fffffe          BL       gpio_trigge_mode
;;;1619       gpio_interrupt_set(GPIOD,GPIO_PIN_0,ENABLE);
000160  2201              MOVS     r2,#1
000162  4611              MOV      r1,r2
000164  4620              MOV      r0,r4
000166  f7fffffe          BL       gpio_interrupt_set
;;;1620   #endif
;;;1621   #endif  // #if PD_EN == 1
;;;1622   
;;;1623   
;;;1624   //    <e0>PE
;;;1625   #define PE_EN 1
;;;1626   #if PE_EN == 1
;;;1627   //      <e8.7>PIN 7
;;;1628   //        <o>Mode
;;;1629   //          <0x0=>Floating
;;;1630   //          <0x1=>Pull up
;;;1631   //          <0x2=>Out
;;;1632   //        <i>Configure GPIO inout mode
;;;1633   //      </e>
;;;1634   #define PE_7_INOUT_MODE 2
;;;1635   
;;;1636   //      <e7.6>PIN 6
;;;1637   //        <o>Mode
;;;1638   //          <0x0=>Floating
;;;1639   //          <0x1=>Pull up
;;;1640   //          <0x2=>Out
;;;1641   //        <i>Configure GPIO inout mode
;;;1642   //      </e>
;;;1643   #define PE_6_INOUT_MODE 2
;;;1644   
;;;1645   //      <e6.5>PIN 5
;;;1646   //        <o>Mode
;;;1647   //          <0x0=>Floating
;;;1648   //          <0x1=>Pull up
;;;1649   //          <0x2=>Out
;;;1650   //        <i>Configure GPIO inout mode
;;;1651   //      </e>
;;;1652   #define PE_5_INOUT_MODE 1
;;;1653   
;;;1654   //      <e5.4>PIN 4
;;;1655   //        <o>Mode
;;;1656   //          <0x0=>Floating
;;;1657   //          <0x1=>Pull up
;;;1658   //          <0x2=>Out
;;;1659   //        <i>Configure GPIO inout mode
;;;1660   //      </e>
;;;1661   #define PE_4_INOUT_MODE 0
;;;1662   
;;;1663   //      <e4.3>PIN 3
;;;1664   //        <o>Mode
;;;1665   //          <0x0=>Floating
;;;1666   //          <0x1=>Pull up
;;;1667   //          <0x2=>Out
;;;1668   //        <i>Configure GPIO inout mode
;;;1669   //      </e>
;;;1670   #define PE_3_INOUT_MODE 1
;;;1671   
;;;1672   //      <e3.2>PIN 2
;;;1673   //        <o>Mode
;;;1674   //          <0x0=>Floating
;;;1675   //          <0x1=>Pull up
;;;1676   //          <0x2=>Out
;;;1677   //        <i>Configure GPIO inout mode
;;;1678   //      </e>
;;;1679   #define PE_2_INOUT_MODE 2
;;;1680   
;;;1681   
;;;1682   //      <e2.1>PIN 1
;;;1683   //        <o>Mode
;;;1684   //          <0x0=>Floating
;;;1685   //          <0x1=>Pull up
;;;1686   //          <0x2=>Out
;;;1687   //        <i>Configure GPIO inout mode
;;;1688   //      </e>
;;;1689   #define PE_1_INOUT_MODE 2
;;;1690   
;;;1691   //      <e1.0>PIN 0
;;;1692   //        <o>Mode
;;;1693   //          <0x0=>Floating
;;;1694   //          <0x1=>Pull up
;;;1695   //          <0x2=>Out
;;;1696   //        <i>Configure GPIO inout mode
;;;1697   //      </e>
;;;1698   //    </e>
;;;1699   #define PE_0_INOUT_MODE 2
;;;1700   
;;;1701   #define PE_PIN 0x3D
;;;1702   
;;;1703   // init PE group
;;;1704   #if PE_PIN & ONE_BIT(7)         //PIN7
;;;1705       gpio_init(GPIOE,(GPIO_MODE)PE_7_INOUT_MODE,GPIO_PIN_7);
;;;1706   #endif
;;;1707   #if PE_PIN & ONE_BIT(6)         //PIN6
;;;1708       gpio_init(GPIOE,(GPIO_MODE)PE_6_INOUT_MODE,GPIO_PIN_6);
;;;1709   #endif
;;;1710   #if PE_PIN & ONE_BIT(5)         //PIN5
;;;1711       gpio_init(GPIOE,(GPIO_MODE)PE_5_INOUT_MODE,GPIO_PIN_5);
00016a  4c57              LDR      r4,|L1.712|
00016c  2220              MOVS     r2,#0x20
00016e  2101              MOVS     r1,#1
000170  4620              MOV      r0,r4
000172  f7fffffe          BL       gpio_init
;;;1712   #endif
;;;1713   #if PE_PIN & ONE_BIT(4)         //PIN4
;;;1714       gpio_init(GPIOE,(GPIO_MODE)PE_4_INOUT_MODE,GPIO_PIN_4);
000176  2210              MOVS     r2,#0x10
000178  2100              MOVS     r1,#0
00017a  4620              MOV      r0,r4
00017c  f7fffffe          BL       gpio_init
;;;1715   #endif
;;;1716   #if PE_PIN & ONE_BIT(3)         //PIN3
;;;1717       gpio_init(GPIOE,(GPIO_MODE)PE_3_INOUT_MODE,GPIO_PIN_3);
000180  2208              MOVS     r2,#8
000182  2101              MOVS     r1,#1
000184  4620              MOV      r0,r4
000186  f7fffffe          BL       gpio_init
;;;1718   #endif
;;;1719   #if PE_PIN & ONE_BIT(2)         //PIN2
;;;1720       gpio_init(GPIOE,(GPIO_MODE)PE_2_INOUT_MODE,GPIO_PIN_2);
00018a  2204              MOVS     r2,#4
00018c  2102              MOVS     r1,#2
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       gpio_init
;;;1721   #endif
;;;1722   #if PE_PIN & ONE_BIT(1)         //PIN1
;;;1723       gpio_init(GPIOE,(GPIO_MODE)PE_1_INOUT_MODE,GPIO_PIN_1);
;;;1724   #endif
;;;1725   #if PE_PIN & ONE_BIT(0)         //PIN0
;;;1726       gpio_init(GPIOE,(GPIO_MODE)PE_0_INOUT_MODE,GPIO_PIN_0);
000194  2201              MOVS     r2,#1
000196  2102              MOVS     r1,#2
000198  4620              MOV      r0,r4
00019a  f7fffffe          BL       gpio_init
;;;1727   #endif
;;;1728   #endif  // #if PE_EN == 1
;;;1729   
;;;1730   
;;;1731   //    <e0>PF
;;;1732   #define PF_EN 1
;;;1733   #if PF_EN == 1
;;;1734   //      <e8.7>PIN 7
;;;1735   //        <o>Mode
;;;1736   //          <0x0=>Floating
;;;1737   //          <0x1=>Pull up
;;;1738   //          <0x2=>Out
;;;1739   //        <i>Configure GPIO inout mode
;;;1740   //      </e>
;;;1741   #define PF_7_INOUT_MODE 2
;;;1742   
;;;1743   //      <e7.6>PIN 6
;;;1744   //        <o>Mode
;;;1745   //          <0x0=>Floating
;;;1746   //          <0x1=>Pull up
;;;1747   //          <0x2=>Out
;;;1748   //        <i>Configure GPIO inout mode
;;;1749   //      </e>
;;;1750   #define PF_6_INOUT_MODE 2
;;;1751   
;;;1752   //      <e6.5>PIN 5
;;;1753   //        <o>Mode
;;;1754   //          <0x0=>Floating
;;;1755   //          <0x1=>Pull up
;;;1756   //          <0x2=>Out
;;;1757   //        <i>Configure GPIO inout mode
;;;1758   //      </e>
;;;1759   #define PF_5_INOUT_MODE 2
;;;1760   
;;;1761   //      <e5.4>PIN 4
;;;1762   //        <o>Mode
;;;1763   //          <0x0=>Floating
;;;1764   //          <0x1=>Pull up
;;;1765   //          <0x2=>Out
;;;1766   //        <i>Configure GPIO inout mode
;;;1767   //      </e>
;;;1768   #define PF_4_INOUT_MODE 2
;;;1769   
;;;1770   //      <e4.3>PIN 3
;;;1771   //        <o>Mode
;;;1772   //          <0x0=>Floating
;;;1773   //          <0x1=>Pull up
;;;1774   //          <0x2=>Out
;;;1775   //        <i>Configure GPIO inout mode
;;;1776   //      </e>
;;;1777   #define PF_3_INOUT_MODE 0
;;;1778   
;;;1779   //      <e3.2>PIN 2
;;;1780   //        <o>Mode
;;;1781   //          <0x0=>Floating
;;;1782   //          <0x1=>Pull up
;;;1783   //          <0x2=>Out
;;;1784   //        <i>Configure GPIO inout mode
;;;1785   //      </e>
;;;1786   #define PF_2_INOUT_MODE 2
;;;1787   
;;;1788   
;;;1789   //      <e2.1>PIN 1
;;;1790   //        <o>Mode
;;;1791   //          <0x0=>Floating
;;;1792   //          <0x1=>Pull up
;;;1793   //          <0x2=>Out
;;;1794   //        <i>Configure GPIO inout mode
;;;1795   //      </e>
;;;1796   #define PF_1_INOUT_MODE 2
;;;1797   
;;;1798   //      <e1.0>PIN 0
;;;1799   //        <o>Mode
;;;1800   //          <0x0=>Floating
;;;1801   //          <0x1=>Pull up
;;;1802   //          <0x2=>Out
;;;1803   //        <i>Configure GPIO inout mode
;;;1804   //      </e>
;;;1805   //    </e>
;;;1806   #define PF_0_INOUT_MODE 2
;;;1807   
;;;1808   #define PF_PIN 0xDD //0xC4
;;;1809   
;;;1810   // init PF group
;;;1811   #if PF_PIN & ONE_BIT(7)         //PIN7
;;;1812       gpio_init(GPIOF,(GPIO_MODE)PF_7_INOUT_MODE,GPIO_PIN_7);
00019e  4c4b              LDR      r4,|L1.716|
0001a0  2280              MOVS     r2,#0x80
0001a2  2102              MOVS     r1,#2
0001a4  4620              MOV      r0,r4
0001a6  f7fffffe          BL       gpio_init
;;;1813   #endif
;;;1814   #if PF_PIN & ONE_BIT(6)         //PIN6
;;;1815       gpio_init(GPIOF,(GPIO_MODE)PF_6_INOUT_MODE,GPIO_PIN_6);
0001aa  2240              MOVS     r2,#0x40
0001ac  2102              MOVS     r1,#2
0001ae  4620              MOV      r0,r4
0001b0  f7fffffe          BL       gpio_init
;;;1816   #endif
;;;1817   #if PF_PIN & ONE_BIT(5)         //PIN5
;;;1818       gpio_init(GPIOF,(GPIO_MODE)PF_5_INOUT_MODE,GPIO_PIN_5);
;;;1819   #endif
;;;1820   #if PF_PIN & ONE_BIT(4)         //PIN4
;;;1821       gpio_init(GPIOF,(GPIO_MODE)PF_4_INOUT_MODE,GPIO_PIN_4);
0001b4  2210              MOVS     r2,#0x10
0001b6  2102              MOVS     r1,#2
0001b8  4620              MOV      r0,r4
0001ba  f7fffffe          BL       gpio_init
;;;1822   #endif
;;;1823   #if PF_PIN & ONE_BIT(3)         //PIN3
;;;1824       gpio_init(GPIOF,(GPIO_MODE)PF_3_INOUT_MODE,GPIO_PIN_3);
0001be  2208              MOVS     r2,#8
0001c0  2100              MOVS     r1,#0
0001c2  4620              MOV      r0,r4
0001c4  f7fffffe          BL       gpio_init
;;;1825   #endif
;;;1826   #if PF_PIN & ONE_BIT(2)         //PIN2
;;;1827       gpio_init(GPIOF,(GPIO_MODE)PF_2_INOUT_MODE,GPIO_PIN_2);
0001c8  2204              MOVS     r2,#4
0001ca  2102              MOVS     r1,#2
0001cc  4620              MOV      r0,r4
0001ce  f7fffffe          BL       gpio_init
;;;1828   #endif
;;;1829   #if PF_PIN & ONE_BIT(1)         //PIN1
;;;1830       gpio_init(GPIOF,(GPIO_MODE)PF_1_INOUT_MODE,GPIO_PIN_1);
;;;1831   #endif
;;;1832   #if PF_PIN & ONE_BIT(0)         //PIN0
;;;1833       gpio_init(GPIOF,(GPIO_MODE)PF_0_INOUT_MODE,GPIO_PIN_0);
0001d2  2201              MOVS     r2,#1
0001d4  2102              MOVS     r1,#2
0001d6  4620              MOV      r0,r4
0001d8  f7fffffe          BL       gpio_init
;;;1834   #endif
;;;1835   #endif  // #if PF_EN == 1
;;;1836   
;;;1837   
;;;1838   //    <e0>PG
;;;1839   #define PG_EN 1
;;;1840   #if PG_EN == 1
;;;1841   //      <e8.7>PIN 7
;;;1842   //        <o>Mode
;;;1843   //          <0x0=>Floating
;;;1844   //          <0x1=>Pull up
;;;1845   //          <0x2=>Out
;;;1846   //        <i>Configure GPIO inout mode
;;;1847   //      </e>
;;;1848   #define PG_7_INOUT_MODE 2
;;;1849   
;;;1850   //      <e7.6>PIN 6
;;;1851   //        <o>Mode
;;;1852   //          <0x0=>Floating
;;;1853   //          <0x1=>Pull up
;;;1854   //          <0x2=>Out
;;;1855   //        <i>Configure GPIO inout mode
;;;1856   //      </e>
;;;1857   #define PG_6_INOUT_MODE 2
;;;1858   
;;;1859   //      <e6.5>PIN 5
;;;1860   //        <o>Mode
;;;1861   //          <0x0=>Floating
;;;1862   //          <0x1=>Pull up
;;;1863   //          <0x2=>Out
;;;1864   //        <i>Configure GPIO inout mode
;;;1865   //      </e>
;;;1866   #define PG_5_INOUT_MODE 2
;;;1867   
;;;1868   //      <e5.4>PIN 4
;;;1869   //        <o>Mode
;;;1870   //          <0x0=>Floating
;;;1871   //          <0x1=>Pull up
;;;1872   //          <0x2=>Out
;;;1873   //        <i>Configure GPIO inout mode
;;;1874   //      </e>
;;;1875   #define PG_4_INOUT_MODE 2
;;;1876   
;;;1877   //      <e4.3>PIN 3
;;;1878   //        <o>Mode
;;;1879   //          <0x0=>Floating
;;;1880   //          <0x1=>Pull up
;;;1881   //          <0x2=>Out
;;;1882   //        <i>Configure GPIO inout mode
;;;1883   //      </e>
;;;1884   #define PG_3_INOUT_MODE 2
;;;1885   
;;;1886   //      <e3.2>PIN 2
;;;1887   //        <o>Mode
;;;1888   //          <0x0=>Floating
;;;1889   //          <0x1=>Pull up
;;;1890   //          <0x2=>Out
;;;1891   //        <i>Configure GPIO inout mode
;;;1892   //      </e>
;;;1893   #define PG_2_INOUT_MODE 2
;;;1894   
;;;1895   
;;;1896   //      <e2.1>PIN 1
;;;1897   //        <o>Mode
;;;1898   //          <0x0=>Floating
;;;1899   //          <0x1=>Pull up
;;;1900   //          <0x2=>Out
;;;1901   //        <i>Configure GPIO inout mode
;;;1902   //      </e>
;;;1903   #define PG_1_INOUT_MODE 2
;;;1904   
;;;1905   //      <e1.0>PIN 0
;;;1906   //        <o>Mode
;;;1907   //          <0x0=>Floating
;;;1908   //          <0x1=>Pull up
;;;1909   //          <0x2=>Out
;;;1910   //        <i>Configure GPIO inout mode
;;;1911   //      </e>
;;;1912   //    </e>
;;;1913   //  </e>
;;;1914   #define PG_0_INOUT_MODE 2
;;;1915   
;;;1916   #define PG_PIN 0x38
;;;1917   
;;;1918   // init PG group
;;;1919   #if PG_PIN & ONE_BIT(7)         //PIN7
;;;1920       gpio_init(GPIOG,(GPIO_MODE)PG_7_INOUT_MODE,GPIO_PIN_7);
;;;1921   #endif
;;;1922   #if PG_PIN & ONE_BIT(6)         //PIN6
;;;1923       gpio_init(GPIOG,(GPIO_MODE)PG_6_INOUT_MODE,GPIO_PIN_6);
;;;1924   #endif
;;;1925   #if PG_PIN & ONE_BIT(5)         //PIN5
;;;1926       gpio_init(GPIOG,(GPIO_MODE)PG_5_INOUT_MODE,GPIO_PIN_5);
0001dc  4c3c              LDR      r4,|L1.720|
0001de  2220              MOVS     r2,#0x20
0001e0  2102              MOVS     r1,#2
0001e2  4620              MOV      r0,r4
0001e4  f7fffffe          BL       gpio_init
;;;1927   #endif
;;;1928   #if PG_PIN & ONE_BIT(4)         //PIN4
;;;1929       gpio_init(GPIOG,(GPIO_MODE)PG_4_INOUT_MODE,GPIO_PIN_4);
0001e8  2210              MOVS     r2,#0x10
0001ea  2102              MOVS     r1,#2
0001ec  4620              MOV      r0,r4
0001ee  f7fffffe          BL       gpio_init
;;;1930   #endif
;;;1931   #if PG_PIN & ONE_BIT(3)         //PIN3
;;;1932       gpio_init(GPIOG,(GPIO_MODE)PG_3_INOUT_MODE,GPIO_PIN_3);
0001f2  2208              MOVS     r2,#8
0001f4  2102              MOVS     r1,#2
0001f6  4620              MOV      r0,r4
0001f8  f7fffffe          BL       gpio_init
;;;1933   #endif
;;;1934   #if PG_PIN & ONE_BIT(2)         //PIN2
;;;1935       gpio_init(GPIOG,(GPIO_MODE)PG_2_INOUT_MODE,GPIO_PIN_2);
;;;1936   #endif
;;;1937   #if PG_PIN & ONE_BIT(1)         //PIN1
;;;1938       gpio_init(GPIOG,(GPIO_MODE)PG_1_INOUT_MODE,GPIO_PIN_1);
;;;1939   #endif
;;;1940   #if PG_PIN & ONE_BIT(0)         //PIN0
;;;1941       gpio_init(GPIOG,(GPIO_MODE)PG_0_INOUT_MODE,GPIO_PIN_0);
;;;1942   #endif
;;;1943   #endif  // #if PG_EN == 1
;;;1944   #endif
;;;1945   }
0001fc  bd10              POP      {r4,pc}
;;;1946   #endif
                          ENDP

                  peripherals_config PROC
;;;1947   
;;;1948   void peripherals_config(void)
0001fe  b5f0              PUSH     {r4-r7,lr}
000200  20ff              MOVS     r0,#0xff
;;;1949   {
000202  b08d              SUB      sp,sp,#0x34
000204  3081              ADDS     r0,r0,#0x81
000206  f7fffffe          BL       wdt_config
00020a  207d              MOVS     r0,#0x7d
00020c  01c0              LSLS     r0,r0,#7
00020e  f7fffffe          BL       wdt_overflow_count
000212  2000              MOVS     r0,#0
000214  f7fffffe          BL       wdt_overflow_count_win
000218  2000              MOVS     r0,#0
00021a  f7fffffe          BL       can_clock_sel
00021e  4822              LDR      r0,|L1.680|
000220  6841              LDR      r1,[r0,#4]  ; <Data1>
000222  6800              LDR      r0,[r0,#0]  ; <Data1>
000224  900c              STR      r0,[sp,#0x30]
000226  4820              LDR      r0,|L1.680|
000228  910a              STR      r1,[sp,#0x28]
00022a  68c4              LDR      r4,[r0,#0xc]  ; <Data2>
00022c  6883              LDR      r3,[r0,#8]  ; <Data2>
00022e  6942              LDR      r2,[r0,#0x14]  ; <Data2>
000230  6901              LDR      r1,[r0,#0x10]  ; <Data2>
000232  9309              STR      r3,[sp,#0x24]
000234  6a43              LDR      r3,[r0,#0x24]  ; <Data2>
000236  46a6              MOV      lr,r4
000238  469c              MOV      r12,r3
00023a  6a87              LDR      r7,[r0,#0x28]  ; <Data2>
00023c  6a06              LDR      r6,[r0,#0x20]  ; <Data2>
00023e  69c5              LDR      r5,[r0,#0x1c]  ; <Data2>
000240  6984              LDR      r4,[r0,#0x18]  ; <Data2>
000242  6ac3              LDR      r3,[r0,#0x2c]  ; <Data2>
000244  6b00              LDR      r0,[r0,#0x30]  ; <Data2>
000246  9100              STR      r1,[sp,#0]
000248  4661              MOV      r1,r12
00024a  9307              STR      r3,[sp,#0x1c]
00024c  9008              STR      r0,[sp,#0x20]
00024e  9706              STR      r7,[sp,#0x18]
000250  9105              STR      r1,[sp,#0x14]
000252  a801              ADD      r0,sp,#4
000254  c074              STM      r0!,{r2,r4-r6}
000256  4673              MOV      r3,lr
000258  9a09              LDR      r2,[sp,#0x24]
00025a  990a              LDR      r1,[sp,#0x28]
00025c  980c              LDR      r0,[sp,#0x30]
00025e  f7fffffe          BL       can_init
000262  4c11              LDR      r4,|L1.680|
000264  4620              MOV      r0,r4
000266  3034              ADDS     r0,r0,#0x34
000268  c80f              LDM      r0,{r0-r3}
00026a  4684              MOV      r12,r0
00026c  3444              ADDS     r4,r4,#0x44
00026e  ccf1              LDM      r4,{r0,r4-r7}
000270  9704              STR      r7,[sp,#0x10]
000272  466f              MOV      r7,sp
000274  c771              STM      r7!,{r0,r4-r6}
000276  4660              MOV      r0,r12
000278  f7fffffe          BL       adc_init
00027c  227d              MOVS     r2,#0x7d
00027e  0152              LSLS     r2,r2,#5
000280  217b              MOVS     r1,#0x7b
000282  480a              LDR      r0,|L1.684|
000284  f7fffffe          BL       timer_init
000288  22ff              MOVS     r2,#0xff
00028a  3291              ADDS     r2,r2,#0x91
00028c  217b              MOVS     r1,#0x7b
00028e  4808              LDR      r0,|L1.688|
000290  f7fffffe          BL       timer_init
000294  2023              MOVS     r0,#0x23
000296  4907              LDR      r1,|L1.692|
000298  0100              LSLS     r0,r0,#4
00029a  f7fffffe          BL       rtc_init
;;;1950   #ifdef BF7x06AMxx_WDT_DRIVER_PRESENT
;;;1951       wdt_cfg();
;;;1952   #endif
;;;1953   
;;;1954   #ifdef BF7x06AMxx_SCI_DRIVER_PRESENT
;;;1955       sci_config();
;;;1956   #endif
;;;1957   
;;;1958   #ifdef BF7x06AMxx_CAN_DRIVER_PRESENT
;;;1959       can_config();
;;;1960   #endif
;;;1961   
;;;1962   #ifdef BF7x06AMxx_ADC_DRIVER_PRESENT
;;;1963       adc_config();
;;;1964   #endif
;;;1965   
;;;1966   #ifdef BF7x06AMxx_TIMER_DRIVER_PRESENT
;;;1967       timer_config();
;;;1968   #endif
;;;1969   
;;;1970   #ifdef BF7x06AMxx_RTC_DRIVER_PRESENT
;;;1971       rtc_config();
;;;1972   #endif
;;;1973   
;;;1974   #ifdef BF7x06AMxx_PWM_DRIVER_PRESENT
;;;1975       pwm_config();
;;;1976   #endif
;;;1977   
;;;1978   #ifdef BF7x06AMxx_GPIO_DRIVER_PRESENT
;;;1979       gpio_config();
00029e  f7fffffe          BL       gpio_config
;;;1980   #endif
;;;1981   }
0002a2  b00d              ADD      sp,sp,#0x34
0002a4  bdf0              POP      {r4-r7,pc}
;;;1982   
                          ENDP

0002a6  0000              DCW      0x0000
                  |L1.680|
                          DCD      ||.constdata||
                  |L1.684|
                          DCD      0x500b0000
                  |L1.688|
                          DCD      0x500b4000
                  |L1.692|
                          DCD      0x000061a8
                  |L1.696|
                          DCD      0x500a0000
                  |L1.700|
                          DCD      0x500a001c
                  |L1.704|
                          DCD      0x500a0038
                  |L1.708|
                          DCD      0x500a0048
                  |L1.712|
                          DCD      0x500a0064
                  |L1.716|
                          DCD      0x500a0074
                  |L1.720|
                          DCD      0x500a0084

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00c00202          DCB      0x00,0xc0,0x02,0x02
000004  8064010f          DCB      0x80,0x64,0x01,0x0f
000008  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0x0000ffff
000010  ffff0000          DCB      0xff,0xff,0x00,0x00
                          DCD      0x0000ffff
000018  ffff0000          DCB      0xff,0xff,0x00,0x00
                          DCD      0x0000ffff
                          DCD      0x0000ffff
000024  ff000000          DCB      0xff,0x00,0x00,0x00
                          DCD      0x0000ffff
                          DCD      0x0000ffff
000030  ff000000          DCB      0xff,0x00,0x00,0x00
000034  1000              DCB      0x10,0x00
000036  0032              DCW      0x0032
000038  00010000          DCB      0x00,0x01,0x00,0x00
                          DCD      0x0078fcfe
000040  00000003          DCB      0x00,0x00,0x00,0x03
000044  0064              DCW      0x0064
000046  0002              DCB      0x00,0x02
000048  00640dac          DCW      0x0064,0x0dac
                          DCD      0x00000000
000050  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "RTE\\Startup\\BF7006AM64\\BF7006AMxx_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_BF7006AMxx_config_c_e7f6e7ea____REV16|
#line 447 ".\\RTE\\CMSIS\\BF7006AM64\\cmsis_armcc.h"
|__asm___19_BF7006AMxx_config_c_e7f6e7ea____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_BF7006AMxx_config_c_e7f6e7ea____REVSH|
#line 462
|__asm___19_BF7006AMxx_config_c_e7f6e7ea____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
