; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave --gnu -o.\obj\segger_rtt.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\obj\segger_rtt.d --cpu=Cortex-M0 --apcs=interwork -Otime --diag_suppress=9931 -I.\src\pt -I.\src -I.\config -I.\RTE\CMSIS\BF7006AM64 -I.\RTE\Device\BF7006AM64 -I.\RTE\SEGGER -I.\RTE\Startup\BF7006AM64 -I.\RTE\_b40 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\BYD\BYDMicro_DFP\1.1.0\Device\Include\BF7006AMxx -D__UVISION_VERSION=536 -D_RTE_ -D_RTE_ --omf_browse=.\obj\segger_rtt.crf RTE\SEGGER\SEGGER_RTT.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _DoInit PROC
;;;301    
;;;302    static void _DoInit(void) {
000000  b510              PUSH     {r4,lr}
;;;303      volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
;;;304      //
;;;305      // Initialize control block
;;;306      //
;;;307      p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
000002  4cfb              LDR      r4,|L1.1008|
;;;308      p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
000004  2001              MOVS     r0,#1
000006  6120              STR      r0,[r4,#0x10]
;;;309      p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
000008  6160              STR      r0,[r4,#0x14]
;;;310      //
;;;311      // Initialize up buffer 0
;;;312      //
;;;313      p->aUp[0].sName         = "Terminal";
00000a  a0fa              ADR      r0,|L1.1012|
00000c  61a0              STR      r0,[r4,#0x18]
;;;314      p->aUp[0].pBuffer       = _acUpBuffer;
00000e  48fc              LDR      r0,|L1.1024|
000010  61e0              STR      r0,[r4,#0x1c]
;;;315      p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
000012  20ff              MOVS     r0,#0xff
000014  3001              ADDS     r0,#1
000016  6220              STR      r0,[r4,#0x20]
;;;316      p->aUp[0].RdOff         = 0u;
000018  2100              MOVS     r1,#0
00001a  62a1              STR      r1,[r4,#0x28]
;;;317      p->aUp[0].WrOff         = 0u;
00001c  6261              STR      r1,[r4,#0x24]
;;;318      p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
00001e  62e1              STR      r1,[r4,#0x2c]
;;;319      //
;;;320      // Initialize down buffer 0
;;;321      //
;;;322      p->aDown[0].sName         = "Terminal";
000020  a0f4              ADR      r0,|L1.1012|
000022  6320              STR      r0,[r4,#0x30]
;;;323      p->aDown[0].pBuffer       = _acDownBuffer;
000024  48f7              LDR      r0,|L1.1028|
000026  6360              STR      r0,[r4,#0x34]
;;;324      p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
000028  2010              MOVS     r0,#0x10
00002a  63a0              STR      r0,[r4,#0x38]
;;;325      p->aDown[0].RdOff         = 0u;
00002c  6421              STR      r1,[r4,#0x40]
;;;326      p->aDown[0].WrOff         = 0u;
00002e  63e1              STR      r1,[r4,#0x3c]
;;;327      p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000030  6461              STR      r1,[r4,#0x44]
;;;328      //
;;;329      // Finish initialization of the control block.
;;;330      // Copy Id string in three steps to make sure "SEGGER RTT" is not found
;;;331      // in initializer memory (usually flash) by J-Link
;;;332      //
;;;333      STRCPY((char*)&p->acID[7], "RTT");
000032  2052              MOVS     r0,#0x52
000034  71e0              STRB     r0,[r4,#7]
000036  2054              MOVS     r0,#0x54
000038  7220              STRB     r0,[r4,#8]
00003a  7260              STRB     r0,[r4,#9]
00003c  72a1              STRB     r1,[r4,#0xa]
;;;334      RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
;;;335      STRCPY((char*)&p->acID[0], "SEGGER");
00003e  4620              MOV      r0,r4
000040  a1f1              ADR      r1,|L1.1032|
000042  f7fffffe          BL       __ARM_common_memcpy4_7
;;;336      RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
;;;337      p->acID[6] = ' ';
000046  2020              MOVS     r0,#0x20
000048  71a0              STRB     r0,[r4,#6]
;;;338      RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
;;;339    }
00004a  bd10              POP      {r4,pc}
;;;340    
                          ENDP

                  _WriteBlocking PROC
;;;359    */
;;;360    static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
00004c  b5f7              PUSH     {r0-r2,r4-r7,lr}
00004e  4605              MOV      r5,r0
000050  b082              SUB      sp,sp,#8
;;;361      unsigned NumBytesToWrite;
;;;362      unsigned NumBytesWritten;
;;;363      unsigned RdOff;
;;;364      unsigned WrOff;
;;;365      volatile char* pDst;
;;;366      //
;;;367      // Write data to buffer and handle wrap-around if necessary
;;;368      //
;;;369      NumBytesWritten = 0u;
000052  2000              MOVS     r0,#0
;;;370      WrOff = pRing->WrOff;
000054  9000              STR      r0,[sp,#0]
000056  68ec              LDR      r4,[r5,#0xc]
000058  4616              MOV      r6,r2                 ;360
                  |L1.90|
;;;371      do {
;;;372        RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
00005a  6928              LDR      r0,[r5,#0x10]
;;;373        if (RdOff > WrOff) {
00005c  42a0              CMP      r0,r4
00005e  d901              BLS      |L1.100|
;;;374          NumBytesToWrite = RdOff - WrOff - 1u;
000060  1b07              SUBS     r7,r0,r4
000062  e002              B        |L1.106|
                  |L1.100|
;;;375        } else {
;;;376          NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
000064  68a9              LDR      r1,[r5,#8]
000066  1a20              SUBS     r0,r4,r0
000068  1a0f              SUBS     r7,r1,r0
                  |L1.106|
;;;377        }
;;;378        NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
00006a  68a8              LDR      r0,[r5,#8]
00006c  1e7f              SUBS     r7,r7,#1              ;376
00006e  1b00              SUBS     r0,r0,r4
000070  42b8              CMP      r0,r7
000072  d800              BHI      |L1.118|
000074  4607              MOV      r7,r0
                  |L1.118|
;;;379        NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
000076  42b7              CMP      r7,r6
000078  d300              BCC      |L1.124|
00007a  4637              MOV      r7,r6
                  |L1.124|
;;;380        pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
00007c  6868              LDR      r0,[r5,#4]
;;;381    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;382        NumBytesWritten += NumBytesToWrite;
;;;383        NumBytes        -= NumBytesToWrite;
;;;384        WrOff           += NumBytesToWrite;
;;;385        while (NumBytesToWrite--) {
;;;386          *pDst++ = *pBuffer++;
;;;387        };
;;;388    #else
;;;389        SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
00007e  463a              MOV      r2,r7
000080  1900              ADDS     r0,r0,r4              ;380
000082  9903              LDR      r1,[sp,#0xc]
000084  f7fffffe          BL       __aeabi_memcpy
;;;390        NumBytesWritten += NumBytesToWrite;
000088  9800              LDR      r0,[sp,#0]
;;;391        pBuffer         += NumBytesToWrite;
;;;392        NumBytes        -= NumBytesToWrite;
00008a  1bf6              SUBS     r6,r6,r7
00008c  19c0              ADDS     r0,r0,r7              ;390
00008e  9000              STR      r0,[sp,#0]            ;391
000090  9803              LDR      r0,[sp,#0xc]          ;391
;;;393        WrOff           += NumBytesToWrite;
000092  19e4              ADDS     r4,r4,r7
000094  19c0              ADDS     r0,r0,r7              ;391
;;;394    #endif
;;;395        if (WrOff == pRing->SizeOfBuffer) {
000096  9003              STR      r0,[sp,#0xc]
000098  68a8              LDR      r0,[r5,#8]
00009a  42a0              CMP      r0,r4
00009c  d100              BNE      |L1.160|
;;;396          WrOff = 0u;
00009e  2400              MOVS     r4,#0
                  |L1.160|
;;;397        }
;;;398        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;399        pRing->WrOff = WrOff;
;;;400      } while (NumBytes);
0000a0  60ec              STR      r4,[r5,#0xc]
0000a2  2e00              CMP      r6,#0
0000a4  d1d9              BNE      |L1.90|
;;;401      return NumBytesWritten;
0000a6  9800              LDR      r0,[sp,#0]
;;;402    }
0000a8  b005              ADD      sp,sp,#0x14
0000aa  bdf0              POP      {r4-r7,pc}
;;;403    
                          ENDP

                  _WriteNoCheck PROC
;;;421    */
;;;422    static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
0000ac  b5f7              PUSH     {r0-r2,r4-r7,lr}
0000ae  4604              MOV      r4,r0
;;;423      unsigned NumBytesAtOnce;
;;;424      unsigned WrOff;
;;;425      unsigned Rem;
;;;426      volatile char* pDst;
;;;427    
;;;428      WrOff = pRing->WrOff;
;;;429      Rem = pRing->SizeOfBuffer - WrOff;
0000b0  68c7              LDR      r7,[r0,#0xc]
0000b2  6880              LDR      r0,[r0,#8]
0000b4  68e1              LDR      r1,[r4,#0xc]          ;428
0000b6  1bc5              SUBS     r5,r0,r7
;;;430      if (Rem > NumBytes) {
;;;431        //
;;;432        // All data fits before wrap around
;;;433        //
;;;434        pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
0000b8  6860              LDR      r0,[r4,#4]
0000ba  4616              MOV      r6,r2                 ;422
0000bc  1840              ADDS     r0,r0,r1
0000be  42b5              CMP      r5,r6                 ;430
0000c0  d906              BLS      |L1.208|
;;;435    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;436        WrOff += NumBytes;
;;;437        while (NumBytes--) {
;;;438          *pDst++ = *pData++;
;;;439        };
;;;440        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;441        pRing->WrOff = WrOff;
;;;442    #else
;;;443        SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
0000c2  9901              LDR      r1,[sp,#4]
0000c4  f7fffffe          BL       __aeabi_memcpy
;;;444        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;445        pRing->WrOff = WrOff + NumBytes;
0000c8  19b8              ADDS     r0,r7,r6
0000ca  60e0              STR      r0,[r4,#0xc]
;;;446    #endif
;;;447      } else {
;;;448        //
;;;449        // We reach the end of the buffer, so need to wrap around
;;;450        //
;;;451    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;452        pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
;;;453        NumBytesAtOnce = Rem;
;;;454        while (NumBytesAtOnce--) {
;;;455          *pDst++ = *pData++;
;;;456        };
;;;457        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
;;;458        NumBytesAtOnce = NumBytes - Rem;
;;;459        while (NumBytesAtOnce--) {
;;;460          *pDst++ = *pData++;
;;;461        };
;;;462        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;463        pRing->WrOff = NumBytes - Rem;
;;;464    #else
;;;465        NumBytesAtOnce = Rem;
;;;466        pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
;;;467        SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
;;;468        NumBytesAtOnce = NumBytes - Rem;
;;;469        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
;;;470        SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
;;;471        RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;472        pRing->WrOff = NumBytesAtOnce;
;;;473    #endif
;;;474      }
;;;475    }
0000cc  b003              ADD      sp,sp,#0xc
0000ce  bdf0              POP      {r4-r7,pc}
                  |L1.208|
0000d0  462a              MOV      r2,r5                 ;467
0000d2  9901              LDR      r1,[sp,#4]            ;467
0000d4  f7fffffe          BL       __aeabi_memcpy
0000d8  9801              LDR      r0,[sp,#4]            ;470
0000da  6863              LDR      r3,[r4,#4]            ;470
0000dc  1b76              SUBS     r6,r6,r5              ;468
0000de  1941              ADDS     r1,r0,r5              ;470
0000e0  4632              MOV      r2,r6                 ;470
0000e2  4618              MOV      r0,r3                 ;470
0000e4  f7fffffe          BL       __aeabi_memcpy
0000e8  60e6              STR      r6,[r4,#0xc]          ;472
0000ea  b003              ADD      sp,sp,#0xc
0000ec  bdf0              POP      {r4-r7,pc}
;;;476    
                          ENDP

                  SEGGER_RTT_ReadUpBufferNoLock PROC
;;;558    */
;;;559    unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
0000ee  b5f0              PUSH     {r4-r7,lr}
0000f0  4616              MOV      r6,r2
;;;560      unsigned                NumBytesRem;
;;;561      unsigned                NumBytesRead;
;;;562      unsigned                RdOff;
;;;563      unsigned                WrOff;
;;;564      unsigned char*          pBuffer;
;;;565      SEGGER_RTT_BUFFER_UP*   pRing;
;;;566      volatile char*          pSrc;
;;;567    
;;;568      INIT();
0000f2  4abf              LDR      r2,|L1.1008|
0000f4  4605              MOV      r5,r0                 ;559
0000f6  7810              LDRB     r0,[r2,#0]
0000f8  b083              SUB      sp,sp,#0xc            ;559
0000fa  460c              MOV      r4,r1                 ;559
0000fc  2800              CMP      r0,#0
0000fe  d101              BNE      |L1.260|
000100  f7fffffe          BL       _DoInit
                  |L1.260|
;;;569      pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000104  2018              MOVS     r0,#0x18
000106  4345              MULS     r5,r0,r5
000108  48b9              LDR      r0,|L1.1008|
;;;570      pBuffer = (unsigned char*)pData;
;;;571      RdOff = pRing->RdOff;
00010a  9400              STR      r4,[sp,#0]
00010c  182d              ADDS     r5,r5,r0              ;569
00010e  6aac              LDR      r4,[r5,#0x28]
;;;572      WrOff = pRing->WrOff;
000110  6a68              LDR      r0,[r5,#0x24]
;;;573      NumBytesRead = 0u;
000112  2700              MOVS     r7,#0
000114  3518              ADDS     r5,r5,#0x18
;;;574      //
;;;575      // Read from current read position to wrap-around of buffer, first
;;;576      //
;;;577      if (RdOff > WrOff) {
000116  9001              STR      r0,[sp,#4]
000118  4284              CMP      r4,r0
00011a  d913              BLS      |L1.324|
;;;578        NumBytesRem = pRing->SizeOfBuffer - RdOff;
00011c  68a8              LDR      r0,[r5,#8]
00011e  1b07              SUBS     r7,r0,r4
;;;579        NumBytesRem = MIN(NumBytesRem, BufferSize);
000120  42b7              CMP      r7,r6
000122  d300              BCC      |L1.294|
000124  4637              MOV      r7,r6
                  |L1.294|
;;;580        pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
000126  6868              LDR      r0,[r5,#4]
;;;581    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;582        NumBytesRead += NumBytesRem;
;;;583        BufferSize   -= NumBytesRem;
;;;584        RdOff        += NumBytesRem;
;;;585        while (NumBytesRem--) {
;;;586          *pBuffer++ = *pSrc++;
;;;587        };
;;;588    #else
;;;589        SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
000128  463a              MOV      r2,r7
00012a  1901              ADDS     r1,r0,r4              ;580
00012c  9800              LDR      r0,[sp,#0]
00012e  f7fffffe          BL       __aeabi_memcpy
;;;590        NumBytesRead += NumBytesRem;
;;;591        pBuffer      += NumBytesRem;
000132  9800              LDR      r0,[sp,#0]
;;;592        BufferSize   -= NumBytesRem;
000134  1bf6              SUBS     r6,r6,r7
000136  19c0              ADDS     r0,r0,r7              ;591
;;;593        RdOff        += NumBytesRem;
;;;594    #endif
;;;595        //
;;;596        // Handle wrap-around of buffer
;;;597        //
;;;598        if (RdOff == pRing->SizeOfBuffer) {
000138  9000              STR      r0,[sp,#0]
00013a  68a8              LDR      r0,[r5,#8]
00013c  19e4              ADDS     r4,r4,r7              ;593
00013e  42a0              CMP      r0,r4
000140  d100              BNE      |L1.324|
;;;599          RdOff = 0u;
000142  2400              MOVS     r4,#0
                  |L1.324|
;;;600        }
;;;601      }
;;;602      //
;;;603      // Read remaining items of buffer
;;;604      //
;;;605      NumBytesRem = WrOff - RdOff;
000144  9801              LDR      r0,[sp,#4]
000146  1b00              SUBS     r0,r0,r4
;;;606      NumBytesRem = MIN(NumBytesRem, BufferSize);
000148  42b0              CMP      r0,r6
00014a  d200              BCS      |L1.334|
00014c  4606              MOV      r6,r0
                  |L1.334|
;;;607      if (NumBytesRem > 0u) {
00014e  2e00              CMP      r6,#0
000150  d007              BEQ      |L1.354|
;;;608        pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
000152  6868              LDR      r0,[r5,#4]
;;;609    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;610        NumBytesRead += NumBytesRem;
;;;611        BufferSize   -= NumBytesRem;
;;;612        RdOff        += NumBytesRem;
;;;613        while (NumBytesRem--) {
;;;614          *pBuffer++ = *pSrc++;
;;;615        };
;;;616    #else
;;;617        SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
000154  4632              MOV      r2,r6
000156  1901              ADDS     r1,r0,r4              ;608
000158  9800              LDR      r0,[sp,#0]
00015a  f7fffffe          BL       __aeabi_memcpy
;;;618        NumBytesRead += NumBytesRem;
00015e  19bf              ADDS     r7,r7,r6
;;;619        pBuffer      += NumBytesRem;
;;;620        BufferSize   -= NumBytesRem;
;;;621        RdOff        += NumBytesRem;
000160  19a4              ADDS     r4,r4,r6
                  |L1.354|
;;;622    #endif
;;;623      }
;;;624      //
;;;625      // Update read offset of buffer
;;;626      //
;;;627      if (NumBytesRead) {
000162  2f00              CMP      r7,#0
000164  d000              BEQ      |L1.360|
;;;628        pRing->RdOff = RdOff;
000166  612c              STR      r4,[r5,#0x10]
                  |L1.360|
;;;629      }
;;;630      //
;;;631      return NumBytesRead;
000168  4638              MOV      r0,r7
;;;632    }
00016a  b003              ADD      sp,sp,#0xc
00016c  bdf0              POP      {r4-r7,pc}
;;;633    
                          ENDP

                  SEGGER_RTT_ReadNoLock PROC
;;;650    */
;;;651    unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
00016e  b5f0              PUSH     {r4-r7,lr}
000170  4616              MOV      r6,r2
;;;652      unsigned                NumBytesRem;
;;;653      unsigned                NumBytesRead;
;;;654      unsigned                RdOff;
;;;655      unsigned                WrOff;
;;;656      unsigned char*          pBuffer;
;;;657      SEGGER_RTT_BUFFER_DOWN* pRing;
;;;658      volatile char*          pSrc;
;;;659      //
;;;660      INIT();
000172  4a9f              LDR      r2,|L1.1008|
000174  4605              MOV      r5,r0                 ;651
000176  7810              LDRB     r0,[r2,#0]
000178  b083              SUB      sp,sp,#0xc            ;651
00017a  460c              MOV      r4,r1                 ;651
00017c  2800              CMP      r0,#0
00017e  d101              BNE      |L1.388|
000180  f7fffffe          BL       _DoInit
                  |L1.388|
;;;661      pRing = (SEGGER_RTT_BUFFER_DOWN*)((char*)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000184  2018              MOVS     r0,#0x18
000186  4345              MULS     r5,r0,r5
000188  4899              LDR      r0,|L1.1008|
;;;662      pBuffer = (unsigned char*)pData;
;;;663      RdOff = pRing->RdOff;
00018a  9400              STR      r4,[sp,#0]
00018c  182d              ADDS     r5,r5,r0              ;661
;;;664      WrOff = pRing->WrOff;
00018e  6c2c              LDR      r4,[r5,#0x40]
000190  6be8              LDR      r0,[r5,#0x3c]
;;;665      NumBytesRead = 0u;
000192  2700              MOVS     r7,#0
000194  3530              ADDS     r5,r5,#0x30
;;;666      //
;;;667      // Read from current read position to wrap-around of buffer, first
;;;668      //
;;;669      if (RdOff > WrOff) {
000196  9001              STR      r0,[sp,#4]
000198  4284              CMP      r4,r0
00019a  d913              BLS      |L1.452|
;;;670        NumBytesRem = pRing->SizeOfBuffer - RdOff;
00019c  68a8              LDR      r0,[r5,#8]
00019e  1b07              SUBS     r7,r0,r4
;;;671        NumBytesRem = MIN(NumBytesRem, BufferSize);
0001a0  42b7              CMP      r7,r6
0001a2  d300              BCC      |L1.422|
0001a4  4637              MOV      r7,r6
                  |L1.422|
;;;672        pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
0001a6  6868              LDR      r0,[r5,#4]
;;;673    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;674        NumBytesRead += NumBytesRem;
;;;675        BufferSize   -= NumBytesRem;
;;;676        RdOff        += NumBytesRem;
;;;677        while (NumBytesRem--) {
;;;678          *pBuffer++ = *pSrc++;
;;;679        };
;;;680    #else
;;;681        SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
0001a8  463a              MOV      r2,r7
0001aa  1901              ADDS     r1,r0,r4              ;672
0001ac  9800              LDR      r0,[sp,#0]
0001ae  f7fffffe          BL       __aeabi_memcpy
;;;682        NumBytesRead += NumBytesRem;
;;;683        pBuffer      += NumBytesRem;
0001b2  9800              LDR      r0,[sp,#0]
;;;684        BufferSize   -= NumBytesRem;
0001b4  1bf6              SUBS     r6,r6,r7
0001b6  19c0              ADDS     r0,r0,r7              ;683
;;;685        RdOff        += NumBytesRem;
;;;686    #endif
;;;687        //
;;;688        // Handle wrap-around of buffer
;;;689        //
;;;690        if (RdOff == pRing->SizeOfBuffer) {
0001b8  9000              STR      r0,[sp,#0]
0001ba  68a8              LDR      r0,[r5,#8]
0001bc  19e4              ADDS     r4,r4,r7              ;685
0001be  42a0              CMP      r0,r4
0001c0  d100              BNE      |L1.452|
;;;691          RdOff = 0u;
0001c2  2400              MOVS     r4,#0
                  |L1.452|
;;;692        }
;;;693      }
;;;694      //
;;;695      // Read remaining items of buffer
;;;696      //
;;;697      NumBytesRem = WrOff - RdOff;
0001c4  9801              LDR      r0,[sp,#4]
0001c6  1b00              SUBS     r0,r0,r4
;;;698      NumBytesRem = MIN(NumBytesRem, BufferSize);
0001c8  42b0              CMP      r0,r6
0001ca  d200              BCS      |L1.462|
0001cc  4606              MOV      r6,r0
                  |L1.462|
;;;699      if (NumBytesRem > 0u) {
0001ce  2e00              CMP      r6,#0
0001d0  d007              BEQ      |L1.482|
;;;700        pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
0001d2  6868              LDR      r0,[r5,#4]
;;;701    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;702        NumBytesRead += NumBytesRem;
;;;703        BufferSize   -= NumBytesRem;
;;;704        RdOff        += NumBytesRem;
;;;705        while (NumBytesRem--) {
;;;706          *pBuffer++ = *pSrc++;
;;;707        };
;;;708    #else
;;;709        SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
0001d4  4632              MOV      r2,r6
0001d6  1901              ADDS     r1,r0,r4              ;700
0001d8  9800              LDR      r0,[sp,#0]
0001da  f7fffffe          BL       __aeabi_memcpy
;;;710        NumBytesRead += NumBytesRem;
0001de  19bf              ADDS     r7,r7,r6
;;;711        pBuffer      += NumBytesRem;
;;;712        BufferSize   -= NumBytesRem;
;;;713        RdOff        += NumBytesRem;
0001e0  19a4              ADDS     r4,r4,r6
                  |L1.482|
;;;714    #endif
;;;715      }
;;;716      if (NumBytesRead) {
0001e2  2f00              CMP      r7,#0
0001e4  d000              BEQ      |L1.488|
;;;717        pRing->RdOff = RdOff;
0001e6  612c              STR      r4,[r5,#0x10]
                  |L1.488|
;;;718      }
;;;719      //
;;;720      return NumBytesRead;
0001e8  4638              MOV      r0,r7
;;;721    }
0001ea  b003              ADD      sp,sp,#0xc
0001ec  bdf0              POP      {r4-r7,pc}
;;;722    
                          ENDP

                  SEGGER_RTT_ReadUpBuffer PROC
;;;747    */
;;;748    unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
0001ee  b510              PUSH     {r4,lr}
;;;749      unsigned NumBytesRead;
;;;750    
;;;751      SEGGER_RTT_LOCK();
0001f0  f3ef8410          MRS      r4,PRIMASK
0001f4  2301              MOVS     r3,#1
0001f6  f3838810          MSR      PRIMASK,r3
;;;752      //
;;;753      // Call the non-locking read function
;;;754      //
;;;755      NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
0001fa  f7fffffe          BL       SEGGER_RTT_ReadUpBufferNoLock
;;;756      //
;;;757      // Finish up.
;;;758      //
;;;759      SEGGER_RTT_UNLOCK();
0001fe  b2e1              UXTB     r1,r4
000200  f3818810          MSR      PRIMASK,r1
;;;760      //
;;;761      return NumBytesRead;
;;;762    }
000204  bd10              POP      {r4,pc}
;;;763    
                          ENDP

                  SEGGER_RTT_Read PROC
;;;779    */
;;;780    unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000206  b510              PUSH     {r4,lr}
;;;781      unsigned NumBytesRead;
;;;782    
;;;783      SEGGER_RTT_LOCK();
000208  f3ef8410          MRS      r4,PRIMASK
00020c  2301              MOVS     r3,#1
00020e  f3838810          MSR      PRIMASK,r3
;;;784      //
;;;785      // Call the non-locking read function
;;;786      //
;;;787      NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
000212  f7fffffe          BL       SEGGER_RTT_ReadNoLock
;;;788      //
;;;789      // Finish up.
;;;790      //
;;;791      SEGGER_RTT_UNLOCK();
000216  b2e1              UXTB     r1,r4
000218  f3818810          MSR      PRIMASK,r1
;;;792      //
;;;793      return NumBytesRead;
;;;794    }
00021c  bd10              POP      {r4,pc}
;;;795    
                          ENDP

                  SEGGER_RTT_WriteWithOverwriteNoLock PROC
;;;818    */
;;;819    void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
00021e  b5f8              PUSH     {r3-r7,lr}
000220  460f              MOV      r7,r1
;;;820      const char*           pData;
;;;821      SEGGER_RTT_BUFFER_UP* pRing;
;;;822      unsigned              Avail;
;;;823      volatile char*        pDst;
;;;824      //
;;;825      // Get "to-host" ring buffer and copy some elements into local variables.
;;;826      //
;;;827      pData = (const char *)pBuffer;
;;;828      pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000222  2118              MOVS     r1,#0x18
000224  4348              MULS     r0,r1,r0
000226  4972              LDR      r1,|L1.1008|
000228  4615              MOV      r5,r2                 ;819
00022a  1844              ADDS     r4,r0,r1
;;;829      //
;;;830      // Check if we will overwrite data and need to adjust the RdOff.
;;;831      //
;;;832      if (pRing->WrOff == pRing->RdOff) {
00022c  6aa1              LDR      r1,[r4,#0x28]
00022e  6a60              LDR      r0,[r4,#0x24]
000230  3418              ADDS     r4,r4,#0x18
000232  4288              CMP      r0,r1
000234  d101              BNE      |L1.570|
;;;833        Avail = pRing->SizeOfBuffer - 1u;
000236  68a0              LDR      r0,[r4,#8]
000238  e004              B        |L1.580|
                  |L1.570|
;;;834      } else if ( pRing->WrOff < pRing->RdOff) {
00023a  6921              LDR      r1,[r4,#0x10]
00023c  4288              CMP      r0,r1
;;;835        Avail = pRing->RdOff - pRing->WrOff - 1u;
;;;836      } else {
;;;837        Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
00023e  6921              LDR      r1,[r4,#0x10]
000240  d202              BCS      |L1.584|
000242  1a08              SUBS     r0,r1,r0              ;835
                  |L1.580|
000244  1e40              SUBS     r0,r0,#1              ;835
000246  e003              B        |L1.592|
                  |L1.584|
000248  1a08              SUBS     r0,r1,r0
00024a  68a1              LDR      r1,[r4,#8]
00024c  1e40              SUBS     r0,r0,#1
00024e  1840              ADDS     r0,r0,r1
                  |L1.592|
;;;838      }
;;;839      if (NumBytes > Avail) {
000250  4285              CMP      r5,r0
000252  d90d              BLS      |L1.624|
;;;840        pRing->RdOff += (NumBytes - Avail);
000254  6921              LDR      r1,[r4,#0x10]
000256  1a28              SUBS     r0,r5,r0
000258  1808              ADDS     r0,r1,r0
00025a  6120              STR      r0,[r4,#0x10]
;;;841        while (pRing->RdOff >= pRing->SizeOfBuffer) {
00025c  6921              LDR      r1,[r4,#0x10]
00025e  68a0              LDR      r0,[r4,#8]
000260  4281              CMP      r1,r0
000262  d305              BCC      |L1.624|
                  |L1.612|
;;;842          pRing->RdOff -= pRing->SizeOfBuffer;
000264  6921              LDR      r1,[r4,#0x10]
000266  1a09              SUBS     r1,r1,r0
000268  6121              STR      r1,[r4,#0x10]
00026a  6921              LDR      r1,[r4,#0x10]         ;841
00026c  4281              CMP      r1,r0                 ;841
00026e  d2f9              BCS      |L1.612|
                  |L1.624|
;;;843        }
;;;844      }
;;;845      //
;;;846      // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
;;;847      //
;;;848      Avail = pRing->SizeOfBuffer - pRing->WrOff;
000270  68e1              LDR      r1,[r4,#0xc]
000272  68a0              LDR      r0,[r4,#8]
000274  1a46              SUBS     r6,r0,r1
                  |L1.630|
;;;849      do {
;;;850        if (Avail > NumBytes) {
000276  68e1              LDR      r1,[r4,#0xc]
000278  6860              LDR      r0,[r4,#4]
00027a  42ae              CMP      r6,r5
00027c  d908              BLS      |L1.656|
;;;851          //
;;;852          // Last round
;;;853          //
;;;854          pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
00027e  1840              ADDS     r0,r0,r1
;;;855    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;856          Avail = NumBytes;
;;;857          while (NumBytes--) {
;;;858            *pDst++ = *pData++;
;;;859          };
;;;860          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;861          pRing->WrOff += Avail;
;;;862    #else
;;;863          SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
000280  462a              MOV      r2,r5
000282  4639              MOV      r1,r7
000284  f7fffffe          BL       __aeabi_memcpy
;;;864          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;865          pRing->WrOff += NumBytes;
000288  68e0              LDR      r0,[r4,#0xc]
00028a  1940              ADDS     r0,r0,r5
;;;866    #endif
;;;867          break;
00028c  60e0              STR      r0,[r4,#0xc]
;;;868        } else {
;;;869          //
;;;870          //  Wrap-around necessary, write until wrap-around and reset WrOff
;;;871          //
;;;872          pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
;;;873    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;874          NumBytes -= Avail;
;;;875          while (Avail--) {
;;;876            *pDst++ = *pData++;
;;;877          };
;;;878          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;879          pRing->WrOff = 0;
;;;880    #else
;;;881          SEGGER_RTT_MEMCPY((void*)pDst, pData, Avail);
;;;882          pData += Avail;
;;;883          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;884          pRing->WrOff = 0;
;;;885          NumBytes -= Avail;
;;;886    #endif
;;;887          Avail = (pRing->SizeOfBuffer - 1);
;;;888        }
;;;889      } while (NumBytes);
;;;890    }
00028e  bdf8              POP      {r3-r7,pc}
                  |L1.656|
000290  1840              ADDS     r0,r0,r1              ;872
000292  4632              MOV      r2,r6                 ;881
000294  4639              MOV      r1,r7                 ;881
000296  f7fffffe          BL       __aeabi_memcpy
00029a  2000              MOVS     r0,#0                 ;884
00029c  19bf              ADDS     r7,r7,r6              ;882
00029e  1bad              SUBS     r5,r5,r6              ;885
0002a0  60e0              STR      r0,[r4,#0xc]          ;887
0002a2  68a6              LDR      r6,[r4,#8]            ;887
0002a4  1e76              SUBS     r6,r6,#1              ;887
0002a6  2d00              CMP      r5,#0                 ;889
0002a8  d1e5              BNE      |L1.630|
0002aa  bdf8              POP      {r3-r7,pc}
;;;891    
                          ENDP

                  SEGGER_RTT_WriteSkipNoLock PROC
;;;919    #if (RTT_USE_ASM == 0)
;;;920    unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
0002ac  b5f8              PUSH     {r3-r7,lr}
;;;921      const char*           pData;
;;;922      SEGGER_RTT_BUFFER_UP* pRing;
;;;923      unsigned              Avail;
;;;924      unsigned              RdOff;
;;;925      unsigned              WrOff;
;;;926      unsigned              Rem;
;;;927      volatile char*        pDst;
;;;928      //
;;;929      // Cases:
;;;930      //   1) RdOff <= WrOff => Space until wrap-around is sufficient
;;;931      //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
;;;932      //   3) RdOff <  WrOff => No space in buf
;;;933      //   4) RdOff >  WrOff => Space is sufficient
;;;934      //   5) RdOff >  WrOff => No space in buf
;;;935      //
;;;936      // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
;;;937      //
;;;938      pData = (const char *)pBuffer;
;;;939      pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0002ae  9100              STR      r1,[sp,#0]
0002b0  2118              MOVS     r1,#0x18
0002b2  4348              MULS     r0,r1,r0
0002b4  494e              LDR      r1,|L1.1008|
0002b6  4616              MOV      r6,r2                 ;920
0002b8  1844              ADDS     r4,r0,r1
;;;940      RdOff = pRing->RdOff;
0002ba  6aa0              LDR      r0,[r4,#0x28]
;;;941      WrOff = pRing->WrOff;
0002bc  6a65              LDR      r5,[r4,#0x24]
0002be  3418              ADDS     r4,r4,#0x18
;;;942      if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
0002c0  42a8              CMP      r0,r5
0002c2  d820              BHI      |L1.774|
;;;943        Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
0002c4  68a1              LDR      r1,[r4,#8]
0002c6  1b4f              SUBS     r7,r1,r5
0002c8  1e79              SUBS     r1,r7,#1
;;;944        if (Avail >= NumBytes) {                            // Case 1)?
0002ca  42b1              CMP      r1,r6
0002cc  d307              BCC      |L1.734|
                  |L1.718|
;;;945    CopyStraight:
;;;946          pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
0002ce  6860              LDR      r0,[r4,#4]
;;;947          memcpy((void*)pDst, pData, NumBytes);
0002d0  9900              LDR      r1,[sp,#0]
0002d2  1940              ADDS     r0,r0,r5              ;946
0002d4  f7fffffe          BL       __aeabi_memcpy
;;;948          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;949          pRing->WrOff = WrOff + NumBytes;
0002d8  19a8              ADDS     r0,r5,r6
;;;950          return 1;
0002da  60e0              STR      r0,[r4,#0xc]
0002dc  e011              B        |L1.770|
                  |L1.734|
;;;951        }
;;;952        Avail += RdOff;                                     // Space incl. wrap-around
0002de  1808              ADDS     r0,r1,r0
;;;953        if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
0002e0  42b0              CMP      r0,r6
0002e2  d314              BCC      |L1.782|
;;;954          Rem = pRing->SizeOfBuffer - WrOff;                // Space until end of buffer
;;;955          pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
0002e4  6860              LDR      r0,[r4,#4]
;;;956          memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
0002e6  463a              MOV      r2,r7
0002e8  1940              ADDS     r0,r0,r5              ;955
0002ea  9900              LDR      r1,[sp,#0]
0002ec  f7fffffe          BL       __aeabi_memcpy
;;;957          NumBytes -= Rem;
0002f0  1bf5              SUBS     r5,r6,r7
;;;958          //
;;;959          // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
;;;960          // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
;;;961          // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
;;;962          // Therefore, check if 2nd memcpy is necessary at all
;;;963          //
;;;964          if (NumBytes) {
0002f2  d005              BEQ      |L1.768|
;;;965            pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
;;;966            memcpy((void*)pDst, pData + Rem, NumBytes);
0002f4  9900              LDR      r1,[sp,#0]
0002f6  6860              LDR      r0,[r4,#4]
0002f8  19c9              ADDS     r1,r1,r7
0002fa  462a              MOV      r2,r5
0002fc  f7fffffe          BL       __aeabi_memcpy
                  |L1.768|
;;;967          }
;;;968          RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;969          pRing->WrOff = NumBytes;
000300  60e5              STR      r5,[r4,#0xc]
                  |L1.770|
;;;970          return 1;
000302  2001              MOVS     r0,#1
;;;971        }
;;;972      } else {                                             // Potential case 4)
;;;973        Avail = RdOff - WrOff - 1u;
;;;974        if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
;;;975          goto CopyStraight;
;;;976        }
;;;977      }
;;;978      return 0;     // No space in buffer
;;;979    }
000304  bdf8              POP      {r3-r7,pc}
                  |L1.774|
000306  1b40              SUBS     r0,r0,r5              ;973
000308  1e40              SUBS     r0,r0,#1              ;973
00030a  42b0              CMP      r0,r6                 ;974
00030c  d2df              BCS      |L1.718|
                  |L1.782|
00030e  2000              MOVS     r0,#0                 ;978
000310  bdf8              POP      {r3-r7,pc}
;;;980    #endif
                          ENDP

                  SEGGER_RTT_WriteDownBufferNoLock PROC
;;;1009   */
;;;1010   unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000312  b570              PUSH     {r4-r6,lr}
000314  460e              MOV      r6,r1
;;;1011     unsigned                Status;
;;;1012     unsigned                Avail;
;;;1013     const char*             pData;
;;;1014     SEGGER_RTT_BUFFER_UP*   pRing;
;;;1015     //
;;;1016     // Get "to-target" ring buffer.
;;;1017     // It is save to cast that to a "to-host" buffer. Up and Down buffer differ in volatility of offsets that might be modified by J-Link.
;;;1018     //
;;;1019     pData = (const char *)pBuffer;
;;;1020     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000316  2118              MOVS     r1,#0x18
000318  4348              MULS     r0,r1,r0
00031a  4935              LDR      r1,|L1.1008|
00031c  4614              MOV      r4,r2                 ;1010
00031e  1845              ADDS     r5,r0,r1
;;;1021     //
;;;1022     // How we output depends upon the mode...
;;;1023     //
;;;1024     switch (pRing->Flags) {
000320  6c68              LDR      r0,[r5,#0x44]
000322  3530              ADDS     r5,r5,#0x30
000324  2800              CMP      r0,#0
000326  d004              BEQ      |L1.818|
000328  2801              CMP      r0,#1
00032a  d008              BEQ      |L1.830|
00032c  2802              CMP      r0,#2
00032e  d118              BNE      |L1.866|
000330  e011              B        |L1.854|
                  |L1.818|
;;;1025     case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1026       //
;;;1027       // If we are in skip mode and there is no space for the whole
;;;1028       // of this output, don't bother.
;;;1029       //
;;;1030       Avail = _GetAvailWriteSpace(pRing);
000332  4628              MOV      r0,r5
000334  f7fffffe          BL       _GetAvailWriteSpace
;;;1031       if (Avail < NumBytes) {
000338  42a0              CMP      r0,r4
00033a  d312              BCC      |L1.866|
00033c  e005              B        |L1.842|
                  |L1.830|
;;;1032         Status = 0u;
;;;1033       } else {
;;;1034         Status = NumBytes;
;;;1035         _WriteNoCheck(pRing, pData, NumBytes);
;;;1036       }
;;;1037       break;
;;;1038     case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1039       //
;;;1040       // If we are in trim mode, trim to what we can output without blocking.
;;;1041       //
;;;1042       Avail = _GetAvailWriteSpace(pRing);
00033e  4628              MOV      r0,r5
000340  f7fffffe          BL       _GetAvailWriteSpace
;;;1043       Status = Avail < NumBytes ? Avail : NumBytes;
000344  42a0              CMP      r0,r4
000346  d200              BCS      |L1.842|
000348  4604              MOV      r4,r0
                  |L1.842|
;;;1044       _WriteNoCheck(pRing, pData, Status);
00034a  4622              MOV      r2,r4
00034c  4631              MOV      r1,r6
00034e  4628              MOV      r0,r5
000350  f7fffffe          BL       _WriteNoCheck
;;;1045       break;
000354  e006              B        |L1.868|
                  |L1.854|
;;;1046     case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1047       //
;;;1048       // If we are in blocking mode, output everything.
;;;1049       //
;;;1050       Status = _WriteBlocking(pRing, pData, NumBytes);
000356  4631              MOV      r1,r6
000358  4628              MOV      r0,r5
00035a  f7fffffe          BL       _WriteBlocking
00035e  4604              MOV      r4,r0
;;;1051       break;
000360  e000              B        |L1.868|
                  |L1.866|
;;;1052     default:
;;;1053       Status = 0u;
000362  2400              MOVS     r4,#0
                  |L1.868|
;;;1054       break;
;;;1055     }
;;;1056     //
;;;1057     // Finish up.
;;;1058     //
;;;1059     return Status;
000364  4620              MOV      r0,r4
;;;1060   }
000366  bd70              POP      {r4-r6,pc}
;;;1061   
                          ENDP

                  SEGGER_RTT_WriteNoLock PROC
;;;1084   */
;;;1085   unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000368  b570              PUSH     {r4-r6,lr}
00036a  460e              MOV      r6,r1
;;;1086     unsigned              Status;
;;;1087     unsigned              Avail;
;;;1088     const char*           pData;
;;;1089     SEGGER_RTT_BUFFER_UP* pRing;
;;;1090     //
;;;1091     // Get "to-host" ring buffer.
;;;1092     //
;;;1093     pData = (const char *)pBuffer;
;;;1094     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
00036c  2118              MOVS     r1,#0x18
00036e  4348              MULS     r0,r1,r0
000370  491f              LDR      r1,|L1.1008|
000372  4614              MOV      r4,r2                 ;1085
000374  1845              ADDS     r5,r0,r1
;;;1095     //
;;;1096     // How we output depends upon the mode...
;;;1097     //
;;;1098     switch (pRing->Flags) {
000376  6ae8              LDR      r0,[r5,#0x2c]
000378  3518              ADDS     r5,r5,#0x18
00037a  2800              CMP      r0,#0
00037c  d004              BEQ      |L1.904|
00037e  2801              CMP      r0,#1
000380  d008              BEQ      |L1.916|
000382  2802              CMP      r0,#2
000384  d118              BNE      |L1.952|
000386  e011              B        |L1.940|
                  |L1.904|
;;;1099     case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1100       //
;;;1101       // If we are in skip mode and there is no space for the whole
;;;1102       // of this output, don't bother.
;;;1103       //
;;;1104       Avail = _GetAvailWriteSpace(pRing);
000388  4628              MOV      r0,r5
00038a  f7fffffe          BL       _GetAvailWriteSpace
;;;1105       if (Avail < NumBytes) {
00038e  42a0              CMP      r0,r4
000390  d312              BCC      |L1.952|
000392  e005              B        |L1.928|
                  |L1.916|
;;;1106         Status = 0u;
;;;1107       } else {
;;;1108         Status = NumBytes;
;;;1109         _WriteNoCheck(pRing, pData, NumBytes);
;;;1110       }
;;;1111       break;
;;;1112     case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1113       //
;;;1114       // If we are in trim mode, trim to what we can output without blocking.
;;;1115       //
;;;1116       Avail = _GetAvailWriteSpace(pRing);
000394  4628              MOV      r0,r5
000396  f7fffffe          BL       _GetAvailWriteSpace
;;;1117       Status = Avail < NumBytes ? Avail : NumBytes;
00039a  42a0              CMP      r0,r4
00039c  d200              BCS      |L1.928|
00039e  4604              MOV      r4,r0
                  |L1.928|
;;;1118       _WriteNoCheck(pRing, pData, Status);
0003a0  4622              MOV      r2,r4
0003a2  4631              MOV      r1,r6
0003a4  4628              MOV      r0,r5
0003a6  f7fffffe          BL       _WriteNoCheck
;;;1119       break;
0003aa  e006              B        |L1.954|
                  |L1.940|
;;;1120     case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1121       //
;;;1122       // If we are in blocking mode, output everything.
;;;1123       //
;;;1124       Status = _WriteBlocking(pRing, pData, NumBytes);
0003ac  4631              MOV      r1,r6
0003ae  4628              MOV      r0,r5
0003b0  f7fffffe          BL       _WriteBlocking
0003b4  4604              MOV      r4,r0
;;;1125       break;
0003b6  e000              B        |L1.954|
                  |L1.952|
;;;1126     default:
;;;1127       Status = 0u;
0003b8  2400              MOVS     r4,#0
                  |L1.954|
;;;1128       break;
;;;1129     }
;;;1130     //
;;;1131     // Finish up.
;;;1132     //
;;;1133     return Status;
0003ba  4620              MOV      r0,r4
;;;1134   }
0003bc  bd70              POP      {r4-r6,pc}
;;;1135   
                          ENDP

                  SEGGER_RTT_WriteDownBuffer PROC
;;;1160   */
;;;1161   unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
0003be  b5f8              PUSH     {r3-r7,lr}
0003c0  4607              MOV      r7,r0
;;;1162     unsigned Status;
;;;1163   
;;;1164     INIT();
0003c2  480b              LDR      r0,|L1.1008|
0003c4  4615              MOV      r5,r2                 ;1161
0003c6  7800              LDRB     r0,[r0,#0]
0003c8  460e              MOV      r6,r1                 ;1161
0003ca  2800              CMP      r0,#0
0003cc  d101              BNE      |L1.978|
0003ce  f7fffffe          BL       _DoInit
                  |L1.978|
;;;1165     SEGGER_RTT_LOCK();
0003d2  f3ef8410          MRS      r4,PRIMASK
0003d6  2001              MOVS     r0,#1
0003d8  f3808810          MSR      PRIMASK,r0
;;;1166     Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
0003dc  462a              MOV      r2,r5
0003de  4631              MOV      r1,r6
0003e0  4638              MOV      r0,r7
0003e2  f7fffffe          BL       SEGGER_RTT_WriteDownBufferNoLock
;;;1167     SEGGER_RTT_UNLOCK();
0003e6  b2e1              UXTB     r1,r4
0003e8  f3818810          MSR      PRIMASK,r1
;;;1168     return Status;
;;;1169   }
0003ec  bdf8              POP      {r3-r7,pc}
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      ||.bss||
                  |L1.1012|
0003f4  5465726d          DCB      "Terminal",0
0003f8  696e616c
0003fc  00      
0003fd  00                DCB      0
0003fe  00                DCB      0
0003ff  00                DCB      0
                  |L1.1024|
                          DCD      ||.bss||+0x48
                  |L1.1028|
                          DCD      ||.bss||+0x148
                  |L1.1032|
000408  53454747          DCB      "SEGGER",0
00040c  455200  
00040f  00                DCB      0
                          ENDP

                  SEGGER_RTT_Write PROC
;;;1189   */
;;;1190   unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000410  b5f8              PUSH     {r3-r7,lr}
000412  4607              MOV      r7,r0
;;;1191     unsigned Status;
;;;1192   
;;;1193     INIT();
000414  48ff              LDR      r0,|L1.2068|
000416  4615              MOV      r5,r2                 ;1190
000418  7800              LDRB     r0,[r0,#0]
00041a  460e              MOV      r6,r1                 ;1190
00041c  2800              CMP      r0,#0
00041e  d101              BNE      |L1.1060|
000420  f7fffffe          BL       _DoInit
                  |L1.1060|
;;;1194     SEGGER_RTT_LOCK();
000424  f3ef8410          MRS      r4,PRIMASK
000428  2001              MOVS     r0,#1
00042a  f3808810          MSR      PRIMASK,r0
;;;1195     Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
00042e  462a              MOV      r2,r5
000430  4631              MOV      r1,r6
000432  4638              MOV      r0,r7
000434  f7fffffe          BL       SEGGER_RTT_WriteNoLock
;;;1196     SEGGER_RTT_UNLOCK();
000438  b2e1              UXTB     r1,r4
00043a  f3818810          MSR      PRIMASK,r1
;;;1197     return Status;
;;;1198   }
00043e  bdf8              POP      {r3-r7,pc}
;;;1199   
                          ENDP

                  SEGGER_RTT_WriteString PROC
;;;1219   */
;;;1220   unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000440  b5f8              PUSH     {r3-r7,lr}
000442  4607              MOV      r7,r0
000444  460e              MOV      r6,r1
;;;1221     unsigned Len;
;;;1222   
;;;1223     Len = STRLEN(s);
000446  4608              MOV      r0,r1
000448  f7fffffe          BL       strlen
;;;1224     return SEGGER_RTT_Write(BufferIndex, s, Len);
00044c  4605              MOV      r5,r0
00044e  48f1              LDR      r0,|L1.2068|
000450  7800              LDRB     r0,[r0,#0]
000452  2800              CMP      r0,#0
000454  d101              BNE      |L1.1114|
000456  f7fffffe          BL       _DoInit
                  |L1.1114|
00045a  f3ef8410          MRS      r4,PRIMASK
00045e  2001              MOVS     r0,#1
000460  f3808810          MSR      PRIMASK,r0
000464  462a              MOV      r2,r5
000466  4631              MOV      r1,r6
000468  4638              MOV      r0,r7
00046a  f7fffffe          BL       SEGGER_RTT_WriteNoLock
00046e  b2e1              UXTB     r1,r4
000470  f3818810          MSR      PRIMASK,r1
;;;1225   }
000474  bdf8              POP      {r3-r7,pc}
;;;1226   
                          ENDP

                  SEGGER_RTT_PutCharSkipNoLock PROC
;;;1249   
;;;1250   unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
000476  2218              MOVS     r2,#0x18
;;;1251     SEGGER_RTT_BUFFER_UP* pRing;
;;;1252     unsigned              WrOff;
;;;1253     unsigned              Status;
;;;1254     volatile char*        pDst;
;;;1255     //
;;;1256     // Get "to-host" ring buffer.
;;;1257     //
;;;1258     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000478  4350              MULS     r0,r2,r0
00047a  4ae6              LDR      r2,|L1.2068|
00047c  b410              PUSH     {r4}                  ;1250
00047e  1880              ADDS     r0,r0,r2
;;;1259     //
;;;1260     // Get write position and handle wrap-around if necessary
;;;1261     //
;;;1262     WrOff = pRing->WrOff + 1;
000480  6a42              LDR      r2,[r0,#0x24]
;;;1263     if (WrOff == pRing->SizeOfBuffer) {
000482  6a04              LDR      r4,[r0,#0x20]
000484  4613              MOV      r3,r2                 ;1262
000486  3018              ADDS     r0,r0,#0x18
000488  1c52              ADDS     r2,r2,#1
00048a  4294              CMP      r4,r2
00048c  d100              BNE      |L1.1168|
;;;1264       WrOff = 0;
00048e  2200              MOVS     r2,#0
                  |L1.1168|
;;;1265     }
;;;1266     //
;;;1267     // Output byte if free space is available
;;;1268     //
;;;1269     if (WrOff != pRing->RdOff) {
000490  6904              LDR      r4,[r0,#0x10]
000492  4294              CMP      r4,r2
000494  d006              BEQ      |L1.1188|
;;;1270       pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
000496  6844              LDR      r4,[r0,#4]
000498  18e3              ADDS     r3,r4,r3
;;;1271       *pDst = c;
00049a  7019              STRB     r1,[r3,#0]
;;;1272       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1273       pRing->WrOff = WrOff;
;;;1274       Status = 1;
00049c  60c2              STR      r2,[r0,#0xc]
;;;1275     } else {
;;;1276       Status = 0;
;;;1277     }
;;;1278     //
;;;1279     return Status;
;;;1280   }
00049e  bc10              POP      {r4}
0004a0  2001              MOVS     r0,#1                 ;1274
0004a2  4770              BX       lr
                  |L1.1188|
0004a4  bc10              POP      {r4}
0004a6  2000              MOVS     r0,#0                 ;1276
0004a8  4770              BX       lr
;;;1281   
                          ENDP

                  SEGGER_RTT_PutCharSkip PROC
;;;1299   
;;;1300   unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
0004aa  b570              PUSH     {r4-r6,lr}
0004ac  4605              MOV      r5,r0
;;;1301     SEGGER_RTT_BUFFER_UP* pRing;
;;;1302     unsigned              WrOff;
;;;1303     unsigned              Status;
;;;1304     volatile char*        pDst;
;;;1305     //
;;;1306     // Prepare
;;;1307     //
;;;1308     INIT();
0004ae  48d9              LDR      r0,|L1.2068|
0004b0  460c              MOV      r4,r1                 ;1300
0004b2  7800              LDRB     r0,[r0,#0]
0004b4  2800              CMP      r0,#0
0004b6  d101              BNE      |L1.1212|
0004b8  f7fffffe          BL       _DoInit
                  |L1.1212|
;;;1309     SEGGER_RTT_LOCK();
0004bc  f3ef8110          MRS      r1,PRIMASK
0004c0  2001              MOVS     r0,#1
0004c2  f3808810          MSR      PRIMASK,r0
;;;1310     //
;;;1311     // Get "to-host" ring buffer.
;;;1312     //
;;;1313     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0004c6  2018              MOVS     r0,#0x18
0004c8  4345              MULS     r5,r0,r5
0004ca  48d2              LDR      r0,|L1.2068|
0004cc  1828              ADDS     r0,r5,r0
;;;1314     //
;;;1315     // Get write position and handle wrap-around if necessary
;;;1316     //
;;;1317     WrOff = pRing->WrOff + 1;
0004ce  6a42              LDR      r2,[r0,#0x24]
;;;1318     if (WrOff == pRing->SizeOfBuffer) {
0004d0  6a05              LDR      r5,[r0,#0x20]
0004d2  4613              MOV      r3,r2                 ;1317
0004d4  3018              ADDS     r0,r0,#0x18
0004d6  1c52              ADDS     r2,r2,#1
0004d8  4295              CMP      r5,r2
0004da  d100              BNE      |L1.1246|
;;;1319       WrOff = 0;
0004dc  2200              MOVS     r2,#0
                  |L1.1246|
;;;1320     }
;;;1321     //
;;;1322     // Output byte if free space is available
;;;1323     //
;;;1324     if (WrOff != pRing->RdOff) {
0004de  6905              LDR      r5,[r0,#0x10]
0004e0  4295              CMP      r5,r2
0004e2  d005              BEQ      |L1.1264|
;;;1325       pDst  = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
0004e4  6845              LDR      r5,[r0,#4]
0004e6  18eb              ADDS     r3,r5,r3
;;;1326       *pDst = c;
0004e8  701c              STRB     r4,[r3,#0]
;;;1327       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1328       pRing->WrOff = WrOff;
;;;1329       Status = 1;
0004ea  60c2              STR      r2,[r0,#0xc]
0004ec  2001              MOVS     r0,#1
0004ee  e000              B        |L1.1266|
                  |L1.1264|
;;;1330     } else {
;;;1331       Status = 0;
0004f0  2000              MOVS     r0,#0
                  |L1.1266|
;;;1332     }
;;;1333     //
;;;1334     // Finish up.
;;;1335     //
;;;1336     SEGGER_RTT_UNLOCK();
0004f2  b2c9              UXTB     r1,r1
0004f4  f3818810          MSR      PRIMASK,r1
;;;1337     //
;;;1338     return Status;
;;;1339   }
0004f8  bd70              POP      {r4-r6,pc}
;;;1340   
                          ENDP

                  SEGGER_RTT_PutChar PROC
;;;1358   
;;;1359   unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
0004fa  b570              PUSH     {r4-r6,lr}
0004fc  4605              MOV      r5,r0
;;;1360     SEGGER_RTT_BUFFER_UP* pRing;
;;;1361     unsigned              WrOff;
;;;1362     unsigned              Status;
;;;1363     volatile char*        pDst;
;;;1364     //
;;;1365     // Prepare
;;;1366     //
;;;1367     INIT();
0004fe  48c5              LDR      r0,|L1.2068|
000500  460c              MOV      r4,r1                 ;1359
000502  7800              LDRB     r0,[r0,#0]
000504  2800              CMP      r0,#0
000506  d101              BNE      |L1.1292|
000508  f7fffffe          BL       _DoInit
                  |L1.1292|
;;;1368     SEGGER_RTT_LOCK();
00050c  f3ef8310          MRS      r3,PRIMASK
000510  2001              MOVS     r0,#1
000512  f3808810          MSR      PRIMASK,r0
;;;1369     //
;;;1370     // Get "to-host" ring buffer.
;;;1371     //
;;;1372     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000516  2018              MOVS     r0,#0x18
000518  4345              MULS     r5,r0,r5
00051a  48be              LDR      r0,|L1.2068|
00051c  1828              ADDS     r0,r5,r0
;;;1373     //
;;;1374     // Get write position and handle wrap-around if necessary
;;;1375     //
;;;1376     WrOff = pRing->WrOff + 1;
00051e  6a42              LDR      r2,[r0,#0x24]
;;;1377     if (WrOff == pRing->SizeOfBuffer) {
000520  6a01              LDR      r1,[r0,#0x20]
000522  4615              MOV      r5,r2                 ;1376
000524  3018              ADDS     r0,r0,#0x18
000526  1c52              ADDS     r2,r2,#1
000528  4291              CMP      r1,r2
00052a  d100              BNE      |L1.1326|
;;;1378       WrOff = 0;
00052c  2200              MOVS     r2,#0
                  |L1.1326|
;;;1379     }
;;;1380     //
;;;1381     // Wait for free space if mode is set to blocking
;;;1382     //
;;;1383     if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00052e  6941              LDR      r1,[r0,#0x14]
000530  2902              CMP      r1,#2
000532  d102              BNE      |L1.1338|
                  |L1.1332|
;;;1384       while (WrOff == pRing->RdOff) {
000534  6901              LDR      r1,[r0,#0x10]
000536  4291              CMP      r1,r2
000538  d0fc              BEQ      |L1.1332|
                  |L1.1338|
;;;1385         ;
;;;1386       }
;;;1387     }
;;;1388     //
;;;1389     // Output byte if free space is available
;;;1390     //
;;;1391     if (WrOff != pRing->RdOff) {
00053a  6901              LDR      r1,[r0,#0x10]
00053c  4291              CMP      r1,r2
00053e  d005              BEQ      |L1.1356|
;;;1392       pDst  = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
000540  6841              LDR      r1,[r0,#4]
000542  1949              ADDS     r1,r1,r5
;;;1393       *pDst = c;
000544  700c              STRB     r4,[r1,#0]
;;;1394       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1395       pRing->WrOff = WrOff;
;;;1396       Status = 1;
000546  60c2              STR      r2,[r0,#0xc]
000548  2001              MOVS     r0,#1
00054a  e000              B        |L1.1358|
                  |L1.1356|
;;;1397     } else {
;;;1398       Status = 0;
00054c  2000              MOVS     r0,#0
                  |L1.1358|
;;;1399     }
;;;1400     //
;;;1401     // Finish up.
;;;1402     //
;;;1403     SEGGER_RTT_UNLOCK();
00054e  b2d9              UXTB     r1,r3
000550  f3818810          MSR      PRIMASK,r1
;;;1404     return Status;
;;;1405   }
000554  bd70              POP      {r4-r6,pc}
;;;1406   
                          ENDP

                  SEGGER_RTT_GetKey PROC
;;;1421   */
;;;1422   int SEGGER_RTT_GetKey(void) {
000556  b538              PUSH     {r3-r5,lr}
;;;1423     char c;
;;;1424     int r;
;;;1425   
;;;1426     r = (int)SEGGER_RTT_Read(0u, &c, 1u);
000558  2000              MOVS     r0,#0
00055a  4669              MOV      r1,sp
00055c  f3ef8410          MRS      r4,PRIMASK
000560  2201              MOVS     r2,#1
000562  f3828810          MSR      PRIMASK,r2
000566  f7fffffe          BL       SEGGER_RTT_ReadNoLock
00056a  b2e1              UXTB     r1,r4
00056c  f3818810          MSR      PRIMASK,r1
;;;1427     if (r == 1) {
000570  2801              CMP      r0,#1
000572  d002              BEQ      |L1.1402|
;;;1428       r = (int)(unsigned char)c;
;;;1429     } else {
;;;1430       r = -1;
000574  2000              MOVS     r0,#0
000576  43c0              MVNS     r0,r0
;;;1431     }
;;;1432     return r;
;;;1433   }
000578  bd38              POP      {r3-r5,pc}
                  |L1.1402|
00057a  4668              MOV      r0,sp                 ;1428
00057c  7800              LDRB     r0,[r0,#0]            ;1428
00057e  bd38              POP      {r3-r5,pc}
;;;1434   
                          ENDP

                  SEGGER_RTT_WaitKey PROC
;;;1449   */
;;;1450   int SEGGER_RTT_WaitKey(void) {
000580  b5f8              PUSH     {r3-r7,lr}
000582  2401              MOVS     r4,#1
000584  1ea5              SUBS     r5,r4,#2
                  |L1.1414|
000586  2000              MOVS     r0,#0
000588  4669              MOV      r1,sp
00058a  f3ef8610          MRS      r6,PRIMASK
00058e  4622              MOV      r2,r4
000590  f3828810          MSR      PRIMASK,r2
000594  f7fffffe          BL       SEGGER_RTT_ReadNoLock
000598  b2f1              UXTB     r1,r6
00059a  f3818810          MSR      PRIMASK,r1
00059e  2801              CMP      r0,#1
0005a0  d003              BEQ      |L1.1450|
0005a2  4628              MOV      r0,r5
                  |L1.1444|
;;;1451     int r;
;;;1452   
;;;1453     do {
;;;1454       r = SEGGER_RTT_GetKey();
;;;1455     } while (r < 0);
0005a4  2800              CMP      r0,#0
0005a6  dbee              BLT      |L1.1414|
;;;1456     return r;
;;;1457   }
0005a8  bdf8              POP      {r3-r7,pc}
                  |L1.1450|
0005aa  4668              MOV      r0,sp
0005ac  7800              LDRB     r0,[r0,#0]
0005ae  e7f9              B        |L1.1444|
;;;1458   
                          ENDP

                  SEGGER_RTT_HasKey PROC
;;;1472   */
;;;1473   int SEGGER_RTT_HasKey(void) {
0005b0  b510              PUSH     {r4,lr}
;;;1474     SEGGER_RTT_BUFFER_DOWN* pRing;
;;;1475     unsigned RdOff;
;;;1476     int r;
;;;1477   
;;;1478     INIT();
0005b2  4898              LDR      r0,|L1.2068|
0005b4  7800              LDRB     r0,[r0,#0]
0005b6  2800              CMP      r0,#0
0005b8  d101              BNE      |L1.1470|
0005ba  f7fffffe          BL       _DoInit
                  |L1.1470|
;;;1479     pRing = (SEGGER_RTT_BUFFER_DOWN*)((char*)&_SEGGER_RTT.aDown[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0005be  4895              LDR      r0,|L1.2068|
;;;1480     RdOff = pRing->RdOff;
;;;1481     if (RdOff != pRing->WrOff) {
0005c0  6c01              LDR      r1,[r0,#0x40]
0005c2  6bc0              LDR      r0,[r0,#0x3c]
0005c4  4288              CMP      r0,r1
0005c6  d001              BEQ      |L1.1484|
;;;1482       r = 1;
0005c8  2001              MOVS     r0,#1
;;;1483     } else {
;;;1484       r = 0;
;;;1485     }
;;;1486     return r;
;;;1487   }
0005ca  bd10              POP      {r4,pc}
                  |L1.1484|
0005cc  2000              MOVS     r0,#0                 ;1484
0005ce  bd10              POP      {r4,pc}
;;;1488   
                          ENDP

                  SEGGER_RTT_HasData PROC
;;;1500   */
;;;1501   unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
0005d0  2118              MOVS     r1,#0x18
;;;1502     SEGGER_RTT_BUFFER_DOWN* pRing;
;;;1503     unsigned                v;
;;;1504   
;;;1505     pRing = (SEGGER_RTT_BUFFER_DOWN*)((char*)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0005d2  4348              MULS     r0,r1,r0
0005d4  498f              LDR      r1,|L1.2068|
0005d6  1840              ADDS     r0,r0,r1
;;;1506     v = pRing->WrOff;
0005d8  6bc1              LDR      r1,[r0,#0x3c]
;;;1507     return v - pRing->RdOff;
0005da  6c00              LDR      r0,[r0,#0x40]
0005dc  1a08              SUBS     r0,r1,r0
;;;1508   }
0005de  4770              BX       lr
;;;1509   
                          ENDP

                  SEGGER_RTT_HasDataUp PROC
;;;1521   */
;;;1522   unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
0005e0  2118              MOVS     r1,#0x18
;;;1523     SEGGER_RTT_BUFFER_UP* pRing;
;;;1524     unsigned                v;
;;;1525   
;;;1526     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0005e2  4348              MULS     r0,r1,r0
0005e4  498b              LDR      r1,|L1.2068|
0005e6  1840              ADDS     r0,r0,r1
;;;1527     v = pRing->RdOff;
0005e8  6a81              LDR      r1,[r0,#0x28]
;;;1528     return pRing->WrOff - v;
0005ea  6a40              LDR      r0,[r0,#0x24]
0005ec  1a40              SUBS     r0,r0,r1
;;;1529   }
0005ee  4770              BX       lr
;;;1530   
                          ENDP

                  SEGGER_RTT_AllocDownBuffer PROC
;;;1549   */
;;;1550   int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
0005f0  b5f8              PUSH     {r3-r7,lr}
0005f2  4607              MOV      r7,r0
;;;1551     int BufferIndex;
;;;1552     volatile SEGGER_RTT_CB* pRTTCB;
;;;1553   
;;;1554     INIT();
0005f4  4887              LDR      r0,|L1.2068|
0005f6  461c              MOV      r4,r3                 ;1550
0005f8  7800              LDRB     r0,[r0,#0]
0005fa  4615              MOV      r5,r2                 ;1550
0005fc  460e              MOV      r6,r1                 ;1550
0005fe  2800              CMP      r0,#0
000600  d101              BNE      |L1.1542|
000602  f7fffffe          BL       _DoInit
                  |L1.1542|
;;;1555     SEGGER_RTT_LOCK();
000606  f3ef8210          MRS      r2,PRIMASK
00060a  2001              MOVS     r0,#1
00060c  f3808810          MSR      PRIMASK,r0
;;;1556     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000610  4980              LDR      r1,|L1.2068|
;;;1557     BufferIndex = 0;
000612  2000              MOVS     r0,#0
                  |L1.1556|
;;;1558     do {
;;;1559       if (pRTTCB->aDown[BufferIndex].pBuffer == NULL) {
000614  2318              MOVS     r3,#0x18
000616  4343              MULS     r3,r0,r3
000618  185b              ADDS     r3,r3,r1
00061a  6b5b              LDR      r3,[r3,#0x34]
00061c  2b00              CMP      r3,#0
00061e  d003              BEQ      |L1.1576|
;;;1560         break;
;;;1561       }
;;;1562       BufferIndex++;
;;;1563     } while (BufferIndex < pRTTCB->MaxNumDownBuffers);
000620  694b              LDR      r3,[r1,#0x14]
000622  1c40              ADDS     r0,r0,#1
000624  4283              CMP      r3,r0
000626  dcf5              BGT      |L1.1556|
                  |L1.1576|
;;;1564     if (BufferIndex < pRTTCB->MaxNumDownBuffers) {
000628  694b              LDR      r3,[r1,#0x14]
00062a  4283              CMP      r3,r0
00062c  dd0a              BLE      |L1.1604|
;;;1565       pRTTCB->aDown[BufferIndex].sName        = sName;
00062e  2318              MOVS     r3,#0x18
000630  4343              MULS     r3,r0,r3
000632  1859              ADDS     r1,r3,r1
000634  630f              STR      r7,[r1,#0x30]
;;;1566       pRTTCB->aDown[BufferIndex].pBuffer      = (char*)pBuffer;
000636  634e              STR      r6,[r1,#0x34]
;;;1567       pRTTCB->aDown[BufferIndex].SizeOfBuffer = BufferSize;
000638  638d              STR      r5,[r1,#0x38]
;;;1568       pRTTCB->aDown[BufferIndex].RdOff        = 0u;
00063a  2300              MOVS     r3,#0
00063c  640b              STR      r3,[r1,#0x40]
;;;1569       pRTTCB->aDown[BufferIndex].WrOff        = 0u;
00063e  63cb              STR      r3,[r1,#0x3c]
;;;1570       pRTTCB->aDown[BufferIndex].Flags        = Flags;
000640  644c              STR      r4,[r1,#0x44]
000642  e001              B        |L1.1608|
                  |L1.1604|
;;;1571       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1572     } else {
;;;1573       BufferIndex = -1;
000644  2000              MOVS     r0,#0
000646  43c0              MVNS     r0,r0
                  |L1.1608|
;;;1574     }
;;;1575     SEGGER_RTT_UNLOCK();
000648  b2d1              UXTB     r1,r2
00064a  f3818810          MSR      PRIMASK,r1
;;;1576     return BufferIndex;
;;;1577   }
00064e  bdf8              POP      {r3-r7,pc}
;;;1578   
                          ENDP

                  SEGGER_RTT_AllocUpBuffer PROC
;;;1597   */
;;;1598   int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000650  b5f8              PUSH     {r3-r7,lr}
000652  4607              MOV      r7,r0
;;;1599     int BufferIndex;
;;;1600     volatile SEGGER_RTT_CB* pRTTCB;
;;;1601   
;;;1602     INIT();
000654  486f              LDR      r0,|L1.2068|
000656  461c              MOV      r4,r3                 ;1598
000658  7800              LDRB     r0,[r0,#0]
00065a  4615              MOV      r5,r2                 ;1598
00065c  460e              MOV      r6,r1                 ;1598
00065e  2800              CMP      r0,#0
000660  d101              BNE      |L1.1638|
000662  f7fffffe          BL       _DoInit
                  |L1.1638|
;;;1603     SEGGER_RTT_LOCK();
000666  f3ef8210          MRS      r2,PRIMASK
00066a  2001              MOVS     r0,#1
00066c  f3808810          MSR      PRIMASK,r0
;;;1604     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000670  4968              LDR      r1,|L1.2068|
;;;1605     BufferIndex = 0;
000672  2000              MOVS     r0,#0
                  |L1.1652|
;;;1606     do {
;;;1607       if (pRTTCB->aUp[BufferIndex].pBuffer == NULL) {
000674  2318              MOVS     r3,#0x18
000676  4343              MULS     r3,r0,r3
000678  185b              ADDS     r3,r3,r1
00067a  69db              LDR      r3,[r3,#0x1c]
00067c  2b00              CMP      r3,#0
00067e  d003              BEQ      |L1.1672|
;;;1608         break;
;;;1609       }
;;;1610       BufferIndex++;
;;;1611     } while (BufferIndex < pRTTCB->MaxNumUpBuffers);
000680  690b              LDR      r3,[r1,#0x10]
000682  1c40              ADDS     r0,r0,#1
000684  4283              CMP      r3,r0
000686  dcf5              BGT      |L1.1652|
                  |L1.1672|
;;;1612     if (BufferIndex < pRTTCB->MaxNumUpBuffers) {
000688  690b              LDR      r3,[r1,#0x10]
00068a  4283              CMP      r3,r0
00068c  dd0a              BLE      |L1.1700|
;;;1613       pRTTCB->aUp[BufferIndex].sName        = sName;
00068e  2318              MOVS     r3,#0x18
000690  4343              MULS     r3,r0,r3
000692  1859              ADDS     r1,r3,r1
000694  618f              STR      r7,[r1,#0x18]
;;;1614       pRTTCB->aUp[BufferIndex].pBuffer      = (char*)pBuffer;
000696  61ce              STR      r6,[r1,#0x1c]
;;;1615       pRTTCB->aUp[BufferIndex].SizeOfBuffer = BufferSize;
000698  620d              STR      r5,[r1,#0x20]
;;;1616       pRTTCB->aUp[BufferIndex].RdOff        = 0u;
00069a  2300              MOVS     r3,#0
00069c  628b              STR      r3,[r1,#0x28]
;;;1617       pRTTCB->aUp[BufferIndex].WrOff        = 0u;
00069e  624b              STR      r3,[r1,#0x24]
;;;1618       pRTTCB->aUp[BufferIndex].Flags        = Flags;
0006a0  62cc              STR      r4,[r1,#0x2c]
0006a2  e001              B        |L1.1704|
                  |L1.1700|
;;;1619       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1620     } else {
;;;1621       BufferIndex = -1;
0006a4  2000              MOVS     r0,#0
0006a6  43c0              MVNS     r0,r0
                  |L1.1704|
;;;1622     }
;;;1623     SEGGER_RTT_UNLOCK();
0006a8  b2d1              UXTB     r1,r2
0006aa  f3818810          MSR      PRIMASK,r1
;;;1624     return BufferIndex;
;;;1625   }
0006ae  bdf8              POP      {r3-r7,pc}
;;;1626   
                          ENDP

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;1651   */
;;;1652   int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
0006b0  b5ff              PUSH     {r0-r7,lr}
0006b2  4604              MOV      r4,r0
;;;1653     int r;
;;;1654     volatile SEGGER_RTT_CB* pRTTCB;
;;;1655   
;;;1656     INIT();
0006b4  4857              LDR      r0,|L1.2068|
0006b6  b081              SUB      sp,sp,#4              ;1652
0006b8  7800              LDRB     r0,[r0,#0]
0006ba  9d0a              LDR      r5,[sp,#0x28]
0006bc  4616              MOV      r6,r2                 ;1652
0006be  460f              MOV      r7,r1                 ;1652
0006c0  2800              CMP      r0,#0
0006c2  d101              BNE      |L1.1736|
0006c4  f7fffffe          BL       _DoInit
                  |L1.1736|
;;;1657     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0006c8  4852              LDR      r0,|L1.2068|
;;;1658     if (BufferIndex < (unsigned)pRTTCB->MaxNumUpBuffers) {
0006ca  6900              LDR      r0,[r0,#0x10]
0006cc  42a0              CMP      r0,r4
0006ce  d918              BLS      |L1.1794|
;;;1659       SEGGER_RTT_LOCK();
0006d0  f3ef8110          MRS      r1,PRIMASK
0006d4  2001              MOVS     r0,#1
0006d6  f3808810          MSR      PRIMASK,r0
;;;1660       if (BufferIndex > 0u) {
;;;1661         pRTTCB->aUp[BufferIndex].sName        = sName;
0006da  2018              MOVS     r0,#0x18
0006dc  4a4d              LDR      r2,|L1.2068|
0006de  4360              MULS     r0,r4,r0
0006e0  1880              ADDS     r0,r0,r2
0006e2  2c00              CMP      r4,#0                 ;1660
0006e4  d006              BEQ      |L1.1780|
0006e6  6187              STR      r7,[r0,#0x18]
;;;1662         pRTTCB->aUp[BufferIndex].pBuffer      = (char*)pBuffer;
0006e8  61c6              STR      r6,[r0,#0x1c]
;;;1663         pRTTCB->aUp[BufferIndex].SizeOfBuffer = BufferSize;
0006ea  9a04              LDR      r2,[sp,#0x10]
0006ec  6202              STR      r2,[r0,#0x20]
;;;1664         pRTTCB->aUp[BufferIndex].RdOff        = 0u;
0006ee  2200              MOVS     r2,#0
0006f0  6282              STR      r2,[r0,#0x28]
;;;1665         pRTTCB->aUp[BufferIndex].WrOff        = 0u;
0006f2  6242              STR      r2,[r0,#0x24]
                  |L1.1780|
;;;1666       }
;;;1667       pRTTCB->aUp[BufferIndex].Flags          = Flags;
0006f4  62c5              STR      r5,[r0,#0x2c]
;;;1668       SEGGER_RTT_UNLOCK();
0006f6  b2c8              UXTB     r0,r1
0006f8  f3808810          MSR      PRIMASK,r0
;;;1669       r =  0;
0006fc  2000              MOVS     r0,#0
;;;1670     } else {
;;;1671       r = -1;
;;;1672     }
;;;1673     return r;
;;;1674   }
0006fe  b005              ADD      sp,sp,#0x14
000700  bdf0              POP      {r4-r7,pc}
                  |L1.1794|
000702  2000              MOVS     r0,#0                 ;1671
000704  43c0              MVNS     r0,r0                 ;1671
000706  b005              ADD      sp,sp,#0x14
000708  bdf0              POP      {r4-r7,pc}
;;;1675   
                          ENDP

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;1700   */
;;;1701   int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
00070a  b5ff              PUSH     {r0-r7,lr}
00070c  4604              MOV      r4,r0
;;;1702     int r;
;;;1703     volatile SEGGER_RTT_CB* pRTTCB;
;;;1704   
;;;1705     INIT();
00070e  4841              LDR      r0,|L1.2068|
000710  b081              SUB      sp,sp,#4              ;1701
000712  7800              LDRB     r0,[r0,#0]
000714  9d0a              LDR      r5,[sp,#0x28]
000716  4616              MOV      r6,r2                 ;1701
000718  460f              MOV      r7,r1                 ;1701
00071a  2800              CMP      r0,#0
00071c  d101              BNE      |L1.1826|
00071e  f7fffffe          BL       _DoInit
                  |L1.1826|
;;;1706     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000722  483c              LDR      r0,|L1.2068|
;;;1707     if (BufferIndex < (unsigned)pRTTCB->MaxNumDownBuffers) {
000724  6940              LDR      r0,[r0,#0x14]
000726  42a0              CMP      r0,r4
000728  d918              BLS      |L1.1884|
;;;1708       SEGGER_RTT_LOCK();
00072a  f3ef8110          MRS      r1,PRIMASK
00072e  2001              MOVS     r0,#1
000730  f3808810          MSR      PRIMASK,r0
;;;1709       if (BufferIndex > 0u) {
;;;1710         pRTTCB->aDown[BufferIndex].sName        = sName;
000734  2018              MOVS     r0,#0x18
000736  4a37              LDR      r2,|L1.2068|
000738  4360              MULS     r0,r4,r0
00073a  1880              ADDS     r0,r0,r2
00073c  2c00              CMP      r4,#0                 ;1709
00073e  d006              BEQ      |L1.1870|
000740  6307              STR      r7,[r0,#0x30]
;;;1711         pRTTCB->aDown[BufferIndex].pBuffer      = (char*)pBuffer;
000742  6346              STR      r6,[r0,#0x34]
;;;1712         pRTTCB->aDown[BufferIndex].SizeOfBuffer = BufferSize;
000744  9a04              LDR      r2,[sp,#0x10]
000746  6382              STR      r2,[r0,#0x38]
;;;1713         pRTTCB->aDown[BufferIndex].RdOff        = 0u;
000748  2200              MOVS     r2,#0
00074a  6402              STR      r2,[r0,#0x40]
;;;1714         pRTTCB->aDown[BufferIndex].WrOff        = 0u;
00074c  63c2              STR      r2,[r0,#0x3c]
                  |L1.1870|
;;;1715       }
;;;1716       pRTTCB->aDown[BufferIndex].Flags          = Flags;
00074e  6445              STR      r5,[r0,#0x44]
;;;1717       RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
;;;1718       SEGGER_RTT_UNLOCK();
000750  b2c8              UXTB     r0,r1
000752  f3808810          MSR      PRIMASK,r0
;;;1719       r =  0;
000756  2000              MOVS     r0,#0
;;;1720     } else {
;;;1721       r = -1;
;;;1722     }
;;;1723     return r;
;;;1724   }
000758  b005              ADD      sp,sp,#0x14
00075a  bdf0              POP      {r4-r7,pc}
                  |L1.1884|
00075c  2000              MOVS     r0,#0                 ;1721
00075e  43c0              MVNS     r0,r0                 ;1721
000760  b005              ADD      sp,sp,#0x14
000762  bdf0              POP      {r4-r7,pc}
;;;1725   
                          ENDP

                  SEGGER_RTT_SetNameUpBuffer PROC
;;;1741   */
;;;1742   int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
000764  b570              PUSH     {r4-r6,lr}
000766  4604              MOV      r4,r0
;;;1743     int r;
;;;1744     volatile SEGGER_RTT_CB* pRTTCB;
;;;1745   
;;;1746     INIT();
000768  482a              LDR      r0,|L1.2068|
00076a  460d              MOV      r5,r1                 ;1742
00076c  7800              LDRB     r0,[r0,#0]
00076e  2800              CMP      r0,#0
000770  d101              BNE      |L1.1910|
000772  f7fffffe          BL       _DoInit
                  |L1.1910|
;;;1747     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000776  4a27              LDR      r2,|L1.2068|
;;;1748     if (BufferIndex < (unsigned)pRTTCB->MaxNumUpBuffers) {
000778  6910              LDR      r0,[r2,#0x10]
00077a  42a0              CMP      r0,r4
00077c  d90d              BLS      |L1.1946|
;;;1749       SEGGER_RTT_LOCK();
00077e  f3ef8010          MRS      r0,PRIMASK
000782  2101              MOVS     r1,#1
000784  f3818810          MSR      PRIMASK,r1
;;;1750       pRTTCB->aUp[BufferIndex].sName = sName;
000788  2118              MOVS     r1,#0x18
00078a  434c              MULS     r4,r1,r4
00078c  18a1              ADDS     r1,r4,r2
00078e  618d              STR      r5,[r1,#0x18]
;;;1751       SEGGER_RTT_UNLOCK();
000790  b2c0              UXTB     r0,r0
000792  f3808810          MSR      PRIMASK,r0
;;;1752       r =  0;
000796  2000              MOVS     r0,#0
;;;1753     } else {
;;;1754       r = -1;
;;;1755     }
;;;1756     return r;
;;;1757   }
000798  bd70              POP      {r4-r6,pc}
                  |L1.1946|
00079a  2000              MOVS     r0,#0                 ;1754
00079c  43c0              MVNS     r0,r0                 ;1754
00079e  bd70              POP      {r4-r6,pc}
;;;1758   
                          ENDP

                  SEGGER_RTT_SetNameDownBuffer PROC
;;;1774   */
;;;1775   int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
0007a0  b570              PUSH     {r4-r6,lr}
0007a2  4604              MOV      r4,r0
;;;1776     int r;
;;;1777     volatile SEGGER_RTT_CB* pRTTCB;
;;;1778   
;;;1779     INIT();
0007a4  481b              LDR      r0,|L1.2068|
0007a6  460d              MOV      r5,r1                 ;1775
0007a8  7800              LDRB     r0,[r0,#0]
0007aa  2800              CMP      r0,#0
0007ac  d101              BNE      |L1.1970|
0007ae  f7fffffe          BL       _DoInit
                  |L1.1970|
;;;1780     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0007b2  4a18              LDR      r2,|L1.2068|
;;;1781     if (BufferIndex < (unsigned)pRTTCB->MaxNumDownBuffers) {
0007b4  6950              LDR      r0,[r2,#0x14]
0007b6  42a0              CMP      r0,r4
0007b8  d90d              BLS      |L1.2006|
;;;1782       SEGGER_RTT_LOCK();
0007ba  f3ef8010          MRS      r0,PRIMASK
0007be  2101              MOVS     r1,#1
0007c0  f3818810          MSR      PRIMASK,r1
;;;1783       pRTTCB->aDown[BufferIndex].sName = sName;
0007c4  2118              MOVS     r1,#0x18
0007c6  434c              MULS     r4,r1,r4
0007c8  18a1              ADDS     r1,r4,r2
0007ca  630d              STR      r5,[r1,#0x30]
;;;1784       SEGGER_RTT_UNLOCK();
0007cc  b2c0              UXTB     r0,r0
0007ce  f3808810          MSR      PRIMASK,r0
;;;1785       r =  0;
0007d2  2000              MOVS     r0,#0
;;;1786     } else {
;;;1787       r = -1;
;;;1788     }
;;;1789     return r;
;;;1790   }
0007d4  bd70              POP      {r4-r6,pc}
                  |L1.2006|
0007d6  2000              MOVS     r0,#0                 ;1787
0007d8  43c0              MVNS     r0,r0                 ;1787
0007da  bd70              POP      {r4-r6,pc}
;;;1791   
                          ENDP

                  SEGGER_RTT_SetFlagsUpBuffer PROC
;;;1807   */
;;;1808   int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
0007dc  b570              PUSH     {r4-r6,lr}
0007de  4604              MOV      r4,r0
;;;1809     int r;
;;;1810     volatile SEGGER_RTT_CB* pRTTCB;
;;;1811   
;;;1812     INIT();
0007e0  480c              LDR      r0,|L1.2068|
0007e2  460d              MOV      r5,r1                 ;1808
0007e4  7800              LDRB     r0,[r0,#0]
0007e6  2800              CMP      r0,#0
0007e8  d101              BNE      |L1.2030|
0007ea  f7fffffe          BL       _DoInit
                  |L1.2030|
;;;1813     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0007ee  4a09              LDR      r2,|L1.2068|
;;;1814     if (BufferIndex < (unsigned)pRTTCB->MaxNumUpBuffers) {
0007f0  6910              LDR      r0,[r2,#0x10]
0007f2  42a0              CMP      r0,r4
0007f4  d910              BLS      |L1.2072|
;;;1815       SEGGER_RTT_LOCK();
0007f6  f3ef8010          MRS      r0,PRIMASK
0007fa  2101              MOVS     r1,#1
0007fc  f3818810          MSR      PRIMASK,r1
;;;1816       pRTTCB->aUp[BufferIndex].Flags = Flags;
000800  2118              MOVS     r1,#0x18
000802  434c              MULS     r4,r1,r4
000804  18a1              ADDS     r1,r4,r2
000806  62cd              STR      r5,[r1,#0x2c]
;;;1817       SEGGER_RTT_UNLOCK();
000808  b2c0              UXTB     r0,r0
00080a  f3808810          MSR      PRIMASK,r0
;;;1818       r =  0;
00080e  2000              MOVS     r0,#0
;;;1819     } else {
;;;1820       r = -1;
;;;1821     }
;;;1822     return r;
;;;1823   }
000810  bd70              POP      {r4-r6,pc}
000812  0000              DCW      0x0000
                  |L1.2068|
                          DCD      ||.bss||
                  |L1.2072|
000818  2000              MOVS     r0,#0                 ;1820
00081a  43c0              MVNS     r0,r0                 ;1820
00081c  bd70              POP      {r4-r6,pc}
;;;1824   
                          ENDP

                  SEGGER_RTT_SetFlagsDownBuffer PROC
;;;1840   */
;;;1841   int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
00081e  b570              PUSH     {r4-r6,lr}
000820  4604              MOV      r4,r0
;;;1842     int r;
;;;1843     volatile SEGGER_RTT_CB* pRTTCB;
;;;1844   
;;;1845     INIT();
000822  4884              LDR      r0,|L1.2612|
000824  460d              MOV      r5,r1                 ;1841
000826  7800              LDRB     r0,[r0,#0]
000828  2800              CMP      r0,#0
00082a  d101              BNE      |L1.2096|
00082c  f7fffffe          BL       _DoInit
                  |L1.2096|
;;;1846     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000830  4a80              LDR      r2,|L1.2612|
;;;1847     if (BufferIndex < (unsigned)pRTTCB->MaxNumDownBuffers) {
000832  6950              LDR      r0,[r2,#0x14]
000834  42a0              CMP      r0,r4
000836  d90d              BLS      |L1.2132|
;;;1848       SEGGER_RTT_LOCK();
000838  f3ef8010          MRS      r0,PRIMASK
00083c  2101              MOVS     r1,#1
00083e  f3818810          MSR      PRIMASK,r1
;;;1849       pRTTCB->aDown[BufferIndex].Flags = Flags;
000842  2118              MOVS     r1,#0x18
000844  434c              MULS     r4,r1,r4
000846  18a1              ADDS     r1,r4,r2
000848  644d              STR      r5,[r1,#0x44]
;;;1850       SEGGER_RTT_UNLOCK();
00084a  b2c0              UXTB     r0,r0
00084c  f3808810          MSR      PRIMASK,r0
;;;1851       r =  0;
000850  2000              MOVS     r0,#0
;;;1852     } else {
;;;1853       r = -1;
;;;1854     }
;;;1855     return r;
;;;1856   }
000852  bd70              POP      {r4-r6,pc}
                  |L1.2132|
000854  2000              MOVS     r0,#0                 ;1853
000856  43c0              MVNS     r0,r0                 ;1853
000858  bd70              POP      {r4-r6,pc}
;;;1857   
                          ENDP

                  SEGGER_RTT_Init PROC
;;;1866   */
;;;1867   void SEGGER_RTT_Init (void) {
00085a  b510              PUSH     {r4,lr}
;;;1868     _DoInit();
00085c  f7fffffe          BL       _DoInit
;;;1869   }
000860  bd10              POP      {r4,pc}
;;;1870   
                          ENDP

                  SEGGER_RTT_SetTerminal PROC
;;;1887   */
;;;1888   int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
000862  b5f8              PUSH     {r3-r7,lr}
000864  4604              MOV      r4,r0
;;;1889     unsigned char         ac[2];
;;;1890     SEGGER_RTT_BUFFER_UP* pRing;
;;;1891     unsigned Avail;
;;;1892     int r;
;;;1893   
;;;1894     INIT();
000866  4873              LDR      r0,|L1.2612|
000868  7800              LDRB     r0,[r0,#0]
00086a  2800              CMP      r0,#0
00086c  d101              BNE      |L1.2162|
00086e  f7fffffe          BL       _DoInit
                  |L1.2162|
;;;1895     r = 0;
;;;1896     ac[0] = 0xFFu;
000872  20ff              MOVS     r0,#0xff
000874  2500              MOVS     r5,#0                 ;1895
000876  4669              MOV      r1,sp
000878  7008              STRB     r0,[r1,#0]
;;;1897     if (TerminalId < sizeof(_aTerminalId)) { // We only support a certain number of channels
00087a  2c10              CMP      r4,#0x10
00087c  d227              BCS      |L1.2254|
;;;1898       ac[1] = _aTerminalId[TerminalId];
00087e  486e              LDR      r0,|L1.2616|
;;;1899       pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
000880  4f6e              LDR      r7,|L1.2620|
000882  5d00              LDRB     r0,[r0,r4]            ;1898
000884  7048              STRB     r0,[r1,#1]            ;1898
;;;1900       SEGGER_RTT_LOCK();                     // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
000886  f3ef8610          MRS      r6,PRIMASK
00088a  2001              MOVS     r0,#1
00088c  f3808810          MSR      PRIMASK,r0
;;;1901       if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
000890  7d38              LDRB     r0,[r7,#0x14]
000892  0780              LSLS     r0,r0,#30
000894  0f80              LSRS     r0,r0,#30
000896  2802              CMP      r0,#2
000898  d00c              BEQ      |L1.2228|
;;;1902         _ActiveTerminal = TerminalId;
;;;1903         _WriteBlocking(pRing, (const char*)ac, 2u);
;;;1904       } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
;;;1905         Avail = _GetAvailWriteSpace(pRing);
00089a  4638              MOV      r0,r7
00089c  f7fffffe          BL       _GetAvailWriteSpace
;;;1906         if (Avail >= 2) {
0008a0  2802              CMP      r0,#2
0008a2  d30e              BCC      |L1.2242|
;;;1907           _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
0008a4  4866              LDR      r0,|L1.2624|
;;;1908           _WriteNoCheck(pRing, (const char*)ac, 2u);
0008a6  2202              MOVS     r2,#2
0008a8  7004              STRB     r4,[r0,#0]            ;1907
0008aa  4669              MOV      r1,sp
0008ac  4638              MOV      r0,r7
0008ae  f7fffffe          BL       _WriteNoCheck
0008b2  e008              B        |L1.2246|
                  |L1.2228|
0008b4  4862              LDR      r0,|L1.2624|
0008b6  2202              MOVS     r2,#2                 ;1903
0008b8  7004              STRB     r4,[r0,#0]            ;1902
0008ba  4638              MOV      r0,r7                 ;1903
0008bc  f7fffffe          BL       _WriteBlocking
0008c0  e001              B        |L1.2246|
                  |L1.2242|
;;;1909         } else {
;;;1910           r = -1;
0008c2  2500              MOVS     r5,#0
0008c4  43ed              MVNS     r5,r5
                  |L1.2246|
;;;1911         }
;;;1912       }
;;;1913       SEGGER_RTT_UNLOCK();
0008c6  b2f0              UXTB     r0,r6
0008c8  f3808810          MSR      PRIMASK,r0
0008cc  e001              B        |L1.2258|
                  |L1.2254|
;;;1914     } else {
;;;1915       r = -1;
0008ce  2500              MOVS     r5,#0
0008d0  43ed              MVNS     r5,r5
                  |L1.2258|
;;;1916     }
;;;1917     return r;
0008d2  4628              MOV      r0,r5
;;;1918   }
0008d4  bdf8              POP      {r3-r7,pc}
;;;1919   
                          ENDP

                  SEGGER_RTT_TerminalOut PROC
;;;1936   */
;;;1937   int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
0008d6  b5f3              PUSH     {r0,r1,r4-r7,lr}
0008d8  4605              MOV      r5,r0
;;;1938     int                   Status;
;;;1939     unsigned              FragLen;
;;;1940     unsigned              Avail;
;;;1941     SEGGER_RTT_BUFFER_UP* pRing;
;;;1942     //
;;;1943     INIT();
0008da  4856              LDR      r0,|L1.2612|
0008dc  b083              SUB      sp,sp,#0xc            ;1937
0008de  7800              LDRB     r0,[r0,#0]
0008e0  2800              CMP      r0,#0
0008e2  d101              BNE      |L1.2280|
0008e4  f7fffffe          BL       _DoInit
                  |L1.2280|
;;;1944     //
;;;1945     // Validate terminal ID.
;;;1946     //
;;;1947     if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
0008e8  2d10              CMP      r5,#0x10
0008ea  d266              BCS      |L1.2490|
;;;1948       //
;;;1949       // Get "to-host" ring buffer.
;;;1950       //
;;;1951       pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0008ec  4c53              LDR      r4,|L1.2620|
;;;1952       //
;;;1953       // Need to be able to change terminal, write data, change back.
;;;1954       // Compute the fixed and variable sizes.
;;;1955       //
;;;1956       FragLen = STRLEN(s);
0008ee  9804              LDR      r0,[sp,#0x10]
0008f0  f7fffffe          BL       strlen
0008f4  4607              MOV      r7,r0
;;;1957       //
;;;1958       // How we output depends upon the mode...
;;;1959       //
;;;1960       SEGGER_RTT_LOCK();
0008f6  f3ef8010          MRS      r0,PRIMASK
0008fa  9001              STR      r0,[sp,#4]
0008fc  2001              MOVS     r0,#1
0008fe  f3808810          MSR      PRIMASK,r0
;;;1961       Avail = _GetAvailWriteSpace(pRing);
000902  4620              MOV      r0,r4
000904  f7fffffe          BL       _GetAvailWriteSpace
000908  4606              MOV      r6,r0
;;;1962       switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
00090a  7d20              LDRB     r0,[r4,#0x14]
00090c  4a4a              LDR      r2,|L1.2616|
00090e  0780              LSLS     r0,r0,#30
000910  0f80              LSRS     r0,r0,#30
000912  d004              BEQ      |L1.2334|
000914  2801              CMP      r0,#1
000916  d024              BEQ      |L1.2402|
000918  2802              CMP      r0,#2
00091a  d124              BNE      |L1.2406|
00091c  e004              B        |L1.2344|
                  |L1.2334|
;;;1963       case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1964         //
;;;1965         // If we are in skip mode and there is no space for the whole
;;;1966         // of this output, don't bother switching terminals at all.
;;;1967         //
;;;1968         if (Avail < (FragLen + 4u)) {
00091e  1d38              ADDS     r0,r7,#4
000920  4286              CMP      r6,r0
000922  d201              BCS      |L1.2344|
;;;1969           Status = 0;
000924  2600              MOVS     r6,#0
000926  e043              B        |L1.2480|
                  |L1.2344|
;;;1970         } else {
;;;1971           _PostTerminalSwitch(pRing, TerminalId);
000928  462b              MOV      r3,r5
00092a  25ff              MOVS     r5,#0xff
00092c  4669              MOV      r1,sp
00092e  700d              STRB     r5,[r1,#0]
000930  4615              MOV      r5,r2
000932  5cd2              LDRB     r2,[r2,r3]
000934  704a              STRB     r2,[r1,#1]
000936  4620              MOV      r0,r4
000938  2202              MOVS     r2,#2
00093a  f7fffffe          BL       _WriteBlocking
;;;1972           Status = (int)_WriteBlocking(pRing, s, FragLen);
00093e  463a              MOV      r2,r7
000940  4620              MOV      r0,r4
000942  9904              LDR      r1,[sp,#0x10]
000944  f7fffffe          BL       _WriteBlocking
000948  4606              MOV      r6,r0
;;;1973           _PostTerminalSwitch(pRing, _ActiveTerminal);
00094a  483d              LDR      r0,|L1.2624|
00094c  22ff              MOVS     r2,#0xff
00094e  7800              LDRB     r0,[r0,#0]  ; _ActiveTerminal
000950  4669              MOV      r1,sp
000952  700a              STRB     r2,[r1,#0]
000954  5c28              LDRB     r0,[r5,r0]
000956  7048              STRB     r0,[r1,#1]
000958  2202              MOVS     r2,#2
00095a  4620              MOV      r0,r4
00095c  f7fffffe          BL       _WriteBlocking
000960  e026              B        |L1.2480|
                  |L1.2402|
;;;1974         }
;;;1975         break;
;;;1976       case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1977         //
;;;1978         // If we are in trim mode and there is not enough space for everything,
;;;1979         // trim the output but always include the terminal switch.  If no room
;;;1980         // for terminal switch, skip that totally.
;;;1981         //
;;;1982         if (Avail < 4u) {
000962  2e04              CMP      r6,#4
000964  d202              BCS      |L1.2412|
                  |L1.2406|
;;;1983           Status = -1;
000966  2600              MOVS     r6,#0
000968  43f6              MVNS     r6,r6
00096a  e021              B        |L1.2480|
                  |L1.2412|
00096c  21ff              MOVS     r1,#0xff
00096e  466b              MOV      r3,sp
000970  7019              STRB     r1,[r3,#0]
000972  4931              LDR      r1,|L1.2616|
;;;1984         } else {
;;;1985           _PostTerminalSwitch(pRing, TerminalId);
000974  4620              MOV      r0,r4
000976  5d49              LDRB     r1,[r1,r5]
000978  7059              STRB     r1,[r3,#1]
00097a  2202              MOVS     r2,#2
00097c  4669              MOV      r1,sp
00097e  f7fffffe          BL       _WriteBlocking
;;;1986           Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
000982  1f30              SUBS     r0,r6,#4
000984  4287              CMP      r7,r0
000986  d300              BCC      |L1.2442|
000988  4607              MOV      r7,r0
                  |L1.2442|
00098a  463a              MOV      r2,r7
00098c  4620              MOV      r0,r4
00098e  9904              LDR      r1,[sp,#0x10]
000990  f7fffffe          BL       _WriteBlocking
000994  4606              MOV      r6,r0
;;;1987           _PostTerminalSwitch(pRing, _ActiveTerminal);
000996  482a              LDR      r0,|L1.2624|
000998  21ff              MOVS     r1,#0xff
00099a  7800              LDRB     r0,[r0,#0]  ; _ActiveTerminal
00099c  466a              MOV      r2,sp
00099e  7011              STRB     r1,[r2,#0]
0009a0  4925              LDR      r1,|L1.2616|
0009a2  5c08              LDRB     r0,[r1,r0]
0009a4  7050              STRB     r0,[r2,#1]
0009a6  2202              MOVS     r2,#2
0009a8  4669              MOV      r1,sp
0009aa  4620              MOV      r0,r4
0009ac  f7fffffe          BL       _WriteBlocking
                  |L1.2480|
;;;1988         }
;;;1989         break;
;;;1990       case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1991         //
;;;1992         // If we are in blocking mode, output everything.
;;;1993         //
;;;1994         _PostTerminalSwitch(pRing, TerminalId);
;;;1995         Status = (int)_WriteBlocking(pRing, s, FragLen);
;;;1996         _PostTerminalSwitch(pRing, _ActiveTerminal);
;;;1997         break;
;;;1998       default:
;;;1999         Status = -1;
;;;2000         break;
;;;2001       }
;;;2002       //
;;;2003       // Finish up.
;;;2004       //
;;;2005       SEGGER_RTT_UNLOCK();
0009b0  9801              LDR      r0,[sp,#4]
0009b2  b2c0              UXTB     r0,r0
0009b4  f3808810          MSR      PRIMASK,r0
0009b8  e001              B        |L1.2494|
                  |L1.2490|
;;;2006     } else {
;;;2007       Status = -1;
0009ba  2600              MOVS     r6,#0
0009bc  43f6              MVNS     r6,r6
                  |L1.2494|
;;;2008     }
;;;2009     return Status;
0009be  4630              MOV      r0,r6
;;;2010   }
0009c0  b005              ADD      sp,sp,#0x14
0009c2  bdf0              POP      {r4-r7,pc}
;;;2011   
                          ENDP

                  SEGGER_RTT_GetAvailWriteSpace PROC
;;;2024   */
;;;2025   unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex) {
0009c4  2118              MOVS     r1,#0x18
;;;2026     SEGGER_RTT_BUFFER_UP* pRing;
;;;2027   
;;;2028     pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
0009c6  4348              MULS     r0,r1,r0
0009c8  491a              LDR      r1,|L1.2612|
0009ca  b510              PUSH     {r4,lr}               ;2025
0009cc  1840              ADDS     r0,r0,r1
0009ce  3018              ADDS     r0,r0,#0x18
;;;2029     return _GetAvailWriteSpace(pRing);
0009d0  f7fffffe          BL       _GetAvailWriteSpace
;;;2030   }
0009d4  bd10              POP      {r4,pc}
;;;2031   
                          ENDP

                  SEGGER_RTT_GetBytesInBuffer PROC
;;;2045   */
;;;2046   unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
0009d6  4917              LDR      r1,|L1.2612|
;;;2047     unsigned RdOff;
;;;2048     unsigned WrOff;
;;;2049     unsigned r;
;;;2050     volatile SEGGER_RTT_CB* pRTTCB;
;;;2051     //
;;;2052     // Avoid warnings regarding volatile access order.  It's not a problem
;;;2053     // in this case, but dampen compiler enthusiasm.
;;;2054     //
;;;2055     pRTTCB = (volatile SEGGER_RTT_CB*)((unsigned char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
;;;2056     RdOff = pRTTCB->aUp[BufferIndex].RdOff;
0009d8  2218              MOVS     r2,#0x18
0009da  4350              MULS     r0,r2,r0
0009dc  1842              ADDS     r2,r0,r1
0009de  6a91              LDR      r1,[r2,#0x28]
;;;2057     WrOff = pRTTCB->aUp[BufferIndex].WrOff;
0009e0  6a50              LDR      r0,[r2,#0x24]
;;;2058     if (RdOff <= WrOff) {
0009e2  4281              CMP      r1,r0
0009e4  d801              BHI      |L1.2538|
;;;2059       r = WrOff - RdOff;
0009e6  1a40              SUBS     r0,r0,r1
;;;2060     } else {
;;;2061       r = pRTTCB->aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
;;;2062     }
;;;2063     return r;
;;;2064   }
0009e8  4770              BX       lr
                  |L1.2538|
0009ea  6a12              LDR      r2,[r2,#0x20]         ;2061
0009ec  1a40              SUBS     r0,r0,r1              ;2061
0009ee  1a10              SUBS     r0,r2,r0              ;2061
0009f0  4770              BX       lr
;;;2065   
                          ENDP

                  SEGGER_RTT_TerminalPrintf PROC
;;;2095   */
;;;2096   int SEGGER_RTT_TerminalPrintf(unsigned TerminalId, const char * sFormat, ...) {
0009f2  2810              CMP      r0,#0x10
;;;2097     int r;
;;;2098     va_list ParamList;
;;;2099     
;;;2100     if(TerminalId > (char)sizeof(_aTerminalId)){
0009f4  d902              BLS      |L1.2556|
;;;2101       return -1;
0009f6  2000              MOVS     r0,#0
0009f8  43c0              MVNS     r0,r0
;;;2102     }
;;;2103     SEGGER_RTT_SetTerminal(TerminalId);
;;;2104   
;;;2105     va_start(ParamList, sFormat);
;;;2106     r = SEGGER_RTT_vprintf(0, sFormat, &ParamList);
;;;2107     va_end(ParamList);
;;;2108     return r;
;;;2109   }
0009fa  4770              BX       lr
                  |L1.2556|
0009fc  b40f              PUSH     {r0-r3}               ;2096
0009fe  b508              PUSH     {r3,lr}               ;2096
000a00  b2c0              UXTB     r0,r0                 ;2103
000a02  f7fffffe          BL       SEGGER_RTT_SetTerminal
000a06  a804              ADD      r0,sp,#0x10           ;2105
000a08  9000              STR      r0,[sp,#0]            ;2106
000a0a  466a              MOV      r2,sp                 ;2106
000a0c  2000              MOVS     r0,#0                 ;2106
000a0e  9903              LDR      r1,[sp,#0xc]          ;2106
000a10  f7fffffe          BL       SEGGER_RTT_vprintf
000a14  b001              ADD      sp,sp,#4
000a16  bc08              POP      {r3}
000a18  b004              ADD      sp,sp,#0x10
000a1a  4718              BX       r3
;;;2110   
                          ENDP

                  _GetAvailWriteSpace PROC
;;;511    */
;;;512    static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
000a1c  6902              LDR      r2,[r0,#0x10]
;;;513      unsigned RdOff;
;;;514      unsigned WrOff;
;;;515      unsigned r;
;;;516      //
;;;517      // Avoid warnings regarding volatile access order.  It's not a problem
;;;518      // in this case, but dampen compiler enthusiasm.
;;;519      //
;;;520      RdOff = pRing->RdOff;
;;;521      WrOff = pRing->WrOff;
;;;522      if (RdOff <= WrOff) {
000a1e  68c1              LDR      r1,[r0,#0xc]
000a20  428a              CMP      r2,r1
000a22  d803              BHI      |L1.2604|
;;;523        r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
000a24  6880              LDR      r0,[r0,#8]
000a26  1a40              SUBS     r0,r0,r1
000a28  1880              ADDS     r0,r0,r2
000a2a  e000              B        |L1.2606|
                  |L1.2604|
;;;524      } else {
;;;525        r = RdOff - WrOff - 1u;
000a2c  1a50              SUBS     r0,r2,r1
                  |L1.2606|
000a2e  1e40              SUBS     r0,r0,#1
;;;526      }
;;;527      return r;
;;;528    }
000a30  4770              BX       lr
;;;529    
                          ENDP

000a32  0000              DCW      0x0000
                  |L1.2612|
                          DCD      ||.bss||
                  |L1.2616|
                          DCD      ||.data||+0x1
                  |L1.2620|
                          DCD      ||.bss||+0x18
                  |L1.2624|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _SEGGER_RTT
                          %        72
                  _acUpBuffer
                          %        256
                  _acDownBuffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  _ActiveTerminal
000000  00                DCB      0x00
                  _aTerminalId
000001  303132            DCB      0x30,0x31,0x32
000004  33343536          DCB      0x33,0x34,0x35,0x36
000008  37383941          DCB      0x37,0x38,0x39,0x41
00000c  42434445          DCB      0x42,0x43,0x44,0x45
000010  46                DCB      0x46

                          AREA ||i.__ARM_common_memcpy4_7||, COMGROUP=__ARM_common_memcpy4_7, CODE, READONLY, ALIGN=1

                  __ARM_common_memcpy4_7 PROC
000000  680a              LDR      r2,[r1,#0]
000002  6002              STR      r2,[r0,#0]
000004  888b              LDRH     r3,[r1,#4]
000006  8083              STRH     r3,[r0,#4]
000008  798a              LDRB     r2,[r1,#6]
00000a  7182              STRB     r2,[r0,#6]
00000c  4770              BX       lr
                          ENDP

