L 1 "src\rain.c"
N#include "rain.h"
L 1 "src\rain.h" 1
N#ifndef __RAIN_H__
N#define __RAIN_H__
N
N#include "includes.h"
L 1 "src\includes.h" 1
N#ifndef __INCLUDES_H__
N#define __INCLUDES_H__
N
N#include "BF7006AMxx_config.h"
L 1 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 1
N/*!
N    \file  BF7006AMxx_config.h
N    \brief peripherals configuration for BF7006AMxx
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2021-02-28, V1.0.0, peripherals configuration for BF7006AMxx
N*/
N
N#ifndef BF7006AMxx_CONFIG_H
N#define BF7006AMxx_CONFIG_H
N
N#include "RTE_Components.h"
L 1 ".\RTE\_b40\RTE_Components.h" 1
N
N/*
N * Auto generated Run-Time-Environment Configuration File
N *      *** Do not modify ! ***
N *
N * Project: 'b40' 
N * Target:  'b40' 
N */
N
N#ifndef RTE_COMPONENTS_H
N#define RTE_COMPONENTS_H
N
N
N/*
N * Define the Device Header File: 
N */
N#define CMSIS_device_header "BF7006AMxx.h"
N
N/* BYD::Device:Peripheral Driver:ADC:1.0.2 */
N#define BF7x06AMxx_ADC_DRIVER_PRESENT
N/* BYD::Device:Peripheral Driver:CAN:1.0.2 */
N#define BF7x06AMxx_CAN_DRIVER_PRESENT
N/* BYD::Device:Peripheral Driver:EFlash:1.0.3 */
N#define BF7x06AMxx_EFLASH_DRIVER_PRESENT
N/* BYD::Device:Peripheral Driver:GPIO:1.0.2 */
N#define BF7x06AMxx_GPIO_DRIVER_PRESENT
N/* BYD::Device:Peripheral Driver:PWM:1.0.3 */
N#define BF7x06AMxx_PWM_DRIVER_PRESENT
N/* BYD::Device:Peripheral Driver:RTC:1.0.2 */
N#define BF7x06AMxx_RTC_DRIVER_PRESENT
N/* BYD::Device:Peripheral Driver:Timer:1.0.2 */
N#define BF7x06AMxx_TIMER_DRIVER_PRESENT
N/* BYD::Device:Peripheral Driver:Watch Dog Timer:1.0.2 */
N#define BF7x06AMxx_WDT_DRIVER_PRESENT
N
N
N#endif /* RTE_COMPONENTS_H */
L 16 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N#include "BF7006AMxx.h"
L 1 ".\RTE\CMSIS\BF7006AM64\BF7006AMxx.h" 1
N/*!
N    \file  BF7006AMxx.h
N    \brief definitions for the BF7006AMxx
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2017-12-27, V1.0, firmware for BF7006AMxx
N*/
N
N#ifndef BF7006AMXX_H
N#define BF7006AMXX_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
Ntypedef enum {FALSE = 0, TRUE = !FALSE} bool;
N#define false                   FALSE
N#define true                    TRUE
N
Ntypedef enum {RESET = 0U, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0U, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0U, SUCCESS = !ERROR} ErrorStatus;
N
N#define NULL                    ((void *)0)
N    
Ntypedef unsigned char           UINT8;              /* unsigned 8 bit definition    */
Ntypedef unsigned short          UINT16;             /* unsigned 16 bit definition   */
Ntypedef unsigned int            UINT32;             /* unsigned 32 bit definition   */
Ntypedef signed char             INT8;               /* signed 8 bit definition      */
Ntypedef short                   INT16;              /* signed 16 bit definition     */
Ntypedef signed int              INT32;              /* signed 32 bit definition     */
Ntypedef void(*pt2Func)(void);                       /* Pointer to Functions, void argument              */
Ntypedef void(*pt2FuncU8)(UINT8);                    /* Pointer to Functions, UINT8 argument             */
Ntypedef void(*pt2FuncU32)(UINT32);                  /* Pointer to Functions, UINT32 argument            */
Ntypedef void(*pt2FuncU32U8)(UINT32,UINT8);          /* Pointer to Functions, UINT32 and UINT8 argument  */
N    
N/* bit operations */
N#define REG32(addr)             (*((volatile uint32_t *)((uint32_t)(addr))))
N#define REG16(addr)             (*((volatile uint16_t *)((uint32_t)(addr))))
N#define REG8(addr)              (*((volatile uint8_t *)((uint32_t)(addr))))
N#define BIT(x)                  ((uint32_t)(0x01UL<<((uint8_t)(x))))
N//#define BIT(x)                  ((uint8_t)(((uint8_t)0x01)<<((uint32_t)x)))
N
N//#define    BIT(0)               ((uint8_t)((uint8_t)0x01<<(x)))
N#define BITS(start, end)                ((uint32_t)((0xFFFFFFFFUL << ((uint8_t)(start))) & (0xFFFFFFFFUL >> (31U - ((uint8_t)(end)))))) 
N#define GET_BITS(regval, start, end)    (((regval) & BITS((start),(end))) >> (start))
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
Ntypedef enum IRQn
N{
N/* -------------------  Cortex-M0 Processor Exceptions Numbers  ------------------- */
N  NonMaskableInt_IRQn           = -14,      /*!<  2 Non Maskable Interrupt          */
N  HardFault_IRQn                = -13,      /*!<  3 HardFault Interrupt             */
N  SVCall_IRQn                   =  -5,      /*!< 11 SV Call Interrupt               */
N  PendSV_IRQn                   =  -2,      /*!< 14 Pend SV Interrupt               */
N  SysTick_IRQn                  =  -1,      /*!< 15 System Tick Interrupt           */
N
N/* ----------------------  ARMCM0 Specific Interrupt Numbers  --------------------- */
N  RESERVED0                     =   0,      /*!<                                    */
N  SYS_IRQn                      =   1,      /*!< Flash ECC Error Interrupt          */
N  RESERVED1                     =   2,      /*!<                                    */
N  RESERVED2                     =   3,      /*!<                                    */
N  LVDT_IRQn                     =   4,      /*!< LVDT Interrupt                     */
N  PWM_CH0_IRQn                  =   5,      /*!< PWM channel 0 Interrupt            */
N  PWM_CH1_IRQn                  =   6,      /*!< PWM channel 1 Interrupt            */
N  PWM_CH2_IRQn                  =   7,      /*!< PWM channel 2 Interrupt            */
N  PWM_CH3_IRQn                  =   8,      /*!< PWM channel 3 Interrupt            */
N  PWM_CH4_IRQn                  =   9,      /*!< PWM channel 4 Interrupt            */
N  PWM_CH5_IRQn                  =  10,      /*!< PWM channel 5 Interrupt            */
N  PWM_TOF_IRQN                  =  11,      /*!< PWM overflow Interrupt             */
N  RESERVED4                     =  12,      /*!<                                    */
N  RESERVED5                     =  13,      /*!<                                    */
N  RESERVED6                     =  14,      /*!<                                    */
N  RESERVED7                     =  15,      /*!<                                    */
N  SCI0_ERR_IRQn                 =  16,      /*!< SCI0 ERR Interrupt                 */
N  SCI0_RX_IRQn                  =  17,      /*!< SCI0 RX Interrupt                  */
N  SCI0_TX_IRQn                  =  18,      /*!< SCI0 TX Interrupt                  */
N  SCI1_ERR_IRQn                 =  19,      /*!< SCI1 ERR Interrupt                 */
N  SCI1_RX_IRQn                  =  20,      /*!< SCI1 RX Interrupt                  */
N  SCI1_TX_IRQn                  =  21,      /*!< SCI1 TX Interrupt                  */
N  GPIO_IRQn                     =  22,      /*!< GPIO External Interrupt            */
N  ADC_IRQn                      =  23,      /*!< ADC Interrupt                      */
N  RESERVED8                     =  24,      /*!<                                    */
N  RTC_IRQn                      =  25,      /*!< RTC Interrupt                      */
N  CAN_WAKE_IRQn                 =  26,      /*!< CAN Interrupt                      */
N  CAN_ERR_IRQn                  =  27,      /*!< CAN ERR Interrupt                  */
N  CAN_RX_IRQn                   =  28,      /*!< CAN RX Interrupt                   */
N  CAN_TX_IRQn                   =  29,      /*!< CAN TX Interrupt                   */
N  TIMER0_IRQn                   =  30,      /*!< Timer0 Interrupt                   */
N  TIMER1_IRQn                   =  31,      /*!< Timer1 Interrupt                   */
N} IRQn_Type;
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* --------  Configuration of the Cortex-M4 Processor and Core Peripherals  ------- */
N#define __CM0_REV                   0x0000      /*!< Core revision r0p0                              */
N#define __MPU_PRESENT               0           /*!< MPU present or not                              */
N#define __NVIC_PRIO_BITS            2           /*!< Number of Bits used for Priority Levels         */
N#define __Vendor_SysTickConfig      0           /*!< Set to 1 if different SysTick Config is used    */
N
N#include "core_cm0.h"                           /* Processor and core peripherals                    */
L 1 ".\RTE\CMSIS\BF7006AM64\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V5.0.1
N * @date     25. November 2016
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2016 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060960 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include "stdint.h"
L 1 ".\RTE\CMSIS\BF7006AM64\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060034
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 ".\RTE\CMSIS\BF7006AM64\core_cm0.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  ( 5U)                                  /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   ( 0U)                                  /*!< [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )  /*!< CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060960 >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 ".\RTE\CMSIS\BF7006AM64\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.1
N * @date     30. January 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include "stdint.h"
N
N/*
N * ARM Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 ".\RTE\CMSIS\BF7006AM64\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (ARM compiler V5) header file
N * @version  V5.0.1
N * @date     03. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060960 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                     __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                  __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE           static __inline
N#endif
N#ifndef   __NO_RETURN
N  #define __NO_RETURN               __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                    __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                    __attribute__((weak))
N#endif
N#ifndef   __UNALIGNED_UINT32
N  #define __UNALIGNED_UINT32(x)     (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)              __attribute__((aligned(x)))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                  __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT           __packed struct
N#endif
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#else
S  (void)fpscr;
S#endif
S}
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  int32_t s = (4 /*sizeof(v)*/ * 8) - 1; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return(result);
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 ".\RTE\CMSIS\BF7006AM64\cmsis_compiler.h" 2
N
N
N/*
N * ARM Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060960 >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S
S  #include <cmsis_iar.h>
S
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __noreturn
S  #endif
S  #ifndef   __USED
S    #define __USED                    __root
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    __packed struct T_UINT32 { uint32_t v; };
S      #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           __packed struct
S  #endif
S
S
S/*
S * TI ARM Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                    __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __attribute__((weak))
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __attribute__((aligned(x)))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           struct __attribute__((packed))
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                     __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN               __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                    __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __attribute__((weak))
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           struct __packed__
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                     _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                  inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE           static inline
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                    __weak
S  #endif
S  #ifndef   __UNALIGNED_UINT32
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                  @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT           @packed struct
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 114 ".\RTE\CMSIS\BF7006AM64\core_cm0.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifndef CMSIS_NVIC_VIRTUAL
N/*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0 */
N/*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0 */
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifndef CMSIS_VECTAB_VIRTUAL
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           Address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)0x0U;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)0x0U;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 110 ".\RTE\CMSIS\BF7006AM64\BF7006AMxx.h" 2
N#include "system_ARMCM0.h"                      /* System Header                                     */
L 1 ".\RTE\CMSIS\BF7006AM64\system_ARMCM0.h" 1
N/**************************************************************************//**
N * @file     system_ARMCM0.h
N * @brief    CMSIS Device System Header File for
N *           ARMCM0 Device Series
N * @version  V1.08
N * @date     23. November 2012
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2011 - 2012 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef SYSTEM_ARMCM0_H
N#define SYSTEM_ARMCM0_H
N
N#include "stdint.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
Nextern uint32_t SystemCoreClock;     /*!< System Clock Frequency (Core Clock)  */
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_ARMCM0_H */
L 111 ".\RTE\CMSIS\BF7006AM64\BF7006AMxx.h" 2
N
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__ICCARM__)
X#elif 0L
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#elif defined ( __CSMC__ )      /* Cosmic */
S/* anonymous unions are enabled by default */
S#else
S  #warning Not supported compiler type
N#endif
N
N
N/**
N  \brief   System Sleeping
N  \details system step into sleeping mode
N */
N__STATIC_INLINE void System_Sleeping(void)
Xstatic __inline void System_Sleeping(void)
N{
N    SCB->SCR &= (uint32_t)(~SCB_SCR_SLEEPDEEP_Msk);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR &= (uint32_t)(~(1UL << 2U));
N    __WFI();
X    __wfi();
N}
N
N/**
N  \brief   System Sleepdeep
N  \details system step into sleepdeep mode
N */
N__STATIC_INLINE void System_SleepDeep(void)
Xstatic __inline void System_SleepDeep(void)
N{
N    SCB->SCR |= (uint32_t)SCB_SCR_SLEEPDEEP_Msk;
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR |= (uint32_t)(1UL << 2U);
N    __WFI();
X    __wfi();
N}
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void set_MSP(uint32_t topOfMainStack)
Xstatic __inline void set_MSP(uint32_t topOfMainStack)
N{
N    __set_MSP(topOfMainStack);
N}
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void set_PSP(uint32_t topOfProcStack)
Xstatic __inline void set_PSP(uint32_t topOfProcStack)
N{
N    __set_PSP(topOfProcStack);
N}
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N__STATIC_INLINE void NOP(void)
Xstatic __inline void NOP(void)
N{
N    __NOP();
X    __nop();
N}
N
N/**
N  \brief   Enable Interrupt
N  \details Enable Interrupt. This instruction can be used for code alignment purposes.
N */
N__STATIC_INLINE void Enable_Irq(void)
Xstatic __inline void Enable_Irq(void)
N{
N    __enable_irq();
N}
N
N/**
N  \brief   Disable Interrupt
N  \details Disable interrupt. This instruction can be used for code alignment purposes.
N */
N__STATIC_INLINE void Disable_Irq(void)
Xstatic __inline void Disable_Irq(void)
N{
N    __disable_irq();
N}
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE              ((uint32_t)0x00000000)          ///< Flash base address
N#define FLASH_NVR_BASE          ((uint32_t)0x00018000)          ///< Flash information block,read only
N#define SRAM_BASE               ((uint32_t)0x20000000)          ///< SRAM base address
N#define EEPROM_BASE             ((uint32_t)0x40000000)          ///< EEPROM base address
N#define AHBPERIPH_BASE          ((uint32_t)0x50000000)          ///< AHB base address
N
N/* Peripheral memory map */
N#define EFLASH_CTRL_BASE        (AHBPERIPH_BASE + (uint32_t)0x00000)    ///< FLASH and EEPROM register base address
N#define SYSCTRL_BASE            (AHBPERIPH_BASE + (uint32_t)0x10000)    ///< SYS control register base address
N#define SCI_BASE                (AHBPERIPH_BASE + (uint32_t)0x40000)    ///< LIN0 register base address
N#define CAN_BASE                (AHBPERIPH_BASE + (uint32_t)0x50000)    ///< CAN register base address
N#define PWM_BASE                (AHBPERIPH_BASE + (uint32_t)0x60000)    ///< PWM register base address
N#define RTC_BASE                (AHBPERIPH_BASE + (uint32_t)0x70000)    ///< RTC register base address
N#define WDT_BASE                (AHBPERIPH_BASE + (uint32_t)0x80000)    ///< WDT register base address
N#define ADC_BASE                (AHBPERIPH_BASE + (uint32_t)0x90000)    ///< ADC/ACMP register base address
N#define GPIO_BASE               (AHBPERIPH_BASE + (uint32_t)0xA0000)    ///< GPIO register base address
N#define TIMER_BASE              (AHBPERIPH_BASE + (uint32_t)0xB0000)    ///< Timer0/1 register base address
N
N#define SCI0                    (SCI_BASE       + (uint32_t)0x0000)     ///< SCI0 register base address
N#define SCI1                    (SCI_BASE       + (uint32_t)0x4000)     ///< SCI1 register base address
N
N#define GPIOA                   (GPIO_BASE      + (uint32_t)0x0000)     ///< GPIOA register base address
N#define GPIOB                   (GPIO_BASE      + (uint32_t)0x001C)     ///< GPIOB register base address
N#define GPIOC                   (GPIO_BASE      + (uint32_t)0x0038)     ///< GPIOC register base address
N#define GPIOD                   (GPIO_BASE      + (uint32_t)0x0048)     ///< GPIOD register base address
N#define GPIOE                   (GPIO_BASE      + (uint32_t)0x0064)     ///< GPIOE register base address
N#define GPIOF                   (GPIO_BASE      + (uint32_t)0x0074)     ///< GPIOF register base address
N#define GPIOG                   (GPIO_BASE      + (uint32_t)0x0084)     ///< GPIOG register base address
N
N#define TIMER0                  (TIMER_BASE     + (uint32_t)0x0000)     ///< Timer0 register base address
N#define TIMER1                  (TIMER_BASE     + (uint32_t)0x4000)     ///< Timer1 register base address
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
X#elif 0L
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#elif defined ( __CSMC__ )      /* Cosmic */
S/* anonymous unions are enabled by default */
S#else
S  #warning Not supported compiler type
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* ARMCM0_H */
L 17 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N#include "BF7006AMxx_sysctrl.h"
L 1 ".\RTE\Device\BF7006AM64\BF7006AMxx_sysctrl.h" 1
N/*!
N    \file  BF7006AMxx_sys.h
N    \brief definitions for the system control
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2017-12-27, V1.0.0, firmware for BF7006AMxx
N	2019-11-22, V1.0.2, firmware for BF7006AMxx
N    2021-03-03, V1.0.3, add variable SystemCoreClock update function in system_clk_sel(void)
N*/
N
N#ifndef BF7006AMxx_SYS_H
N#define	BF7006AMxx_SYS_H
N
N#include "BF7006AMxx.h"
N
N/* registers definitions */
N#define SYS_PTSEL                   (REG32(SYSCTRL_BASE + 0x00U))       /*!< sci2 port function remap register          */
N#define SYS_XTAL_CTRL               (REG32(SYSCTRL_BASE + 0x04U))       /*!< xtal control register                      */
N#define SYS_PLL_SOURCE_SEL          (REG32(SYSCTRL_BASE + 0x08U))       /*!< pll source clock select register           */
N#define SYS_CLK_SEL                 (REG32(SYSCTRL_BASE + 0x0CU))       /*!< system clock select register               */
N#define SYS_VECTOR_OFFSET           (REG32(SYSCTRL_BASE + 0x10U))       /*!< interrupt vector address offset register   */
N#define SYS_CLK_PD                  (REG32(SYSCTRL_BASE + 0x14U))       /*!< analog clock power down register           */
N#define SYS_CAN_DOMAIN              (REG32(SYSCTRL_BASE + 0x18U))       /*!< can domain count register                  */
N#define SYS_CLK_OUT                 (REG32(SYSCTRL_BASE + 0x1CU))       /*!< analog clock output register               */
N#define SYS_IO_LOCK                 (REG32(SYSCTRL_BASE + 0x20U))       /*!< lock io direction register                 */
N#define SYS_LVDT_CRL                (REG32(SYSCTRL_BASE + 0x24U))       /*!< bor and lvdt control register              */
N#define SYS_EXRST                   (REG32(SYSCTRL_BASE + 0x28U))       /*!< external reset function enable register    */
N#define SYS_EXFLT                   (REG32(SYSCTRL_BASE + 0x2CU))       /*!< external filiter enable register           */
N#define SYS_BIST                    (REG32(SYSCTRL_BASE + 0x30U))       /*!< sram bist test state register              */
N#define SYS_PERH_HALT               (REG32(SYSCTRL_BASE + 0x34U))       /*!< PWM/WDT enable or not in debug mode when halt*/
N#define SYS_PLL_T                   (REG32(SYSCTRL_BASE + 0x38U))       /*!< PLL standby timer set register             */
N#define SYS_DUMMY                   (REG32(SYSCTRL_BASE + 0x3CU))       /*!< dummy register                             */
N#define SYS_CAN_CLKSEL              (REG32(SYSCTRL_BASE + 0x40U))       /*!< CAN clock select register                  */
N#define SYS_CAN_RST                 (REG32(SYSCTRL_BASE + 0x44U))       /*!< CAN module reset register                  */
N#define SYS_CAN_SPWKFLAG            (REG32(SYSCTRL_BASE + 0x48U))       /*!< CAN wake up from deelsleep state register  */
N#define SYS_RSTSTAT                 (REG32(SYSCTRL_BASE + 0x100U))      /*!< reset status register                      */
N#define SYS_INTEN                   (REG32(SYSCTRL_BASE + 0x104U))      /*!< system interrupt enable register           */
N#define SYS_INTFLG                  (REG32(SYSCTRL_BASE + 0x108U))      /*!< system interrupt flag register             */
N#define SYS_XTAL_CHK                (REG32(SYSCTRL_BASE + 0x10CU))      /*!< xtal clcok check control register          */
N#define SYS_XTAL_CHKCNT             (REG32(SYSCTRL_BASE + 0x110U))      /*!< xtal check count set register              */
N#define SYS_XTAL_INIT               (REG32(SYSCTRL_BASE + 0x114U))      /*!< xtal initialize control register           */
N#define SYS_LVDT_IE                 (REG32(SYSCTRL_BASE + 0x118U))      /*!< lvdt interrupt enable register             */
N#define SYS_LVDT_IF                 (REG32(SYSCTRL_BASE + 0x11CU))      /*!< lvdt interrupt flag register               */
N
N/* bits registers definitions */
N/* SYS_XTAL_CTRL */
N#define SYS_XTAL_CTRL_PD            BIT(7)                              /*!< xtal pown down flag                */
N#define SYS_XTAL_CTRL_CNT           BITS(4,6)                           /*!< xtal valid count                   */
N#define SYS_XTAL_CTRL_INIT          BIT(3)                              /*!< xtal initialize complete flag      */
N#define SYS_XTAL_CTRL_SLEEPPD       BIT(1)                              /*!< xtal powndown in sleepdeep mode    */
N#define SYS_XTAL_CTRL_EN            BIT(0)                              /*!< xtal enable                        */
N
N/* SYS_CLK */
N#define SYS_CLK_SYSSEL              BIT(2)                              /*!< system clock select pll or xtal    */
N#define SYS_CLK_PLLDIV              BITS(0,1)                           /*!< pll clock divide                   */
N#define SYS_CLK_PLLDIV_Pos          0                                   /*!< pll clock divide postion           */
N
N/* SYS_CLK_PD */
N#define SYS_CLK_PD_LVDT             BIT(2)                              /*!< lvdt powerdown     */
N#define SYS_CLK_PD_BOR              BIT(1)                              /*!< bor powerdown      */
N#define SYS_CLK_PD_RC128K           BIT(0)                              /*!< rc128k powerdown   */
N
N/* SYS_RSTSTAT */
N#define SYS_RSTSTAT_XTALCHK         BIT(8)
N#define SYS_RSTSTAT_XTALINIT        BIT(7)
N#define SYS_RSTSTAT_ADDR_FLOW       BIT(6)
N#define SYS_RSTSTAT_EXRST           BIT(5)
N#define SYS_RSTSTAT_LOCKUP          BIT(4)
N#define SYS_RSTSTAT_SOFT            BIT(3)
N#define SYS_RSTSTAT_WDT             BIT(2)
N#define SYS_RSTSTAT_POR             BIT(0)
N
N/* SYS_INTEN */
N#define SYS_INTEN_LVDT              BIT(9)                  /*!< lower power detect interrupt enable                */
N#define SYS_INTEN_ETER              BIT(8)                  /*!< eeprom ECC error two bits or more interrupt enable */
N#define SYS_INTEN_EOER              BIT(7)                  /*!< eeprom ECC error one bit interrupt enable          */
N#define SYS_INTEN_FTER              BIT(6)                  /*!< flash ECC error two bits or more interrupt enable  */
N#define SYS_INTEN_FOER              BIT(5)                  /*!< flash ECC error one bit interrupt enable           */
N#define SYS_INTEN_EPOT              BIT(4)                  /*!< eeprom protect range illegal access interrupt enable */
N#define SYS_INTEN_FPOT              BIT(3)                  /*!< flash protect range illegal access interrupt enable  */
N#define SYS_INTEN_ADJ               BIT(2)                  /*!< config bits error interrupt enable                 */
N#define SYS_INTEN_XTALCHK           BIT(1)                  /*!< xtal check eroor interrupt enable                  */
N#define SYS_INTEN_XTALINIT          BIT(0)                  /*!< xtal initialize timeout interrupt enable           */
N
N/* SYS_INTFLG */
N#define SYS_INTFLG_LVDT             BIT(9)                  /*!< lower power detect interrupt flag                  */
N#define SYS_INTFLG_ETER             BIT(8)                  /*!< eeprom ECC error two bits or more interrupt flag   */
N#define SYS_INTFLG_EOER             BIT(7)                  /*!< eeprom ECC error one bit interrupt flag            */
N#define SYS_INTFLG_FTER             BIT(6)                  /*!< flash ECC error two bits or more interrupt flag    */
N#define SYS_INTFLG_FOER             BIT(5)                  /*!< flash ECC error one bit interrupt flag             */
N#define SYS_INTFLG_EPOT             BIT(4)                  /*!< eeprom protect range illegal access interrupt flag */
N#define SYS_INTFLG_FPOT             BIT(3)                  /*!< flash protect range illegal access interrupt flag  */
N#define SYS_INTFLG_ADJ              BIT(2)                  /*!< config bits error interrupt flag                   */
N#define SYS_INTFLG_XTALCHK          BIT(1)                  /*!< xtal check eroor interrupt flag                    */
N#define SYS_INTFLG_XTALINIT         BIT(0)                  /*!< xtal initialize timeout interrupt flag             */
N
N/* SYS_XTAL_CHK */
N#define SYS_XTAL_CHK_RSTEN          BIT(1)                  /*!< xtal check fail reset enable */
N#define SYS_XTAL_CHK_EN             BIT(0)                  /*!< xtal check enable            */
N
N/* SYS_XTAL_INIT */
N#define SYS_XTAL_INIT_RSTEN         BIT(1)                  /*!< xtal initialize fail reset enable */
N#define SYS_XTAL_INIT_EN            BIT(0)                  /*!< xtal initialize timeout enable    */
N
N/* constants definitions */
N/* sci1 port select define */
N#define SCI1_PF0_PF1                0                       /*!< select PF0 and PF1 as sci1 */
N#define SCI1_PE2_PE3                1                       /*!< select PE2 and PE3 as sci1 */
N#define SCI1_PE6_PE7                2                       /*!< select PE6 and PE7 as sci1 */
N
N/* PLL source clock select define */
N#define SYS_PLL_SEL_RC1M            0xacb3U                 /*!< pll source clock select rc_1M      */
N#define SYS_PLL_SEL_XTAL_16M        0xccd2U                 /*!< pll source clock select xtal/16    */
N#define SYS_PLL_SEL_XTAL_12M        0xbd5aU                 /*!< pll source clock select xtal/12    */
N#define SYS_PLL_SEL_XTAL_8M         0x8d9cU                 /*!< pll source clock select xtal/8     */
N
N
N/* system clock define */
N#define SYS_CLK_32M                 0x9abdU                 /*!< system clock select pll 32M hz */
N#define SYS_CLK_16M                 0x3ca2U                 /*!< system clock select pll 16M hz */
N#define SYS_CLK_8M                  0xe78cU                 /*!< system clock select pll 8M hz  */
N#define SYS_CLK_XTAL                0x7c6bU                 /*!< system clock select xtal       */
N
N/* system interrupt define */
N#define SYS_INT_LVDT_ENABLE         SYS_INTEN_LVDT          /*!< lower power detect interrupt enable                    */
N#define SYS_INT_LVDT_DISABLE        0                       /*!< lower power detect interrupt disable                   */
N#define SYS_INT_ETER_ENABLE         SYS_INTEN_ETER          /*!< eeprom ECC error two bits or more interrupt enable     */
N#define SYS_INT_ETER_DISABLE        0                       /*!< eeprom ECC error two bits or more interrupt disable    */
N#define SYS_INT_EOER_ENABLE         SYS_INTEN_EOER          /*!< eeprom ECC error one bit interrupt enable              */
N#define SYS_INT_EOER_DISABLE        0                       /*!< eeprom ECC error one bit interrupt disable             */
N#define SYS_INT_FTER_ENABLE         SYS_INTEN_FTER          /*!< flash ECC error two bits or more interrupt enable      */
N#define SYS_INT_FTER_DISABLE        0                       /*!< flash ECC error two bits or more interrupt disable     */
N#define SYS_INT_FOER_ENABLE         SYS_INTEN_FOER          /*!< flash ECC error one bit interrupt enable               */
N#define SYS_INT_FOER_DISABLE        0                       /*!< flash ECC error one bit interrupt disable              */
N#define SYS_INT_EPOT_ENABLE         SYS_INTEN_EPOT          /*!< eeprom protect range illegal access interrupt enable   */
N#define SYS_INT_EPOT_DISABLE        0                       /*!< eeprom protect range illegal access interrupt disable  */
N#define SYS_INT_FPOT_ENABLE         SYS_INTEN_FPOT          /*!< flash protect range illegal access interrupt enable    */
N#define SYS_INT_FPOT_DISABLE        0                       /*!< flash protect range illegal access interrupt disable   */
N#define SYS_INT_ADJ_ENABLE          SYS_INTEN_ADJ           /*!< config bits error interrupt enable                     */
N#define SYS_INT_ADJ_DISABLE         0                       /*!< config bits error interrupt disable                    */
N#define SYS_INT_OSC_ENABLE          SYS_INTEN_OSC           /*!< XTAL OSC error interrupt enable                        */
N#define SYS_INT_OSC_DISABLE         0                       /*!< XTAL OSC error interrupt disable                       */
N
N/* system interrupt flag define */
N#define SYS_IF_LVDT_MASK            BIT(9)                  /*!< lower power detect interrupt flag mask                 */
N#define SYS_IF_ETER_MASK            BIT(8)                  /*!< eeprom ECC error two bits or more interrupt flag mask  */
N#define SYS_IF_EOER_MASK            BIT(7)                  /*!< eeprom ECC error one bit interrupt flag mask           */
N#define SYS_IF_FTER_MASK            BIT(6)                  /*!< flash ECC error two bits or more interrupt flag mask   */
N#define SYS_IF_FOER_MASK            BIT(5)                  /*!< flash ECC error one bit interrupt flag mask            */
N#define SYS_IF_EPOT_MASK            BIT(4)                  /*!< eeprom protect range illegal access interrupt flag mask*/
N#define SYS_IF_FPOT_MASK            BIT(3)                  /*!< flash protect range illegal access interrupt flag mask */
N#define SYS_IF_ADJ_MASK             BIT(2)                  /*!< config bits error interrupt flag mask                  */
N#define SYS_IF_OSC_MASK             BIT(1)                  /*!< XTAL OSC error interrupt flag mask                     */
N
N/* can clock select define */
N#define CAN_XTAL_CLOCK              0U                      /*!< select xtal as can clock */
N#define CAN_PLL_CLOCK               1U                      /*!< select pll as can clock  */
N
N/* can wakeup flag from sleepdeep mode */
N#define SYS_CAN_SPWKFLAG_CLR        1
N
N/* lvde voltage gear define */
N#define LVDT_GEAR_4P5V              2U                      /*!< lvdt voltage gear 4.5V */
N#define LVDT_GEAR_4P0V              1U                      /*!< lvdt voltage gear 4.0V */
N#define LVDT_GEAR_3P5V              0U                      /*!< lvdt voltage gear 3.5V */
N
N/* lvdt interrupt flag define */
N#define LVDT_IF_BOOST               2U                      /*!< lvdt boost interrupt flag */
N#define LVDT_IF_BUCK                1U                      /*!< lvdt buck interrupt flag */
N
N/* clock output source define */
N#define CLK_OUT_XTAL_DIV_8          3U                      /*!< clock output xtal divide 8         */
N#define CLK_OUT_PLL_DIV_16          2U                      /*!< clock output PLL divide 16         */
N#define CLK_OUT_RC_32K              1U                      /*!< clock output internal rc 32k hz    */
N#define CLK_OUT_RC_250K             0U                      /*!< clock output internal rc 250k hz   */
N
N/* clock2 output source define */
N#define CLK2_OUT_XTAL_DIV_16        0x20U                   /*!< clock2 output xtal divide 16       */
N#define CLK2_OUT_RC_250K            0x10U                   /*!< clock2 output internal rc 250k hz  */
N
N/* function declarations */
N/* sci1 port select */
Nvoid sci1_port_sel(uint8_t port_sel);
N
N/* system clock select */
Nvoid system_clk_sel(uint32_t pll_source_sel,uint32_t clk_sel,uint8_t xtal_freq);
N/* xtal initiliaze */
NErrorStatus xtal_init(void);
N/* enable or disable xtal powerdown in sleepdeep mode */
Nvoid xtal_sleepdeep_pd(FunctionalState pd_en);
N/* enable or disable rc128k powerdown */
Nvoid rc128k_pd(FunctionalState pd_en);
N/* clock out */
Nvoid clock_out(uint8_t clk_source);
N/* clock2 out */
Nvoid clock2_out(uint8_t clk2_source);
N
N
N/* system interrupt vector address offset */
Nvoid system_intvector_offset(uint32_t offset_addr);
N
N/* system interrupt config */
Nvoid system_int_cfg(uint8_t int_state,FunctionalState en_state);
N/* system interrupt flag get */
Nuint16_t system_intflg_get(void);
N/* system interrupt flag clear */
Nvoid system_intflg_clr(uint16_t int_flg);
N
N/* lvdt initialize */
Nvoid lvdt_init(FunctionalState lvdt_en,uint8_t lvdt_vol_gear,FunctionalState int_en);
N/* lvdt enable */
Nvoid lvdt_enable(void);
N/* lvdt disable */
Nvoid lvdt_disable(void);
N/* lvdt interrput flag get */
Nuint8_t lvdt_int_flag_get(void);
N/* lvdt interrput flag clear */
Nvoid lvdt_int_flag_clr(uint8_t int_flag);
N
N/* bor initialize */
Nvoid bor_init(FunctionalState bor_en,FunctionalState filter_en);
N/* bor enable */
Nvoid bor_enbale(void);
N/* bor disable */
Nvoid bor_disable(void);
N/* bor filter 100us enable */
Nvoid bor_filter_enbale(void);
N/* bor filter 100us disable */
Nvoid bor_filter_disable(void);
N
N/* reset pin filter enable or disable */
Nvoid reset_filter(FunctionalState filter_en);
N/* reset flag get */
Nuint16_t rst_flag_get(void);
N/* reset flag clear */
Nvoid rst_flag_clr(uint16_t rst_flag);
N
N/* variable declarations */
Nextern volatile uint8_t xtal_timeout;
N#endif
L 18 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N
N#ifdef BF7x06AMxx_SCI_DRIVER_PRESENT
S    #include "BF7006AMxx_sci.h"
N#endif
N
N#ifdef BF7x06AMxx_CAN_DRIVER_PRESENT
N    #include "BF7006AMxx_can.h"
L 1 ".\RTE\Device\BF7006AM64\BF7006AMxx_can.h" 1
N/*!
N    \file  BF7006AMxx_can.h
N    \brief definitions for the can
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2017-12-27, V1.0.0, firmware for BF7006AMxx
N	2019-11-22, V1.0.2, firmware for BF7006AMxx
N*/
N#ifndef BF7006AMxx_CAN_H
N#define	BF7006AMxx_CAN_H
N
N#include "BF7006AMxx.h"
N
N/* registers definitions */
N#define	CAN_MOD					(REG32(CAN_BASE + 0x00U))		/*!< CAN mode control register */
N#define	CAN_CMR					(REG32(CAN_BASE + 0x04U))		/*!< CAN command control register */
N#define	CAN_SR					(REG32(CAN_BASE + 0x08U))		/*!< CAN status register */
N#define	CAN_IF					(REG32(CAN_BASE + 0x0CU))		/*!< CAN interupt control register */
N#define	CAN_IE					(REG32(CAN_BASE + 0x10U))		/*!< CAN interupt enable register */
N#define	CAN_BTR0				(REG32(CAN_BASE + 0x18U))		/*!< CAN baud rate control register0 */
N#define	CAN_BTR1				(REG32(CAN_BASE + 0x1CU))		/*!< CAN baud rate control register1 */
N#define	CAN_SLPAK				(REG32(CAN_BASE + 0x20U))		/*!< CAN sleep mode acknowledge register */
N#define	CAN_WUP					(REG32(CAN_BASE + 0x24U))		/*!< CAN wake up control register */
N#define	CAN_ALC					(REG32(CAN_BASE + 0x2CU))		/*!< CAN arbitration lost capture register */
N#define	CAN_ECC					(REG32(CAN_BASE + 0x30U))		/*!< CAN error code capture register */
N#define	CAN_EMLR				(REG32(CAN_BASE + 0x34U))		/*!< CAN error alarm count register */
N#define	CAN_RXERR				(REG32(CAN_BASE + 0x38U))		/*!< CAN rx error count register */
N#define	CAN_TXERR				(REG32(CAN_BASE + 0x3CU))		/*!< CAN tx error count register */
N#define	CAN_FRCTL				(REG32(CAN_BASE + 0x40U))		/*!< CAN frame control register */
N#define	CAN_IDAR0				(REG32(CAN_BASE + 0x40U))		/*!< CAN identifier acceptance register0 */
N#define	CAN_IDAR1				(REG32(CAN_BASE + 0x44U))		/*!< CAN identifier acceptance register1 */
N#define	CAN_IDAR2				(REG32(CAN_BASE + 0x48U))		/*!< CAN identifier acceptance register2 */
N#define	CAN_IDAR3				(REG32(CAN_BASE + 0x4CU))		/*!< CAN identifier acceptance register3 */
N#define	CAN_IDMR0				(REG32(CAN_BASE + 0x50U))		/*!< CAN identifier mask register0 */
N#define	CAN_IDMR1				(REG32(CAN_BASE + 0x54U))		/*!< CAN identifier mask register1 */
N#define	CAN_IDMR2				(REG32(CAN_BASE + 0x58U))		/*!< CAN identifier mask register2 */
N#define	CAN_IDMR3				(REG32(CAN_BASE + 0x5CU))		/*!< CAN identifier mask register3 */
N#define	CAN_RMC					(REG32(CAN_BASE + 0x74U))		/*!< CAN rx fifo data count register */
N#define	CAN_ENABLE				(REG32(CAN_BASE + 0x78U))		/*!< CAN enable register */
N#define	CAN_CLRISR				(REG32(CAN_BASE + 0x80U))		/*!< CAN interrupt flag clear register */
N#define	CAN_CLRECC				(REG32(CAN_BASE + 0x84U))		/*!< CAN error code capture status clr register */
N#define	CAN_FILTER_EN			(REG32(CAN_BASE + 0x88U))		/*!< CAN wakeup from sleepdeep filter enable register */
N
N/* can frame id and data regeisters definitions */
N#define	CAN_ID0					(REG32(CAN_BASE + 0x44U))		/*!< CAN identifier register0 */
N#define	CAN_ID1					(REG32(CAN_BASE + 0x48U))		/*!< CAN identifier register1 */
N#define	CAN_ID2					(REG32(CAN_BASE + 0x4CU))		/*!< CAN identifier register2 */
N#define	CAN_ID3					(REG32(CAN_BASE + 0x50U))		/*!< CAN identifier register3 */
N#define	CAN_DATA0				(REG32(CAN_BASE + 0x54U))		/*!< CAN data register0 */
N#define	CAN_DATA1				(REG32(CAN_BASE + 0x58U))		/*!< CAN data register1 */
N#define	CAN_DATA2				(REG32(CAN_BASE + 0x5CU))		/*!< CAN data register2 */
N#define	CAN_DATA3				(REG32(CAN_BASE + 0x60U))		/*!< CAN data register3 */
N#define	CAN_DATA4				(REG32(CAN_BASE + 0x64U))		/*!< CAN data register4 */
N#define	CAN_DATA5				(REG32(CAN_BASE + 0x68U))		/*!< CAN data register5 */
N#define	CAN_DATA6				(REG32(CAN_BASE + 0x6CU))		/*!< CAN data register6 */
N#define	CAN_DATA7				(REG32(CAN_BASE + 0x70U))		/*!< CAN data register7 */
N/* end can frame id and data regeisters definitions */
N
N/* end registers definitions */
N
N/* bits definitions */
N/* CAN_MOD */
N#define	CAN_MOD_AFM				BIT(3)		/*!< filter mode select */
N#define	CAN_MOD_STM				BIT(2)		/*!< self test mode */
N#define	CAN_MOD_LOM				BIT(1)		/*!< listen only mode */
N#define	CAN_MOD_RM				BIT(0)		/*!< reset mode */	
N
N/* CAN_CMR */
N#define CAN_CMR_SPM				BIT(5)		/*!< sleep mode request */	
N#define CAN_CMR_SRR				BIT(4)		/*!< self receive request */	
N#define CAN_CMR_CDO				BIT(3)		/*!< clear data overflow status */	
N#define CAN_CMR_RRB				BIT(2)		/*!< release rx buffer */	
N#define CAN_CMR_AT				BIT(1)		/*!< abort transmit request */	
N#define	CAN_CMR_TR				BIT(0)		/*!< transmit request */	
N
N/* CAN_SR */
N#define	CAN_SR_BS				BIT(7)		/*!< bus off status */
N#define	CAN_SR_ES				BIT(6)		/*!< error status */
N#define	CAN_SR_TS				BIT(5)		/*!< tx status */
N#define	CAN_SR_RS				BIT(4)		/*!< rx status */
N#define	CAN_SR_TCS				BIT(3)		/*!< tx complet status */
N#define	CAN_SR_TBS				BIT(2)		/*!< tx buffer status */
N#define	CAN_SR_DOS				BIT(1)		/*!< data overflow status */
N#define	CAN_SR_RBS				BIT(0)		/*!< rx buffer status */
N
N/* CAN_IF */
N#define	CAN_IF_BEI				BIT(7)		/*!< bus error interrut flag */
N#define	CAN_IF_ALI				BIT(6)		/*!< arbitration lost interrupt flag */
N#define	CAN_IF_EPI				BIT(5)		/*!< error passive interrupt flag */
N#define	CAN_IF_WUPI				BIT(4)		/*!< wake up interrupt flag */
N#define	CAN_IF_DOI				BIT(3)		/*!< data overflow interrupt flag */
N#define	CAN_IF_EI				BIT(2)		/*!< error interrupt or bus state change interrupt flag */
N#define	CAN_IF_TI				BIT(1)		/*!< Tx interrupt flag */
N#define	CAN_IF_RI				BIT(0)		/*!< rx interrupt flag */
N
N/* CAN_IE */
N#define	CAN_IE_BEIE				BIT(7)		/*!< bus error interrupt enable */
N#define	CAN_IE_ALIE				BIT(6)		/*!< arbitration lost interrupt enable */
N#define	CAN_IE_EPIE				BIT(5)		/*!< error passive interrupt enable */
N#define	CAN_IE_WUIE				BIT(4)		/*!< wake up interrupt enable */
N#define	CAN_IE_DOIE				BIT(3)		/*!< data overflow interrupt enable */
N#define	CAN_IE_EIE				BIT(2)		/*!< error interrupt enable */
N#define	CAN_IE_TIE				BIT(1)		/*!< tx interrupt enable */
N#define	CAN_IE_RIE				BIT(0)		/*!< rx interrupt enable */
N
N/* CAN_BTR0 */
N#define	CAN_BTR0_SJW			BITS(6,7)	/*!< synchronlzation jump width */
N#define	CAN_BTR0_SJW_LSB		6U			/*!< lowest bit of CAN_BTR0_SJW */
N#define	CAN_BTR0_BRP			BITS(0,5)	/*!< baud rate prescaler */
N#define	CAN_BTR0_BRP_LSB		0U			/*!< lowest bit of CAN_BTR0_BRP */
N
N
N/* CAN_BTR1 */
N#define	CAN_BTR1_SAM			BIT(7)		/*!< sampling timers */
N#define	CAN_BTR1_SAM_LSB		7U			/*!< lowst bit of CAN_BTR1_SAM */
N#define	CAN_BTR1_TSEG2			BITS(4,6)	/*!< time segment 2 */
N#define	CAN_BTR1_TSEG2_LSB		4U			/*!< lowest bit of CAN_BTR1_TSEG2 */
N#define	CAN_BTR1_TSEG1			BITS(0,3)	/*!< time segment 1 */
N#define	CAN_BTR1_TSEG1_LSB		0U			/*!< lowest bit of CAN_BTR1_TSEG1 */
N
N/* CAN_WUP */
N#define	CAN_WUP_MODE			BIT(1)		/*!< wake up mode select */
N#define	CAN_WUP_ENABLE			BIT(0)		/*!< wake up enable */
N
N/* CAN_ALC */
N#define	CAN_ALC_CODE			BITS(0,4)	/*!< arbitration lost code */
N
N/* CAN_ECC */
N#define	CAN_ECC_MODE			BITS(6,7)	/*!< error mode */
N#define	CAN_ECC_DIR				BIT(5)		/*!< tx or rx error */
N#define	CAN_ECC_CODE			BITS(0,4)	/*!< error campture code */
N
N/* CAN_FRCTL */
N#define	CAN_FRCTL_FF			BIT(7)		/*!< standard or extended flame select */
N#define	CAN_FRCTL_RTR			BIT(6)		/*!< remote or data flame select */
N#define	CAN_FRCTL_DLC			BITS(0,3)	/*!< data lenth */
N#define	CAN_FRCTL_DLC_LSB		0U			/*!< lowest bit of  CAN_FRCTL_DLC*/
N
N/* CAN_CLRISR */
N#define	CAN_CLRISR_BEI			BIT(7)		/*!< clear bus error interrupt flag */
N#define	CAN_CLRISR_ALI			BIT(6)		/*!< clear arbitration lost interrupt flag */
N#define	CAN_CLRISR_EPI			BIT(5)		/*!< clear error passive interrupt flag */
N#define	CAN_CLRISR_WUPI			BIT(4)		/*!< clear wake up interrupt flag */
N#define	CAN_CLRISR_DOI			BIT(3)		/*!< clear data overflow interrupt flag */
N#define	CAN_CLRISR_EI			BIT(2)		/*!< clear error interrupt flag */
N#define	CAN_CLRISR_TI			BIT(1)		/*!< clear tx interrupt flag */
N/* end bits definitions */
N
N/* contact definitions */
N/* can tx interrupt enable and disable define */
N#define CAN_TIE_ENABLE         	BIT(1)      /*!< tx interrupt enable */                
N#define CAN_TIE_DISABLE        	0U           /*!< tx interrupt disable */                
N
N/* can rx interrupt enable and disable define */
N#define CAN_RIE_ENABLE         	BIT(0)      /*!< rx interrupt enable */                
N#define CAN_RIE_DISABLE        	0U           /*!< rx interrupt disable */   		
N
N/* can wake up interrupt enable and disable define */
N#define CAN_WUIE_ENABLE         BIT(4)      /*!< wake up interrupt enable */           
N#define CAN_WUIE_DISABLE        0U           /*!< wake up interrupt disable */           
N
N/* can error interrupt enable and disable define */
N#define CAN_BEIE_ENABLE    		BIT(7)  	/*!< bus error interrupt enable */  
N#define CAN_BEIE_DISABLE    	0U			/*!< bus error interrupt disable */         
N#define CAN_ALIE_ENABLE         BIT(6)      /*!< arbitration lost interrupt enable */  
N#define CAN_ALIE_DISABLE        0U          /*!< arbitration lost interrupt disable */  
N#define CAN_EPIE_ENABLE         BIT(5)      /*!< error passive interrupt enable */
N#define CAN_EPIE_DISABLE        0U          /*!< error passive interrupt disable */     
N#define CAN_DOIE_ENABLE         BIT(3)      /*!< data overflow interrupt enable */    
N#define CAN_DOIE_DISABLE        0U          /*!< data overflow interrupt disable */     
N#define CAN_EIE_ENABLE         	BIT(2)      /*!< error alarm interrupt enable */             
N#define CAN_EIE_DISABLE        	0U          /*!< error alarm interrupt disable */
N#define	CAN_ERR_ALL_ENABLE		(BITS(5U,7U) | BITS(2U,3U))/*!< all error interrupt enable */
N
N/* can nvic interrupt enable and disable define */
N#define	CAN_WU_NVIC_ENABLE		BIT(3)		/*!< wake up nvic interrupt enable */
N#define	CAN_WU_NVIC_DISABLE		0U			/*!< wake up nvic interrupt disable */
N
N#define	CAN_ERR_NVIC_ENABLE		BIT(2)		/*!< error nvic interrupt enable */
N#define	CAN_ERR_NVIC_DISABLE	0U			/*!< error nvic interrupt disable */
N
N#define	CAN_RX_NVIC_ENABLE		BIT(1)		/*!< rx nvic interrupt enable */
N#define	CAN_RX_NVIC_DISABLE		0U			/*!< rx nvic interrupt disable */
N
N#define	CAN_TX_NVIC_ENABLE		BIT(0)		/*!< tx nvic interrupt enable */
N#define	CAN_TX_NVIC_DISABLE		0U			/*!< tx nvic interrupt disable */
N
N/* can bus state define */
N#define	CAN_BUS_ON				0U			/*!< can bus on */
N#define CAN_BUS_OFF				BIT(7)		/*!< can bus off */
N
N
N/* can baud rate prescaler set */
N#define CAN_BTR0_BRP_SET(regval)	((uint8_t)(CAN_BTR0_BRP & ((uint32_t)(regval) << CAN_BTR0_BRP_LSB)))
N
N/* can synchronlzation jump width set */
N#define CAN_BTR0_SJW_SET(regval)	((uint8_t)(CAN_BTR0_SJW & ((uint32_t)(regval) << CAN_BTR0_SJW_LSB)))
N
N/* can time segment 1 set */
N#define CAN_BTR1_TSEG1_SET(regval)	((uint8_t)(CAN_BTR1_TSEG1 & ((uint32_t)(regval) << CAN_BTR1_TSEG1_LSB)))
N
N/* can time segment 2 set */
N#define CAN_BTR1_TSEG2_SET(regval)	((uint8_t)(CAN_BTR1_TSEG2 & ((uint32_t)(regval) << CAN_BTR1_TSEG2_LSB)))
N
N/* can sample timers set */
N#define CAN_BTR1_SAM_SET(regval)	((uint8_t)(CAN_BTR1_SAM & ((uint32_t)(regval) << CAN_BTR1_SAM_LSB)))
N
N/* can data lenth set */
N#define CAN_FRCTL_DLC_SET(regval)	((uint8_t)(CAN_FRCTL_DLC & ((uint32_t)(regval) << CAN_FRCTL_DLC_LSB)))
N
N/* can data register */
N#define	CAN_DATA(x)					(REG32(CAN_BASE + 0x54U + ((x) << 2)))
N
N/* can work mode enum */
Ntypedef enum
N{
N	CAN_NOMARL = 0,
N	CAN_MODE_LISTEN_ONLY,
N	CAN_MODE_SELF_TEST,
N	CAN_MODE_SELF_RECEIVE,
N}can_work_mode_enum;
N
N/* can baud enum */
Ntypedef enum
N{
N	CAN_BAUD_50K = 0,
N	CAN_BAUD_100K,
N	CAN_BAUD_125K,
N	CAN_BAUD_200K,
N	CAN_BAUD_250K,
N	CAN_BAUD_400K,
N	CAN_BAUD_500K,
N	CAN_BAUD_800K,
N	CAN_BAUD_1M
N}can_baud_enum;
N
N/* can module clock enum */
Ntypedef enum
N{
N	CAN_CLK_32M,
N	CAN_CLK_16M,
N	CAN_CLK_8M
N}can_clk_enum;
N
N
N/* can filter mode enum */
Ntypedef enum
N{
N	CAN_DOUBLE_FILTER,		/*!< double filter */
N	CAN_SINGLE_FILTER,		/*!< single filter */
N}CAN_FILTER_MODE;
N
N/* can filter frame enum */
Ntypedef enum
N{
N	CAN_STANDARD_FRAME,		/*!< standard frame */
N	CAN_EXTENDED_FRAME,		/*!< extened frame */
N}CAN_FRAME_FORMAT;
N
N/* can filter RTR enum */
Ntypedef enum
N{
N	CAN_DATA_FRAME,			/*!< data frame */
N	CAN_REMOTE_FRAME,		/*!< remote frame */
N}CAN_FRAME_TYPE;
N
N/* can arbitration lost capture code enum */
Ntypedef enum
N{
N	CAN_ALC_ID_BIT0,
N	CAN_ALC_ID_BIT1,
N	CAN_ALC_ID_BIT2,
N	CAN_ALC_ID_BIT3,
N	CAN_ALC_ID_BIT4,
N	CAN_ALC_ID_BIT5,
N	CAN_ALC_ID_BIT6,
N	CAN_ALC_ID_BIT7,
N	CAN_ALC_ID_BIT8,
N	CAN_ALC_ID_BIT9,
N	CAN_ALC_ID_BIT10,
N	CAN_ALC_SRTR,
N	CAN_ALC_IDE,
N	CAN_ALC_ID_BIT11,
N	CAN_ALC_ID_BIT12,
N	CAN_ALC_ID_BIT13,
N	CAN_ALC_ID_BIT14,
N	CAN_ALC_ID_BIT15,
N	CAN_ALC_ID_BIT16,
N	CAN_ALC_ID_BIT17,
N	CAN_ALC_ID_BIT18,
N	CAN_ALC_ID_BIT19,
N	CAN_ALC_ID_BIT20,
N	CAN_ALC_ID_BIT21,
N	CAN_ALC_ID_BIT22,
N	CAN_ALC_ID_BIT23,
N	CAN_ALC_ID_BIT24,
N	CAN_ALC_ID_BIT25,
N	CAN_ALC_ID_BIT26,
N	CAN_ALC_ID_BIT27,
N	CAN_ALC_ID_BIT28,
N	CAN_ALC_RTR,
N}CAN_ALC_CODE_ENUM;
N
N/* CAN initiliaze parameters struct */
Ntypedef struct
N{
N	can_work_mode_enum 	working_mode;			/*!< can working mode */
N	uint8_t 			resync_jump_width;		/*!< synchronlzation jump width */
N	can_clk_enum 		can_clk;				/*!< can module clock */
N	can_baud_enum		can_baud;				/*!< can baud set */
N	uint8_t 			sampling_times;			/*!< sampling timers */
N	uint8_t 			error_alarm_count;		/*!< error alarm count */
N	uint8_t				int_enable;				/*!< interrupt enable */
N	uint8_t 			nvic_int_enable;		/*!< nvic interrupt enable */
N}can_parameter_struct;
N
N/* CAN filter parameter struct */
Ntypedef struct
N{
N	CAN_FILTER_MODE		filter_mode;			/*!< select filter mode: single mode or double mode */
N	CAN_FRAME_FORMAT	filter_frame;			/*!< select filter standard frame or extended frame */
N	CAN_FRAME_TYPE		filter_RTR;				/*!< select filter frame type */
N	FunctionalState		filter_mask_RTR;		/*!< RTR bit mask */
N	/* single filter cofing */
N	uint32_t 			filter_single_id;		/*!< single filter id */
N	uint8_t				filter_data0;			/*!< data0 filter  */
N	uint8_t 			filter_data1;			/*!< data1 filter  */
N	uint32_t 			filter_mask_single_id;	/*!< single filter mask id */
N	uint8_t				filter_mask_data0;		/*!< data0 filter mask  */
N	uint8_t				filter_mask_data1;		/*!< data1 filter mask  */
N	/* double filter config */
N	uint32_t			filter_double_id0;		/*!< double filter id0 */
N	uint32_t 			filter_double_id1;		/*!< double filter id1 */
N	uint8_t				filter_data0_std;		/*!< double filter data0 in standard frame */
N	uint32_t			filter_mask_double_id0;	/*!< double filter id0 mask */
N	uint32_t 			filter_mask_double_id1;	/*!< double filter id1 mask */
N	uint8_t 			filter_mask_data0_std;	/*!< double filter data0 mask in standard frame */
N
N}can_filter_parameter_struct;
N
N/* CAN transmit message struct */
Ntypedef struct
N{
N    uint32_t 			sfid;                 /*!< standard format frame identifier */
N    uint32_t 			efid;                 /*!< extended format frame identifier */
N    uint8_t 			data[8];              /*!< transmit data */
N    CAN_FRAME_FORMAT 	ff;                   /*!< format of frame, standard or extended format */
N    CAN_FRAME_TYPE 		ft;                   /*!< type of frame, data or remote */
N    uint8_t 			dlen;                 /*!< data length */
N}can_frame_struct;
N
N///* CAN receive message struct */
N//typedef struct
N//{
N//    uint32_t 			sfid;                 /*!< standard format frame identifier */
N//    uint32_t 			rx_efid;                 /*!< extended format frame identifier */
N//    CAN_FRAME_FORMAT 	ff;                   /*!< format of frame, standard or extended format */
N//    CAN_FRAME_TYPE 		rx_ft;                   /*!< type of frame, data or remote */
N//    uint8_t 			rx_dlen;                 /*!< data length */
N//    uint8_t 			rx_data[8];              /*!< receive data */
N//}can_frame_struct;
N
N/* function declarations */
N/* can initialize */
NErrorStatus can_init(can_parameter_struct can_parameter_init,can_filter_parameter_struct can_filter_parameter);
N/* can receive message */
NErrorStatus can_receive_message(can_frame_struct *receive_data);
N/* can transmit message */
NErrorStatus can_transmit_message(can_frame_struct *transmit_data);
N/* can transmit request */
Nvoid can_transmit_request(void);
N/* wait for can transmit complete */
NErrorStatus can_wait_trans(void);
N/* read frame error code */
Nuint8_t can_read_frame_error_code(void);
N/* read arbitration lost code */
Nuint8_t can_read_arbitration_lost_code(void);
N/* can transmit abort */
Nvoid can_transmit_abort(void);
N/* can sleep config */
Nvoid can_sleep_config(uint8_t wakeup_mode,uint8_t filter_en,FunctionalState state);
N/* can sleep request */
NErrorStatus can_sleep_request(void);
N/* can wait transmit frame */
Nvoid can_wait_transmit_frame(can_frame_struct *transmit_data);
N/* get can fifo frame number */
Nuint8_t can_get_fifo_num(void);
N/* get can tx error cnt */
Nuint8_t can_get_txerrcnt(void);
N/* get can rx error cnt */
Nuint8_t can_get_rxerrcnt(void);
N/* reset can module */
Nvoid can_module_rst(void);
N/* can clock select */
Nvoid can_clock_sel(uint8_t can_clock);
N/* can tx buff empty judge */
Nbool is_can_txbuf_empty(void);
N
N/* interrupt function declarations */
N/* can interrupt enable */
Nvoid can_int_enable(uint8_t intstate);
N/* can interrupt disable */
Nvoid can_int_disable(uint8_t intstate);
N/* get can interrupt flag */
Nuint8_t can_interrupt_flag_get(void);
N/* can interrupt flag clear */
Nvoid can_int_flag_clr(uint8_t int_flag);
N/* get can status */
Nuint8_t can_status_get(void);
N
N#endif
L 25 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N#endif
N
N#ifdef BF7x06AMxx_ADC_DRIVER_PRESENT
N    #include "BF7006AMxx_adc.h"
L 1 ".\RTE\Device\BF7006AM64\BF7006AMxx_adc.h" 1
N/*!
N    \file  BF7006AMxx_adc.h
N    \brief definitions for the adc
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N	2019-11-20, V1.0.2, firmware for BF7006AMxx
N*/
N
N#ifndef BF7006AMxx_ADC_H
N#define BF7006AMxx_ADC_H
N
N#include "BF7006AMxx.h"
N
N/* register definitions */
N#define ADC_SC1                 REG32(ADC_BASE + 0x00U)         /*!< adc control register1            */
N#define ADC_SC2                 REG32(ADC_BASE + 0x04U)         /*!< adc count register2              */
N#define ADC_DATA                REG32(ADC_BASE + 0x08U)         /*!< adc data register                */
N#define ADC_CV0                 REG32(ADC_BASE + 0x0cU)         /*!< adc compare value register0      */
N#define ADC_CV1                 REG32(ADC_BASE + 0x10U)         /*!< adc compare value register1      */
N#define ADC_CFG                 REG32(ADC_BASE + 0x14U)         /*!< adc config register              */
N#define ADC_APCTL               REG32(ADC_BASE + 0x18U)         /*!< adc pin analog enable register   */
N#define ADC_SPT                 REG32(ADC_BASE + 0x1cU)         /*!< adc sample clock config register */
N#define ADC_ALC                 REG32(ADC_BASE + 0x20U)         /*!< adc calibration config register  */
N#define ADC_BL5                 REG32(ADC_BASE + 0x24U)         /*!< adc calibration bit5 register    */
N#define ADC_BL6                 REG32(ADC_BASE + 0x28U)         /*!< adc calibration bit6 register    */
N#define ADC_BL7                 REG32(ADC_BASE + 0x2cU)         /*!< adc calibration bit7 register    */
N#define ADC_BL8                 REG32(ADC_BASE + 0x30U)         /*!< adc calibration bit8 register    */
N#define ADC_BL9                 REG32(ADC_BASE + 0x34U)         /*!< adc calibration bit9 register    */
N#define ADC_BL10                REG32(ADC_BASE + 0x38U)         /*!< adc calibration bit10 register   */
N#define ADC_BL11                REG32(ADC_BASE + 0x3cU)         /*!< adc calibration bit11 register   */
N#define ADC_CTEN                REG32(ADC_BASE + 0x40U)
N#define ADC_CTWIDTH             REG32(ADC_BASE + 0x44U)
N#define ADC_CTM8                REG32(ADC_BASE + 0x48U)
N#define ADC_CTM4                REG32(ADC_BASE + 0x4cU)
N#define ADC_CTM2                REG32(ADC_BASE + 0x50U)
N#define ADC_CTL8                REG32(ADC_BASE + 0x54U)
N#define ADC_CTL4                REG32(ADC_BASE + 0x58U)
N#define ADC_CTL2                REG32(ADC_BASE + 0x5cU)
N#define ADC_CTSL8               REG32(ADC_BASE + 0x60U)
N#define ADC_CTSL4               REG32(ADC_BASE + 0x64U)
N#define ADC_CTSL2               REG32(ADC_BASE + 0x68U)
N#define ADC_CTSL1               REG32(ADC_BASE + 0x6cU)
N#define ADC_CTCOMP              REG32(ADC_BASE + 0x70U)
N#define ADC_CTGR                REG32(ADC_BASE + 0x74U)
N#define ADC_CKC                 REG32(ADC_BASE + 0x78U)         /*!< adc timing sequence set register    */
N#define ADC_ISEL                REG32(ADC_BASE + 0x7cU)         /*!< adc bias current select register    */
N#define ADC_PD                  REG32(ADC_BASE + 0x80U)         /*!< adc power down register             */
N#define ADC_TEST                REG32(ADC_BASE + 0x84U)         /*!< adc self test mode register         */
N#define ADC_CALEN               REG32(ADC_BASE + 0x88U)         /*!< adc calibration enable register     */
N#define ADC_IKW                 REG32(ADC_BASE + 0x8cU)         /*!< adc hardware trigge select register */
N#define ADC_FRSEL               REG32(ADC_BASE + 0x90U)         /*!< adc filter select register          */
N#define ADC_CTRLSEL             REG32(ADC_BASE + 0x94U)         /*!< adc compare config register         */
N/* end registers definitions */
N
N/* bits definitions */
N/* ADC_SC1 bits definitions */
N#define ADC_SC1_COCO            BIT(7)                          /*!< adc convert over flag             */
N#define ADC_SC1_AIEN            BIT(6)                          /*!< adc convert over interrupt enable */
N#define ADC_SC1_ADCO            BIT(5)                          /*!< adc continue convert enable       */
N#define ADC_SC1_ADCH            BITS(0,4)                       /*!< adc convert channel select        */
N#define ADC_SC1_ADCH_LSB        0U                              /*!< lowest bit of ADC_SC1_ADCH        */
N
N/* ADC_SC2 bits definitions */
N#define ADC_SC2_ADACT           BIT(7)                          /*!< adc converting flag               */
N#define ADC_SC2_ADTRG           BIT(6)                          /*!< adc convert trigge select         */
N#define ADC_SC2_ACFE0           BIT(5)                          /*!< adc compare0 enable               */
N#define ADC_SC2_ACFGT0          BIT(4)                          /*!< adc compare0 condition select     */
N#define ADC_SC2_ACFE1           BIT(3)                          /*!< adc compare1 enable               */
N#define ADC_SC2_ACFGT1          BIT(2)                          /*!< adc compare1 condition select     */
N#define ADC_SC2_ADHTS           BIT(1)                          /*!< adc hardware trigge source select */
N#define ADC_SC2_CONREN          BIT(0)                          /*!< adc calibration enable            */
N
N/* ADC_CFG bits definitions */
N#define ADC_CFG_ADIV            BITS(4,6)                       /*!< adc clock divide config        */
N#define ADC_CFG_ADIV_LSB        4U                              /*!< LSB of adc clock divide config */
N#define ADC_CFG_MODE            BIT(2)                          /*!< adc convert data width select  */
N
N/* ADC_APCTL bits definitions */
N#define ADC_APCTL_23            BIT(23)                         /*!< adc23 pin analog enable */
N#define ADC_APCTL_22            BIT(22)                         /*!< adc22 pin analog enable */
N#define ADC_APCTL_21            BIT(21)                         /*!< adc21 pin analog enable */
N#define ADC_APCTL_20            BIT(20)                         /*!< adc20 pin analog enable */
N#define ADC_APCTL_19            BIT(19)                         /*!< adc19 pin analog enable */
N#define ADC_APCTL_18            BIT(18)                         /*!< adc18 pin analog enable */
N#define ADC_APCTL_17            BIT(17)                         /*!< adc17 pin analog enable */
N#define ADC_APCTL_16            BIT(16)                         /*!< adc16 pin analog enable */
N#define ADC_APCTL_15            BIT(15)                         /*!< adc15 pin analog enable */
N#define ADC_APCTL_14            BIT(14)                         /*!< adc14 pin analog enable */
N#define ADC_APCTL_13            BIT(13)                         /*!< adc13 pin analog enable */
N#define ADC_APCTL_12            BIT(12)                         /*!< adc12 pin analog enable */
N#define ADC_APCTL_11            BIT(11)                         /*!< adc11 pin analog enable */
N#define ADC_APCTL_10            BIT(10)                         /*!< adc10 pin analog enable */
N#define ADC_APCTL_9             BIT(9)                          /*!< adc9  pin analog enable */
N#define ADC_APCTL_8             BIT(8)                          /*!< adc8  pin analog enable */
N#define ADC_APCTL_7             BIT(7)                          /*!< adc7  pin analog enable */
N#define ADC_APCTL_6             BIT(6)                          /*!< adc6  pin analog enable */
N#define ADC_APCTL_5             BIT(5)                          /*!< adc5  pin analog enable */
N#define ADC_APCTL_4             BIT(4)                          /*!< adc4  pin analog enable */
N#define ADC_APCTL_3             BIT(3)                          /*!< adc3  pin analog enable */
N#define ADC_APCTL_2             BIT(2)                          /*!< adc2  pin analog enable */
N#define ADC_APCTL_1             BIT(1)                          /*!< adc1  pin analog enable */
N#define ADC_APCTL_0             BIT(0)                          /*!< adc0  pin analog enable */
N
N/* ADC_ALC bits definitions */
N#define ADC_ALC_WIDTH           BIT(5)                          /*!< adc calibrate data width select */
N#define ADC_ALC_SEL             BITS(1,4)                       /*!< adc calibrate bit select        */
N#define ADC_ALC_SEL_LSB         1U                              /*!< lowest bit of ADC_ALC_SEL       */
N#define ADC_ALC_EN              BIT(0)                          /*!< adc calibrate enable            */
N
N/* ADC_TEST bits definitions */
N#define ADC_TEST_NUM            BIT(1)                          /*!< adc self test convert number */
N#define ADC_TEST_EN             BIT(0)                          /*!< adc self test mode ebable    */
N/* end bits definitions */
N
N/* contacts definition */
N/* adc data width define */
N#define ADC_DATA_12BITS         0x01U                           /*!< dc data width 12bits */
N#define ADC_DATA_8BITS          0x00U                           /*!< dc data width 8bits  */
N
N/* adc clock divide define,adc_clk m 16M */
N#define ADC_CLK_DIV_1           0x00U                           /*!< adc clock select system clock divide 1  */
N#define ADC_CLK_DIV_2           0x10U                           /*!< adc clock select system clock divide 2  */
N#define ADC_CLK_DIV_3           0x70U                           /*!< adc clock select system clock divide 3  */
N#define ADC_CLK_DIV_4           0x20U                           /*!< adc clock select system clock divide 4  */
N#define ADC_CLK_DIV_6           0x30U                           /*!< adc clock select system clock divide 6  */
N#define ADC_CLK_DIV_8           0x40U                           /*!< adc clock select system clock divide 8  */
N#define ADC_CLK_DIV_10          0x50U                           /*!< adc clock select system clock divide 10 */
N#define ADC_CLK_DIV_12          0x60U                           /*!< adc clock select system clock divide 12 */
N
N/* adc trigger mode define */
N#define ADC_TRIGG_SOFT          0x00U                           /*!< adc trigger mode select software trigger */
N#define ADC_TRIGG_HARD          0x01U                           /*!< adc trigger mode select hardware trigger */
N
N/* adc hardware trigger source select define */
N#define ADC_TRIGG_HARD_NMI      0x01U                           /*!< adc hardware trigger source select NMI interrupt */
N#define ADC_TRIGG_HARD_PWM      0x02U                           /*!< adc hardware trigger source select PWM interrupt */
N#define ADC_TRIGG_HARD_RTC      0x03U                           /*!< adc hardware trigger source select RTC interrupt */
N
N/* adc compare condition define */
N#define ADC_COMP_LESS           0x00U                           /*!< adc compare condition: less than ADC_CV0            */
N#define ADC_COMP_LARGER         0x01U                           /*!< adc compare condition: larger or equal than ADC_CV0 */
N#define ADC_COMP_BETWEEN        0x02U                           /*!< adc compare condition: between ADC_CV0 and ADC_CV1  */
N
N/* adc channel define */
N#define ADC_CH_0(x)             ((uint8_t)(x))                  /*<! adc channel x                         */
N#define ADC_CH_TEMP             26U                             /*<! adc channel internal temperature      */
N#define ADC_CH_BG               27U                             /*!< adc channel internal bandgap (1.267V) */
N#define ADC_CH_VREFH            29U                             /*!< adc channel VREFH                     */
N#define ADC_CH_VREFL            30U                             /*!< adc channel VREFL                     */
N#define ADC_CH_OFF              31U                             /*!< adc channel off, adc stop scan        */
N
N/* adc compare 0 or 1 enum */
Ntypedef enum
N{
N    ADC_COMPARE_0,
N    ADC_COMPARE_1
N}adc_compare_n;
N
N/* ADC trigger parameters struct */
Ntypedef struct
N{
N    uint8_t             trigger_mode;           /*!< adc trigger mode select:hardware or software               */
N    uint8_t             trigger_source;         /*!< adc trigger source select:PWM or RTC or NMI                */
N    uint16_t            pwm_trigger_delay;      /*!< delay between pwm overflow interrupt and start adc convert */
N}adc_trigger_struct;
N
N/* ADC compare function parameters struct */
Ntypedef struct
N{
N    FunctionalState     compare_en;             /*!< adc compare function enable  */
N    uint8_t             compare_condition;      /*!< adc compare condition select */
N    uint16_t            lower_limit_val;        /*!< adc compare lower limit val  */
N    uint16_t            higher_limit_val;       /*!< adc compare higher limit val */
N}adc_compare_struct;
N
N/* ADC initiliaze parameters struct */
Ntypedef struct
N{
N    uint8_t             adc_clk;                /*!< adc clock select:system clock divide(1/2/3/4/6/8/10/12) */
N    uint16_t            sample_clk_num;         /*!< adc sample clock number set,low 10bits valid            */
N    FunctionalState     adco_en;                /*!< adc continuous convert enable                           */
N    uint8_t             data_width;             /*!< adc convert data width select:8bits or 12bits           */
N    uint32_t            channel_en;             /*!< adc channel enale    */
N    FunctionalState     int_en;                 /*!< adc interrupt enable */
N    adc_trigger_struct  trigger;                /*!< adc trigger config   */
N    adc_compare_struct  compare;                /*!< adc compare config   */
N    adc_compare_struct  compare_0;              /*!< adc compare 0 config */
N    adc_compare_struct  compare_1;              /*!< adc compare 1 config */
N}adc_parameter_struct;
N
N/* function declarations */
N/* adc initialize */
Nvoid adc_init(adc_parameter_struct adc_init_para);
N/* adc channel enable */
Nvoid adc_channel_enable(uint32_t ch);
N/* adc channel disable */
Nvoid adc_channel_disable(uint32_t ch);
N/* adc start convert */
Nvoid adc_start_convert(uint8_t ch);
N/* adc convert data get */
Nuint16_t adc_data_get(void);
N/*! wait for adc convert */
NErrorStatus wait_adc_convert(void);
N/* adc interrupt set */
Nvoid adc_interrupt_set(FunctionalState en);
N/* adc power down enable */
Nvoid adc_powerdown(FunctionalState en);
N/* adc compare config */
Nvoid adc_compare_config(adc_compare_struct adc_compare);
N/* adc trigger config */
Nvoid adc_trigger_config(adc_trigger_struct adc_trigger);
N#endif
L 29 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N#endif
N
N#ifdef BF7x06AMxx_EFLASH_DRIVER_PRESENT
N    #include "BF7006AMxx_eflash.h"
L 1 ".\RTE\Device\BF7006AM64\BF7006AMxx_eflash.h" 1
N/*!
N    \file  BF7006AMxx_flash.h
N    \brief definitions for the flash control
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2017-12-27, V1.0.0, firmware for BF7006AMxx
N    2019-11-22, V1.0.2, firmware for BF7006AMxx
N    2021-03-03, V1.0.3, remove EEPROM_NVR operation for operation on EEPROM nvr is not recommanded
N*/
N
N#ifndef BF7006AMxx_EFLASH_H
N#define	BF7006AMxx_EFLASH_H
N
N#include "BF7006AMxx.h"
N#include "BF7006AMxx_wdt.h"
L 1 ".\RTE\Device\BF7006AM64\BF7006AMxx_wdt.h" 1
N/*!
N    \file  BF7006AMxx_wdt.h
N    \brief definitions for the wdt
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2017-12-27, V1.0.0, firmware for BF7006AMxx
N	2019-11-22, V1.0.2, firmware for BF7006AMxx
N*/
N
N#ifndef BF7006AMxx_WDT_H
N#define	BF7006AMxx_WDT_H
N
N#include "BF7006AMxx.h"
N
N/* register definitions */
N#define	WDT_CS					(REG32(WDT_BASE + 0x00U))		/*!< wdt control register */
N#define	WDT_CNT					(REG32(WDT_BASE + 0x04U))		/*!< wdt count register */
N#define	WDT_TOVAL				(REG32(WDT_BASE + 0x08U))		/*!< wdt over flow register */
N#define	WDT_WINVAL				(REG32(WDT_BASE + 0x0cU))		/*!< wdt over flow register in window mode */
N/* end registers definitions */
N
N/* WDT_CS bits definitions */
N#define	WDT_CS_WINEN			BIT(15)						/*!< wdt window mode enable */
N#define	WDT_CS_CLKSEL			BIT(8)						/*!< wdt clock select */
N#define	WDT_CS_EN				BIT(7)						/*!< wdt enable */
N#define	WDT_CS_UPDATA			BIT(5)						/*!< wdt_cs register updata enable */
N#define	WDT_CS_SLEEP			BIT(1)						/*!< wdt enable when in sleeping mode */
N#define	WDT_CS_DEEPSLEEP		BIT(0)						/*!< wdt enable when in deep sleep mode */
N/* end bits definitions */
N
N/* WDT control define */
N/* wdt window mode select */
N#define	WDT_WIN_ENABLE			BIT(15)						/*!< wdt window mode enable */
N#define	WDT_WIN_DISABLE			0U							/*!< wdt window mode disable */
N
N/* wdt clock select */
N#define	WDT_CLOCK_32KHZ			BIT(8)						/*!< wdt clock select 32k HZ */
N#define	WDT_CLOCK_1KHZ			0U							/*!< wdt clock select 1k HZ */
N
N/* wdt enable */
N#define	WDT_ENABLE				BIT(7)						/*!< wdt enable */
N#define	WDT_DISABLE				0U							/*!< wdt disable */
N
N/* wdt updata enable */
N#define	WDT_UPDATA_ENABLE		BIT(5)						/*!< wdt updata enable */
N#define	WDT_UPDATA_DISABLE		0U							/*!< wdt updata disable */
N
N/* wdt enable in sleep mode */
N#define	WDT_SLEEP_ENABLE		BIT(1)						/*!< wdt enable when in sleep mode */
N#define	WDT_SLEEP_DISABLE		0U							/*!< wdt disable when in sleep mode */
N
N/* wdt enable in deep sleep mode */
N#define	WDT_DEEPSLEEP_ENABLE	BIT(0)						/*!< wdt enable when in deep sleep mode */
N#define	WDT_DEEPSLEEP_DISABLE	0U							/*!< wdt disable when in deep sleep mode */
N
N/* function declarations */
N/* wdt clear */
Nvoid wdt_clear(void);
N/* wdt updata */
Nvoid wdt_updata(uint16_t wdt_cs);
N/* wdt config */
Nvoid wdt_config(uint16_t wdt_cs);
N/* wdt overflow count set */
Nvoid wdt_overflow_count(uint16_t wdt_cnt);
N/* wdt overflow count set in window mode */
Nvoid wdt_overflow_count_win(uint16_t wdt_cnt);
N
N#endif
L 19 ".\RTE\Device\BF7006AM64\BF7006AMxx_eflash.h" 2
N#include "BF7006AMxx_sysctrl.h"
N
N/* registers definitions */
N#define EFLASH_SEL                  (REG32(EFLASH_CTRL_BASE + 0x00U))       /*!< flash or eeprom select register            */
N#define EFLASH_MODE                 (REG32(EFLASH_CTRL_BASE + 0x04U))       /*!< flash and eeprom prog/erase mode register  */
N#define EFLASH_EBCFG                (REG32(EFLASH_CTRL_BASE + 0x08U))       /*!< flash and eeprom control register          */
N#define FLASH_STATE                 (REG32(EFLASH_CTRL_BASE + 0x0cU))       /*!< flash prog/erase state register            */
N#define EEPROM_STATE                (REG32(EFLASH_CTRL_BASE + 0x10U))       /*!< eeprom prog/erase state register           */
N
N#define EFLASH_ECC_CTRL             (REG32(EFLASH_CTRL_BASE + 0x200U))      /*!< flash and eeprom ECC error correct enable register */
N#define EFLASH_UNLOCK               (REG32(EFLASH_CTRL_BASE + 0x204U))      /*!< flash and eeprom unlock key register       */
N#define FLASH_LOCK_SIZE             (REG32(EFLASH_CTRL_BASE + 0x208U))      /*!< flash lock size register                   */
N#define EEPROM_LOCK_SIZE            (REG32(EFLASH_CTRL_BASE + 0x20cU))      /*!< eeprom lock size register                  */
N/* end registers definitions */
N
N/* contact define */
N/* flash or eeprom select */
N#define FLASH_SEL                   0xaa55U                                 /*!< select to access flash  */
N#define EEPROM_SEL                  0xcd78U                                 /*!< select to access eeprom */
N
N/* flash and eeprom unlock */
N#define EFLASH_UNLOCK_KEY           0xab23dc54U                             /*!< flash and eeprom unlock key */
N
N
N/* flash define */
N/* flash max address */
N#define FLASH_MAX_ADDR              (FLASH_BASE + 0x17FFFU)                 /*!< flash max address              */
N/* flash sector size */
N#define FLASH_SECTOR_SIZE           0x400U                                  /*!< flash sector size              */
N/* flash sector max number */
N#define FLASH_SECTOR_MAX_NUM        96U                                     /*!< flash max sector number        */
N/* flash prog/erase mode define */
N/* note: when cpu run code in flash to erase flash, CPU must halt when erase flash
N         when cpu run code in SRAM to erase flash,CPU must run when erase flash    */
N#define FLASH_HALT_ENABLE           0xa5U                                   /*!< CPU halt when erase FLASH      */
N#define FLASH_HALT_DISABLE          0x5aU                                   /*!< CPU run when erase FLASH       */
N/* flash prog/erase command define */
N#define FLASH_SECTOR_ERASE          0x55U                                   /*!< flash sector erase             */
N#define FLASH_MASS_ERASE            0xaaU                                   /*!< flash mass erase               */
N#define FLASH_PROG                  0x33U                                   /*!< flash prog                     */
N/* flash operation done state */    
N#define FLASH_STATE_IDLE            0x01U                                   /*!< flash erase or prog done state */
N/* flash lock size */
N#define FLASH_LOCK_UNIT             0x800U                                  /*!< flash lock minimun unit        */
N/* flash lock page number */
N#define FLASH_LOCK_MAX_PAGE         48U                                     /*!< flash lock page max number     */
N
N/* eeprom define */
N/* eeprom max address */
N#define EEPROM_MAX_ADDR             (EEPROM_BASE + 0x7FFU)                  /*!< eeprom max address             */
N/* eeprom sector size */
N#define EEPROM_SECTOR_SIZE          0x40U                                   /*!< eeprom sector size             */
N/* eeprom sector max number */
N#define EEPROM_SECTOR_MAX_NUM       32U                                     /*!< eeprom max sector number       */
N/* eeprom prog/erase mode define */
N#define EEPROM_PROG_ERASE_MODE      0x3cU                                   /*!< eeprom prog/erase mode         */
N/* eeprom prog/erase command define */
N#define EEPROM_SECTOR_ERASE         0x55U                                   /*!< eeprom sector erase            */
N#define EEPROM_MASS_ERASE           0xaaU                                   /*!< eeprom mass erase              */
N#define EEPROM_PROG                 0x33U                                   /*!< eeprom prog                    */
N/* eeprom operation done state */    
N#define EEPROM_STATE_IDLE           0x01U                                   /*!< eeprom erase or prog done state */
N/* eeprom lock unit */
N#define EEPROM_LOCK_UNIT            0x40                                    /*!< eeprom lock minimun unit       */
N/* eeprom lock page number */
N#define EEPROM_LOCK_MAX_PAGE        36U                                     /*!< eeprom lock page max number    */
N
N/* function declarations */
N/* ECC error correction enable */
NErrorStatus ecc_enable(void);
N/* ECC error correction disable */
NErrorStatus ecc_disable(void);
N
N/* flash function declarations */
N/* flash sector erase */
NErrorStatus flash_sector_erase(uint8_t sector_num,bool is_wait_done);
N/* flash n sectors erase */
NErrorStatus flash_Nsectors_erase(uint8_t sector_num,uint8_t len);
N/* flash mass erase */
NErrorStatus flash_mass_erase(bool is_wait_done);
N/* flash word prog */
NErrorStatus flash_prog_word(uint32_t addr,uint32_t data);
N/* flash words prog */
NErrorStatus flash_prog_Nwords(uint32_t addr,uint32_t data[],uint32_t len);
N/* is flash idle */
Nbool is_flash_idle(void);
N/* wait flash prog/erase done */
NErrorStatus wait_flash_prog_erae_done(void);
N/* flash word get */
NErrorStatus flash_word_get(uint32_t addr,uint32_t *red_dat);
N/* flash words get */
NErrorStatus flash_Nwords_get(uint32_t addr,uint32_t *red_dat,uint32_t len);
N/* flash protect set */
Nvoid flash_protect(uint8_t protect_page);
N
N/* eeprom function declarations */
N/* eeprom sector erase */
NErrorStatus eeprom_sector_erase(uint8_t sector_num,bool is_wait_done);
N/* eeprom n sectors erase */
NErrorStatus eeprom_Nsectors_erase(uint8_t sector_num,uint8_t len);
N/* eeprom mass erase */
NErrorStatus eeprom_mass_erase(bool is_wait_done);
N/* eeprom word prog */
NErrorStatus eeprom_prog_word(uint32_t addr,uint32_t data);
N/* eeprom words prog */
NErrorStatus eeprom_prog_Nwords(uint32_t addr,uint32_t data[],uint32_t len);
N/* is eeprom idle */
Nbool is_eeprom_idle(void);
N/* wait eeprom prog/erase done */
NErrorStatus wait_eeprom_prog_erae_done(void);
N/* eeprom word get */
NErrorStatus eeprom_word_get(uint32_t addr,uint32_t *red_dat);
N/* eeprom words get */
NErrorStatus eeprom_Nwords_get(uint32_t addr,uint32_t *red_dat,uint32_t len);
N/* eeprom protect set */
Nvoid eeprom_protect(uint8_t protect_page);
N
N#endif
L 33 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N#endif
N
N#ifdef BF7x06AMxx_WDT_DRIVER_PRESENT
N    #include "BF7006AMxx_wdt.h"
N#endif
N
N#ifdef BF7x06AMxx_TIMER_DRIVER_PRESENT
N    #include "BF7006AMxx_timer.h"
L 1 ".\RTE\Device\BF7006AM64\BF7006AMxx_timer.h" 1
N/*!
N    \file  BF7006AMxx_timer.h
N    \brief definitions for the timer
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2017-12-27, V1.0.0, firmware for BF7006AMxx
N	2019-11-22, V1.0.2, firmware for BF7006AMxx
N*/
N
N#ifndef BF7006AMxx_TIMER_H
N#define	BF7006AMxx_TIMER_H
N
N#include "BF7006AMxx.h"
N
N/* registers definitions */
N#define TIMER_CFG(timerx) 			(REG32((timerx) + 0x00U))		/*!< timer0/1 control register */	
N#define TIMER_MOD(timerx) 			(REG32((timerx) + 0x04U))		/*!< timer0/1 mod count register */	
N#define	TIMER_CNT(timerx)			(REG32((timerx) + 0x08U))		/*!< timer0/1 current count register */
N/* end registers definitions */
N
N/* TIMER_CFG bits definitions */
N#define	TIMER_CFG_IF				BIT(6)						/*!< timer0/1 interrupt flag */
N#define	TIMER_CFG_IE				BIT(5)						/*!< timer0/1 interrupt enable */
N#define	TIMER_CFG_CLK_DIV			BITS(3,4)					/*!< timer0/1 clock divide select */
N#define	TIMER_CFG_CLK_DIV_LSB		3							/*!< LSB of clock divide select */
N#define	TIMER_CFG_CLK_SEL			BIT(2)						/*!< timer0/1 clock select */
N#define	TIMER_CFG_RLD				BIT(1)						/*!< timer0/1 reload select */
N#define	TIMER_CFG_EN				BIT(0)						/*!< timer0/1 enable */
N/* end TIMER_CFG bits definitions */
N
N/* contacts definitions */
N/* timer0/1 interrupt enable */
N#define	TIMER_INT_ENABLE			BIT(5)						/*!< timer0/1 interrupt enable */
N#define	TIMER_INT_DISABLE			0U							/*!< timer0/1 interrupt disable */
N
N/* timer0/1 clock select define */
N#define	TIMER_CLK_32K				0x04U						/*!< timer0/1 clock select as 32K HZ */
N#define	TIMER_CLK_SYS_DIV1			0x00U						/*!< timer0/1 clock select as system clock divide 1*/
N#define	TIMER_CLK_SYS_DIV2			0x08U						/*!< timer0/1 clock select as system clock divide 2*/
N#define	TIMER_CLK_SYS_DIV4			0x10U						/*!< timer0/1 clock select as system clock divide 4*/
N#define	TIMER_CLK_SYS_DIV8			0x18U						/*!< timer0/1 clock select as system clock divide 8*/
N
N/* timer0/1 auto reload select */
N#define	TIMER_AUTO_RLD_ENABLE		BIT(1)						/*!< timer0/1 auto reload enable */
N#define	TIMER_AUTO_RLD_DISABLE		0U							/*!< timer0/1 auto reload disable */
N
N/* timer0/1 enable */
N#define	TIMER_ENABLE				BIT(0)						/*!< timer0/1 enable */
N#define	TIMER_DISABLE				0U							/*!< timer0/1 disable */
N
N/* function declarations */
N/* timer0/1 initialize */
Nvoid timer_init(uint32_t timerx,uint8_t timer_cfg,uint16_t timer_mod);
N/* timer0/1 enable */
Nvoid timer_enable(uint32_t timerx);
N/* timer0/1 disable */
Nvoid timer_disable(uint32_t timerx);
N/* timer0/1 mod count set */
Nvoid timer_mod_set(uint32_t timerx,uint16_t count);
N/* timer0/1 current count get */
Nuint16_t timer_cnt_get(uint32_t timerx);
N
N/* timer0/1 interrupt flag clear */
Nvoid timer_intflag_clr(uint32_t timerx);
N/* timer0/1 interrupt flag get */
NFlagStatus timer_intflag_get(uint32_t timerx);
N
N#endif
L 41 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N#endif
N
N#ifdef BF7x06AMxx_RTC_DRIVER_PRESENT
N    #include "BF7006AMxx_rtc.h"
L 1 ".\RTE\Device\BF7006AM64\BF7006AMxx_rtc.h" 1
N/*!
N    \file  BF7006AMxx_rtc.h
N    \brief definitions for the rtc
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2017-12-27, V1.0.0, firmware for BF7006AMxx
N	2019-11-22, V1.0.2, firmware for BF7006AMxx
N*/
N
N#ifndef	BF7006AMxx_RTC_H
N#define	BF7006AMxx_RTC_H
N
N#include "BF7006AMxx.h"
N#include "BF7006AMxx_sysctrl.h"
N
N/* register definitions */
N#define	RTC_SC					(REG32(RTC_BASE + 0x00U))		/*!< rtc control register */
N#define	RTC_CNT					(REG32(RTC_BASE + 0x04U))		/*!< rtc count register */
N#define	RTC_MOD					(REG32(RTC_BASE + 0x08U))		/*!< rtc mod count register */
N/* end register definitions */
N
N/* bits definition */
N#define	RTC_SC_EN				BIT(9)						/*!< rtc enable */
N#define	RTC_SC_IF				BIT(7)						/*!< rtc interrupt flag */
N#define	RTC_SC_CLK_SEL			BITS(5U,6U)					/*!< rtc clock select */
N#define	RTC_SC_CLK_SEL_LSB		5U							/*!< LSB of rtc clock select */
N#define	RTC_SC_IE				BIT(4)						/*!< rtc interrupt enable */
N/* end bits definition */
N
N/* contacts definition */
N/* rtc enable */
N#define	RTC_ENABLE				BIT(9)						
N#define	RTC_DISABLE				0U
N
N/* rtc clock select */	
N#define	RTC_CLK_SEL_1K			0U							/*!< select rc_1k as rtc clock */
N#define	RTC_CLK_SEL_XTAL_DIV32	(1U << RTC_SC_CLK_SEL_LSB)	/*!< select xtal/32 as rtc clock,if xtal initiliaze fail,change rc_1k as rtc clock */
N#define	RTC_CLK_SEL_32K			(2U << RTC_SC_CLK_SEL_LSB)	/*!< select rc_32k as rtc clock */
N
N/* rtc interrupt enable */
N#define	RTC_INT_ENABLE			BIT(4)
N#define	RTC_INT_DISABLE			0U
N
N/* function declarations */
N/* rtc initialize */
Nvoid rtc_init(uint16_t rtc_sc,uint32_t rtc_mod);
N/* rtc mod count set */
Nvoid rtc_mod_set(uint16_t rtc_mod);
N/* rtc current count get */
Nuint16_t rtc_cnt_get(void);
N/* rtc enable */
Nvoid rtc_enable(void);
N/* rtc disable */
Nvoid rtc_disable(void);
N/* rtc interrupt enable */
Nvoid rtc_int_enable(void);
N/* rtc interrupt disable */
Nvoid rtc_int_disable(void);
N/* rtc interrupt flag get */
NFlagStatus rtc_int_flag_get(void);
N/* rtc interrupt flag clear */
Nvoid rtc_int_flag_clr(void);
N/* rtc clock select */
Nvoid rtc_clk_sel(uint8_t clk_sel);
N
N#endif
L 45 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N#endif
N
N#ifdef BF7x06AMxx_PWM_DRIVER_PRESENT
N    #include "BF7006AMxx_pwm.h"
L 1 ".\RTE\Device\BF7006AM64\BF7006AMxx_pwm.h" 1
N/*!
N    \file  BF7006AMxx_pwm.h
N    \brief definitions for the pwm
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2017-12-27, V1.0.0, firmware for BF7006AMxx
N	2019-11-22, V1.0.2, firmware for BF7006AMxx
N    2021-03-03, V1.0.3, fixed problems which may cause by configuration order of pwm control reg and channel value reg
N                        now configure mod reg first then sc reg
N*/
N
N#ifndef BF7006AMxx_PWM_H
N#define	BF7006AMxx_PWM_H
N
N#include "BF7006AMxx.h"
N
N/* register definitions */
N#define PWM_SC                      (REG32(PWM_BASE + 0x00U))       /*!< pwm control register               */
N#define PWM_CNT                     (REG32(PWM_BASE + 0x04U))       /*!< pwm current count register         */
N#define PWM_MOD                     (REG32(PWM_BASE + 0x08U))       /*!< pwm mod count register             */
N#define PWM_C0SC                    (REG32(PWM_BASE + 0x0cU))       /*!< pwm channel 0 control register     */
N#define PWM_C0V                     (REG32(PWM_BASE + 0x10U))       /*!< pwm channel 0 count register       */
N#define PWM_C1SC                    (REG32(PWM_BASE + 0x14U))       /*!< pwm channel 1 control register     */
N#define PWM_C1V                     (REG32(PWM_BASE + 0x18U))       /*!< pwm channel 1 count register       */
N#define PWM_C2SC                    (REG32(PWM_BASE + 0x1cU))       /*!< pwm channel 2 control register     */
N#define PWM_C2V                     (REG32(PWM_BASE + 0x20U))       /*!< pwm channel 2 count register       */
N#define PWM_C3SC                    (REG32(PWM_BASE + 0x24U))       /*!< pwm channel 3 control register     */
N#define PWM_C3V                     (REG32(PWM_BASE + 0x28U))       /*!< pwm channel 3 count register       */
N#define PWM_C4SC                    (REG32(PWM_BASE + 0x2cU))       /*!< pwm channel 4 control register     */
N#define PWM_C4V                     (REG32(PWM_BASE + 0x30U))       /*!< pwm channel 4 count register       */
N#define PWM_C5SC                    (REG32(PWM_BASE + 0x34U))       /*!< pwm channel 5 control register     */
N#define PWM_C5V                     (REG32(PWM_BASE + 0x38U))       /*!< pwm channel 5 count register       */
N#define PWM_ADC_CV                  (REG32(PWM_BASE + 0x3CU))       /*!< pwm trigg adc scan count register  */
N/* end register definitions */
N
N/* bits definitions */
N/* PWM_SC */
N#define PWM_SC_TOF                  BIT(7)                          /*!< pwm over flow interrupt flag       */
N#define PWM_SC_TOIE                 BIT(6)                          /*!< pwm over flow interrupt enable     */
N#define PWM_SC_CPWMS                BIT(5)                          /*!< pwm count unidirectional or bidirectional select */
N#define PWM_SC_CLK_SEL              BITS(3,4)                       /*!< pwm clock select                   */
N#define PWM_SC_CLK_SEL_LSB          3                               /*!< pwm clock select LSB               */
N#define PWM_SC_CLK_DIV              BITS(0,2)                       /*!< pwm clock divide                   */
N#define PWM_SC_CLK_DIV_LSB          0                               /*!< pwm clock divide LSB               */
N
N/* PWM_CnSC(n=0~5) */
N#define PWM_CnSC_IF                 BIT(7)                          /*!< pwm channel n input or output capture interrupt flag   */
N#define PWM_CnSC_IE                 BIT(6)                          /*!< pwm channel n input or output capture interrupt enable */
N#define PWM_CnSC_MS                 BITS(4,5)                       /*!< pwm channel n mode select          */
N#define PWM_CnSC_MS_LSB             4U                              /*!< pwm channel n mode select LSB      */
N#define PWM_CnSC_ELS                BITS(2,3)                       /*!< pwm channel n edge or level select */
N#define PWM_CnSC_ELS_LSB            2U                              /*!< pwm channel n edge or level select LSB */
N/* end bits definitions */
N
N/* contacts definitions */
N/* pwm interrupt enable */
N#define PWM_INT_ENABLE              BIT(6)                          /*!< pwm interrupt enable   */
N#define PWM_INT_DISABLE             0U                              /*!< pwm interrupt disable  */
N
N/* pwm cpwms set */
N#define PWM_CPWMS_UNIDIR            0U                              /*!< pwm count unidirectional   */
N#define PWM_CPWMS_BIDIR             BIT(5)                          /*!< pwm count bidirectional    */
N
N/* pwm clock select */
N#define PWM_CLK_SEL_SYS             (1U << PWM_SC_CLK_SEL_LSB)      /*!< pwm clock select as system clock       */
N#define PWM_CLK_SEL_EXIN            (3U << PWM_SC_CLK_SEL_LSB)      /*!< pwm clock select as external input pin */
N#define PWM_CLK_SEL_CLOSE           0U                              /*!< pwm clock close                        */
N
N/* pwm clock divide */
N#define PWM_CLK_DIV_1               0U                              /*!< pwm clock divide 1 */
N#define PWM_CLK_DIV_2               1U                              /*!< pwm clock divide 2 */
N#define PWM_CLK_DIV_4               2U                              /*!< pwm clock divide 4 */
N#define PWM_CLK_DIV_8               3U                              /*!< pwm clock divide 8 */
N#define PWM_CLK_DIV_16              4U                              /*!< pwm clock divide 16 */
N#define PWM_CLK_DIV_32              5U                              /*!< pwm clock divide 32 */
N#define PWM_CLK_DIV_64              6U                              /*!< pwm clock divide 64 */
N#define PWM_CLK_DIV_128             7U                              /*!< pwm clock divide 128 */
N
N/* pwm channel n interrupr enable */
N#define PWM_CHn_INT_ENABLE          BIT(6)
N#define PWM_CHn_INT_DISABLE         0U
N
N/* pwm channel n mode select */
N#define PWM_CHn_MS(x)               (PWM_CnSC_MS & ((uint8_t)(x) << PWM_CnSC_MS_LSB))
N
N/* pwm channel n edge or level select */
N#define PWM_CHn_ELS(x)              (PWM_CnSC_ELS & ((uint8_t)(x) << PWM_CnSC_ELS_LSB))
N
N/* function declarations */
N/* pwm initialize */
Nvoid pwm_init(uint8_t pwm_sc,uint16_t pwm_mod);
N/* pwm mod count set */
Nvoid pwm_mod_set(uint16_t mod_count);
N/* pwm current count get */
Nuint16_t pwm_get_count(void);
N/* pwm interrupt flag clear */
Nvoid pwm_tof_clr(void);
N
N/* pwm channel 0 initialize */
Nvoid pwm_ch0_init(uint8_t pwm_ch_sc,uint16_t pwm_ch_cnt);
N/* pwm channel 0 count set */
Nvoid pwm_ch0_cnt_set(uint16_t count);
N/* pwm channel 0 current count get */
Nuint16_t pwm_ch0_get_count(void);
N/* pwm channel 0 interrupt flag clear */
Nvoid pwm_ch0_if_clr(void);
N
N/* pwm channel 1 initialize */
Nvoid pwm_ch1_init(uint8_t pwm_ch_sc,uint16_t pwm_ch_cnt);
N/* pwm channel 1 count set */
Nvoid pwm_ch1_cnt_set(uint16_t count);
N/* pwm channel 1 current count get */
Nuint16_t pwm_ch1_get_count(void);
N/* pwm channel 1 interrupt flag clear */
Nvoid pwm_ch1_if_clr(void);
N
N/* pwm channel 2 initialize */
Nvoid pwm_ch2_init(uint8_t pwm_ch_sc,uint16_t pwm_ch_cnt);
N/* pwm channel 2 count set */
Nvoid pwm_ch2_cnt_set(uint16_t count);
N/* pwm channel 2 current count get */
Nuint16_t pwm_ch2_get_count(void);
N/* pwm channel 2 interrupt flag clear */
Nvoid pwm_ch2_if_clr(void);
N
N/* pwm channel 3 initialize */
Nvoid pwm_ch3_init(uint8_t pwm_ch_sc,uint16_t pwm_ch_cnt);
N/* pwm channel 3 count set */
Nvoid pwm_ch3_cnt_set(uint16_t count);
N/* pwm channel 3 current count get */
Nuint16_t pwm_ch3_get_count(void);
N/* pwm channel 3 interrupt flag clear */
Nvoid pwm_ch3_if_clr(void);
N
N/* pwm channel 4 initialize */
Nvoid pwm_ch4_init(uint8_t pwm_ch_sc,uint16_t pwm_ch_cnt);
N/* pwm channel 4 count set */
Nvoid pwm_ch4_cnt_set(uint16_t count);
N/* pwm channel 4 current count get */
Nuint16_t pwm_ch4_get_count(void);
N/* pwm channel 4 interrupt flag clear */
Nvoid pwm_ch4_if_clr(void);
N
N/* pwm channel 5 initialize */
Nvoid pwm_ch5_init(uint8_t pwm_ch_sc,uint16_t pwm_ch_cnt);
N/* pwm channel 5 count set */
Nvoid pwm_ch5_cnt_set(uint16_t count);
N/* pwm channel 5 current count get */
Nuint16_t pwm_ch5_get_count(void);
N/* pwm channel 5 interrupt flag clear */
Nvoid pwm_ch5_if_clr(void);
N
N
N#endif	
L 49 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N#endif
N
N#ifdef BF7x06AMxx_GPIO_DRIVER_PRESENT
N    #include "BF7006AMxx_gpio.h"
L 1 ".\RTE\Device\BF7006AM64\BF7006AMxx_gpio.h" 1
N/*!
N    \file  BF7006AMxx_gpio.h
N    \brief definitions for the gpio
N*/
N
N/*
N    Copyright (C) 2017 Byd
N
N    2017-12-27, V1.0.0, firmware for BF7006AMxx
N	2019-11-22, V1.0.2, firmware for BF7006AMxx
N*/
N
N#ifndef BF7006AMxx_GPIO_H
N#define	BF7006AMxx_GPIO_H
N
N#include "BF7006AMxx.h"
N
N/* registers definitions */
N#define	GPIO_PTD(gpiox)					(REG32((gpiox) + 0x00U))		/*!< gpio(A/B/C/D/E/F/G) data register */
N#define	GPIO_PTDD(gpiox)				(REG32((gpiox) + 0x04U))		/*!< gpio(A/B/C/D/E/F/G) direction register */
N#define	GPIO_PTPE(gpiox)				(REG32((gpiox) + 0x08U))		/*!< gpio(A/B/C/D/E/F/G) pull up/down enable register */
N#define	GPIO_PTSC(gpiox)				(REG32((gpiox) + 0x10U))		/*!< gpio(A/B/D) control register */
N#define	GPIO_PTPS(gpiox)				(REG32((gpiox) + 0x14U))		/*!< gpio(A/B/D) port interrupt enable register */
N#define	GPIO_PTES(gpiox)				(REG32((gpiox) + 0x18U))		/*!< gpio(A/B/D) port interrupt edge select register */
N#define	GPIOA_INTSTA					(REG32(GPIO_BASE + 0x94U))	/*!< GPIOA interrupt status register */
N#define	GPIOB_INTSTA					(REG32(GPIO_BASE + 0x98U))	/*!< GPIOB interrupt status register */
N#define	GPIOD_INTSTA					(REG32(GPIO_BASE + 0x9CU))	/*!< GPIOD interrupt status register */
N#define	NMISC							(REG32(GPIO_BASE + 0xA0U))	/*!< NMI port control register */
N
N/* bits definitions */
N
N/* GPIO_PTD */
N#define	GPIO_PTD_PTD0					BIT(0)						/*!< port pin 0 data */
N#define	GPIO_PTD_PTD1					BIT(1)						/*!< port pin 1 data */
N#define	GPIO_PTD_PTD2					BIT(2)						/*!< port pin 2 data */
N#define	GPIO_PTD_PTD3					BIT(3)						/*!< port pin 3 data */
N#define	GPIO_PTD_PTD4					BIT(4)						/*!< port pin 4 data */
N#define	GPIO_PTD_PTD5					BIT(5)						/*!< port pin 5 data */
N#define	GPIO_PTD_PTD6					BIT(6)						/*!< port pin 6 data */
N#define	GPIO_PTD_PTD7					BIT(7)						/*!< port pin 7 data */
N
N/* GPIO_PTDD */
N#define	GPIO_PTDD_PTDD0					BIT(0)						/*!< port pin 0 direction */
N#define	GPIO_PTDD_PTDD1					BIT(1)						/*!< port pin 1 direction */
N#define	GPIO_PTDD_PTDD2					BIT(2)						/*!< port pin 2 direction */
N#define	GPIO_PTDD_PTDD3					BIT(3)						/*!< port pin 3 direction */
N#define	GPIO_PTDD_PTDD4					BIT(4)						/*!< port pin 4 direction */
N#define	GPIO_PTDD_PTDD5					BIT(5)						/*!< port pin 5 direction */
N#define	GPIO_PTDD_PTDD6					BIT(6)						/*!< port pin 6 direction */
N#define	GPIO_PTDD_PTDD7					BIT(7)						/*!< port pin 7 direction */
N
N/* GPIO_PTPE */
N#define	GPIO_PTPE_PTPE0					BIT(0)						/*!< port pin 0 pull up enable */
N#define	GPIO_PTPE_PTPE1					BIT(1)						/*!< port pin 1 pull up enable */
N#define	GPIO_PTPE_PTPE2					BIT(2)						/*!< port pin 2 pull up enable */
N#define	GPIO_PTPE_PTPE3					BIT(3)						/*!< port pin 3 pull up enable */
N#define	GPIO_PTPE_PTPE4					BIT(4)						/*!< port pin 4 pull up enable */
N#define	GPIO_PTPE_PTPE5					BIT(5)						/*!< port pin 5 pull up enable */
N#define	GPIO_PTPE_PTPE6					BIT(6)						/*!< port pin 6 pull up enable */
N#define	GPIO_PTPE_PTPE7					BIT(7)						/*!< port pin 7 pull up enable */
N
N/* GPIO_PTSC */
N#define	GPIO_PTSC_TRGMOD				BIT(0)						/*!< port interrupt trigge mode select */
N#define	GPIO_PTSC_IE					BIT(1)						/*!< port interrupt enable */
N#define	GPIO_PTSC_ACK					BIT(2)						/*!< port interrupt acknowledge */
N#define	GPIO_PTSC_IF					BIT(3)						/*!< port interrupt flag */
N
N/* GPIO_PS */
N#define	GPIO_PTPS_PTPS0					BIT(0)						/*!< pin 0 port interrupt function enable */
N#define	GPIO_PTPS_PTPS1					BIT(1)						/*!< pin 1 port interrupt function enable */
N#define	GPIO_PTPS_PTPS2					BIT(2)						/*!< pin 2 port interrupt function enable */
N#define	GPIO_PTPS_PTPS3					BIT(3)						/*!< pin 3 port interrupt function enable */
N#define	GPIO_PTPS_PTPS4					BIT(4)						/*!< pin 4 port interrupt function enable */
N#define	GPIO_PTPS_PTPS5					BIT(5)						/*!< pin 5 port interrupt function enable */
N#define	GPIO_PTPS_PTPS6					BIT(6)						/*!< pin 6 port interrupt function enable */
N#define	GPIO_PTPS_PTPS7					BIT(7)						/*!< pin 7 port interrupt function enable */
N
N/* GPIO_PTES */
N#define	GPIO_PTES_PTES0					BIT(0)						/*!< port pin 0 edge trigge select */
N#define	GPIO_PTES_PTES1					BIT(1)						/*!< port pin 1 edge trigge select */
N#define	GPIO_PTES_PTES2					BIT(2)						/*!< port pin 2 edge trigge select */
N#define	GPIO_PTES_PTES3					BIT(3)						/*!< port pin 3 edge trigge select */
N#define	GPIO_PTES_PTES4					BIT(4)						/*!< port pin 4 edge trigge select */
N#define	GPIO_PTES_PTES5					BIT(5)						/*!< port pin 5 edge trigge select */
N#define	GPIO_PTES_PTES6					BIT(6)						/*!< port pin 6 edge trigge select */
N#define	GPIO_PTES_PTES7					BIT(7)						/*!< port pin 7 edge trigge select */
N
N/* GPIOA_INTSTA */
N#define	GPIOA_INTSTA_PIN0				BIT(0)						/*!< port A pin 0 interrupt state */
N#define	GPIOA_INTSTA_PIN1				BIT(1)						/*!< port A pin 1 interrupt state */
N#define	GPIOA_INTSTA_PIN2				BIT(2)						/*!< port A pin 2 interrupt state */
N#define	GPIOA_INTSTA_PIN3				BIT(3)						/*!< port A pin 3 interrupt state */
N#define	GPIOA_INTSTA_PIN4				BIT(4)						/*!< port A pin 4 interrupt state */
N#define	GPIOA_INTSTA_PIN5				BIT(5)						/*!< port A pin 5 interrupt state */
N#define	GPIOA_INTSTA_PIN6				BIT(6)						/*!< port A pin 6 interrupt state */
N#define	GPIOA_INTSTA_PIN7				BIT(7)						/*!< port A pin 7 interrupt state */
N
N/* GPIOB_INTSTA */
N#define	GPIOB_INTSTA_PIN0				BIT(0)						/*!< port B pin 0 interrupt state */
N#define	GPIOB_INTSTA_PIN1				BIT(1)						/*!< port B pin 1 interrupt state */
N#define	GPIOB_INTSTA_PIN2				BIT(2)						/*!< port B pin 2 interrupt state */
N#define	GPIOB_INTSTA_PIN3				BIT(3)						/*!< port B pin 3 interrupt state */
N#define	GPIOB_INTSTA_PIN4				BIT(4)						/*!< port B pin 4 interrupt state */
N#define	GPIOB_INTSTA_PIN5				BIT(5)						/*!< port B pin 5 interrupt state */
N#define	GPIOB_INTSTA_PIN6				BIT(6)						/*!< port B pin 6 interrupt state */
N#define	GPIOB_INTSTA_PIN7				BIT(7)						/*!< port B pin 7 interrupt state */
N
N/* GPIOD_INTSTA */
N#define	GPIOD_INTSTA_PIN0				BIT(0)						/*!< port D pin 0 interrupt state */
N#define	GPIOD_INTSTA_PIN1				BIT(1)						/*!< port D pin 1 interrupt state */
N#define	GPIOD_INTSTA_PIN2				BIT(2)						/*!< port D pin 2 interrupt state */
N#define	GPIOD_INTSTA_PIN3				BIT(3)						/*!< port D pin 3 interrupt state */
N#define	GPIOD_INTSTA_PIN4				BIT(4)						/*!< port D pin 4 interrupt state */
N#define	GPIOD_INTSTA_PIN5				BIT(5)						/*!< port D pin 5 interrupt state */
N#define	GPIOD_INTSTA_PIN6				BIT(6)						/*!< port D pin 6 interrupt state */
N#define	GPIOD_INTSTA_PIN7				BIT(7)						/*!< port D pin 7 interrupt state */
N
N/* NMISC */
N#define	NMISC_MOD						BIT(0)						/*!< NMI interrupt trigge mode select */
N#define	NMISC_IE						BIT(1)						/*!< NMI interrupt enable */
N#define	NMISC_ACK						BIT(2)						/*!< NMI interrupt acknowledge */
N#define	NMISC_IF						BIT(3)						/*!< NMI interrupt flag */
N#define	NMISC_PE						BIT(4)						/*!< port NMI function enable */
N#define	NMISC_EDG						BIT(5)						/*!< NMI interrupt edge select */
N
N/* GPIO pin definitions */
N#define GPIO_PIN_0                       BIT(0)                    /*!< GPIO pin 0 */
N#define GPIO_PIN_1                       BIT(1)                    /*!< GPIO pin 1 */
N#define GPIO_PIN_2                       BIT(2)                    /*!< GPIO pin 2 */
N#define GPIO_PIN_3                       BIT(3)                    /*!< GPIO pin 3 */
N#define GPIO_PIN_4                       BIT(4)                    /*!< GPIO pin 4 */
N#define GPIO_PIN_5                       BIT(5)                    /*!< GPIO pin 5 */
N#define GPIO_PIN_6                       BIT(6)                    /*!< GPIO pin 6 */
N#define GPIO_PIN_7                       BIT(7)                    /*!< GPIO pin 7 */
N#define GPIO_PIN_ALL                     BITS(0,7)                 /*!< GPIO pin all */
N
N/* GPIO mode definitions */
Ntypedef enum
N{
N	GPIO_MODE_IN_FLOATING,											/*!< floating input mode */
N	GPIO_MODE_IPU,													/*!< pull-up input mode */
N	GPIO_MODE_OUT,													/*!< GPIO output mode */
N}GPIO_MODE;
N
N
N/* GPIO interrupt mode definitions */
Ntypedef enum
N{
N	GPIO_TRG_HIGH,													/*!< gpio trigge mode in rising edge or high level */
N	GPIO_TRG_LOW,													/*!< gpio trigge mode in falling edge or low level */
N	GPIO_TRG_RISING,												/*!< gpio trigge mode in rising edge */		
N	GPIO_TRG_FALLING,												/*!< gpio trigge mode in falling edge */	
N}GPIO_TRG_MODE;
N
N/* NMI trigg mode definitions */
N#define	NMI_TRG_HIGH				0x21							/*!< nmi trigge mode in rising edge or high level */
N#define NMI_TRG_LOW					0x01                            /*!< nmi trigge mode in falling edge or low level */
N#define NMI_TRG_RISING				0x20                            /*!< nmi trigge mode in rising edge */		
N#define NMI_TRG_FALLING				0x00                            /*!< nmi trigge mode in falling edge */	
N
N/* function declarations */
N/* initialize gpio  */
Nvoid gpio_init(uint32_t gpio_periph,GPIO_MODE mode,uint8_t pin);
N/* gpio bit set */
Nvoid gpio_bit_set(uint32_t gpio_periph,uint8_t pin);
N/* gpio bit reset */
Nvoid gpio_bit_reset(uint32_t gpio_periph,uint8_t pin);
N/* write data to the specified GPIO pin */
Nvoid gpio_bit_write(uint32_t gpio_periph,uint8_t pin,FlagStatus bit_value);
N/* gpio port write */
Nvoid gpio_port_write(uint32_t gpio_periph,uint8_t data);
N/* get GPIO pin status */
NFlagStatus gpio_bit_get(uint32_t gpio_periph,uint8_t pin);
N/* get GPIO port status */
Nuint8_t gpio_port_get(uint32_t gpio_periph);
N/* gpio toggle */
Nvoid gpio_toggle(uint32_t gpio_periph,uint8_t pin);
N/* gpio trigge mode set */
NErrorStatus gpio_trigge_mode(uint32_t gpio_periph,GPIO_TRG_MODE trg_mode,uint8_t pin);
N/* gpio trigge interrupt set */
Nvoid gpio_interrupt_set(uint32_t gpio_periph,uint8_t pin,FunctionalState value);
N/* get gpio port interrupt state */
Nuint8_t get_gpio_port_interrupt_state(uint32_t gpio_periph);
N/* get gpio interrupt state */
NFlagStatus get_gpio_interrupt_state(uint32_t gpio_periph,uint8_t pin);
N/* clr gpio interrupt state */
Nvoid clr_gpio_interrupt_state(uint32_t gpio_periph,uint8_t pin);
N/* nmi initialize */
Nvoid nmi_init(uint8_t trigg_mode,FunctionalState state);
N/*  clr nmi interrupt flag */
Nvoid clr_nmi_interrupt_flag(void);
N#endif
L 53 ".\RTE\Startup\BF7006AM64\BF7006AMxx_config.h" 2
N#endif
N
N/* call this function to initialize all selected peripherals */
Nvoid peripherals_config(void);
N
N/* call the following functions to configure single peripheral */
Nvoid adc_config(void);
Nvoid sci_config(void);
Nvoid can_config(void);
Nvoid timer_config(void);
Nvoid pwm_config(void);
Nvoid wdt_cfg(void);
Nvoid rtc_config(void);
Nvoid gpio_config(void);
N
N#endif
L 5 "src\includes.h" 2
N#include "SEGGER_RTT.h"
L 1 ".\RTE\SEGGER\SEGGER_RTT.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER RTT * Real Time Transfer for embedded targets         *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* condition is met:                                                  *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this condition and the following disclaimer.             *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       RTT version: 6.92                                           *
N*                                                                    *
N**********************************************************************
N
N---------------------------END-OF-HEADER------------------------------
NFile    : SEGGER_RTT.h
NPurpose : Implementation of SEGGER real-time transfer which allows
N          real-time communication on targets which support debugger 
N          memory accesses while the CPU is running.
NRevision: $Rev: 20869 $
N----------------------------------------------------------------------
N*/
N
N#ifndef SEGGER_RTT_H
N#define SEGGER_RTT_H
N
N#include "SEGGER_RTT_Conf.h"
L 1 ".\RTE\SEGGER\SEGGER_RTT_Conf.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER RTT * Real Time Transfer for embedded targets         *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* condition is met:                                                  *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this condition and the following disclaimer.             *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       RTT version: 6.92                                           *
N*                                                                    *
N**********************************************************************
N
N---------------------------END-OF-HEADER------------------------------
NFile    : SEGGER_RTT_Conf.h
NPurpose : Implementation of SEGGER real-time transfer (RTT) which
N          allows real-time communication on targets which support
N          debugger memory accesses while the CPU is running.
NRevision: $Rev: 21386 $
N
N*/
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N#ifndef SEGGER_RTT_CONF_H
N#define SEGGER_RTT_CONF_H
N
N#ifdef __IAR_SYSTEMS_ICC__
S  #include <intrinsics.h>
N#endif
N
N/*********************************************************************
N*
N*       Defines, configurable
N*
N**********************************************************************
N*/
N
N//
N// Take in and set to correct values for Cortex-A systems with CPU cache
N//
N//#define SEGGER_RTT_CPU_CACHE_LINE_SIZE            (32)          // Largest cache line size (in bytes) in the current system
N//#define SEGGER_RTT_UNCACHED_OFF                   (0xFB000000)  // Address alias where RTT CB and buffers can be accessed uncached
N//
N// Most common case:
N// Up-channel 0: RTT
N// Up-channel 1: SystemView
N//
N//  <o>Maxium Up Buffers numbers
N#ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
N  #define SEGGER_RTT_MAX_NUM_UP_BUFFERS             (1)     // Max. number of up-buffers (T->H) available on this target    (Default: 3)
N#endif
N//
N// Most common case:
N// Down-channel 0: RTT
N// Down-channel 1: SystemView
N//
N//  <o>Maxium Down Buffers numbers
N#ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
N  #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS           (1)     // Max. number of down-buffers (H->T) available on this target  (Default: 3)
N#endif
N
N//  <o>Up Buffers size(bytes)
N#ifndef   BUFFER_SIZE_UP
N  #define BUFFER_SIZE_UP                            (256)  // Size of the buffer for terminal output of target, up to host (Default: 1k)
N#endif
N
N//  <o>Down Buffers size(bytes)
N#ifndef   BUFFER_SIZE_DOWN
N  #define BUFFER_SIZE_DOWN                          (16)    // Size of the buffer for terminal input to target from host (Usually keyboard input) (Default: 16)
N#endif
N
N//  <o>RTT printf buffer size(bytes)
N#ifndef   SEGGER_RTT_PRINTF_BUFFER_SIZE
N  #define SEGGER_RTT_PRINTF_BUFFER_SIZE             (64u)    // Size of buffer for RTT printf to bulk-send chars via RTT     (Default: 64)
N#endif
N
N//  <o>RTT mode select
N//    <0=>No Block Skip
N//    <1=>No Block trim
N//    <2=>Block if FIFO Full
N#ifndef   SEGGER_RTT_MODE_DEFAULT
N  #define SEGGER_RTT_MODE_DEFAULT                   0 // Mode for pre-initialized terminal channel (buffer 0)
N#endif
N
N/*********************************************************************
N*
N*       RTT memcpy configuration
N*
N*       memcpy() is good for large amounts of data,
N*       but the overhead is big for small amounts, which are usually stored via RTT.
N*       With SEGGER_RTT_MEMCPY_USE_BYTELOOP a simple byte loop can be used instead.
N*
N*       SEGGER_RTT_MEMCPY() can be used to replace standard memcpy() in RTT functions.
N*       This is may be required with memory access restrictions,
N*       such as on Cortex-A devices with MMU.
N*/
N#ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
N  #define SEGGER_RTT_MEMCPY_USE_BYTELOOP              0 // 0: Use memcpy/SEGGER_RTT_MEMCPY, 1: Use a simple byte-loop
N#endif
N//
N// Example definition of SEGGER_RTT_MEMCPY to external memcpy with GCC toolchains and Cortex-A targets
N//
N//#if ((defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__)) && (defined (__ARM_ARCH_7A__))
N//  #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      SEGGER_memcpy((pDest), (pSrc), (NumBytes))
N//#endif
N
N//
N// Target is not allowed to perform other RTT operations while string still has not been stored completely.
N// Otherwise we would probably end up with a mixed string in the buffer.
N// If using  RTT from within interrupts, multiple tasks or multi processors, define the SEGGER_RTT_LOCK() and SEGGER_RTT_UNLOCK() function here.
N//
N// SEGGER_RTT_MAX_INTERRUPT_PRIORITY can be used in the sample lock routines on Cortex-M3/4.
N// Make sure to mask all interrupts which can send RTT data, i.e. generate SystemView events, or cause task switches.
N// When high-priority interrupts must not be masked while sending RTT data, SEGGER_RTT_MAX_INTERRUPT_PRIORITY needs to be adjusted accordingly.
N// (Higher priority = lower priority number)
N// Default value for embOS: 128u
N// Default configuration in FreeRTOS: configMAX_SYSCALL_INTERRUPT_PRIORITY: ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N// In case of doubt mask all interrupts: 1 << (8 - BASEPRI_PRIO_BITS) i.e. 1 << 5 when 3 bits are implemented in NVIC
N// or define SEGGER_RTT_LOCK() to completely disable interrupts.
N//
N#ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
N  #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY         (0x20)   // Interrupt priority to lock on SEGGER_RTT_LOCK on Cortex-M3/4 (Default: 0x20)
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for SEGGER Embedded Studio,
N*       Rowley CrossStudio and GCC
N*/
N#if ((defined(__SES_ARM) || defined(__SES_RISCV) || defined(__CROSSWORKS_ARM) || defined(__GNUC__) || defined(__clang__)) && !defined (__CC_ARM) && !defined(WIN32))
X#if ((0L || 0L || 0L || 1L || 0L) && !1L && !0L)
S  #if (defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_8M_BASE__))
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                    unsigned int _SEGGER_RTT__LockState;                                         \
S                                  __asm volatile ("mrs   %0, primask  \n\t"                         \
S                                                  "movs  r1, #1       \n\t"                         \
S                                                  "msr   primask, r1  \n\t"                         \
S                                                  : "=r" (_SEGGER_RTT__LockState)                                \
S                                                  :                                                 \
S                                                  : "r1", "cc"                                      \
S                                                  );
X    #define SEGGER_RTT_LOCK()   {                                                                                                       unsigned int _SEGGER_RTT__LockState;                                                                           __asm volatile ("mrs   %0, primask  \n\t"                                                                           "movs  r1, #1       \n\t"                                                                           "msr   primask, r1  \n\t"                                                                           : "=r" (_SEGGER_RTT__LockState)                                                                                  :                                                                                                   : "r1", "cc"                                                                                        );
S
S    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   primask, %0  \n\t"                         \
S                                                  :                                                 \
S                                                  : "r" (_SEGGER_RTT__LockState)                                 \
S                                                  :                                                 \
S                                                  );                                                \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   primask, %0  \n\t"                                                                           :                                                                                                   : "r" (_SEGGER_RTT__LockState)                                                                                   :                                                                                                   );                                                                                }
S  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_8M_MAIN__))
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                    unsigned int _SEGGER_RTT__LockState;                                         \
S                                  __asm volatile ("mrs   %0, basepri  \n\t"                         \
S                                                  "mov   r1, %1       \n\t"                         \
S                                                  "msr   basepri, r1  \n\t"                         \
S                                                  : "=r" (_SEGGER_RTT__LockState)                                \
S                                                  : "i"(SEGGER_RTT_MAX_INTERRUPT_PRIORITY)          \
S                                                  : "r1", "cc"                                      \
S                                                  );
X    #define SEGGER_RTT_LOCK()   {                                                                                                       unsigned int _SEGGER_RTT__LockState;                                                                           __asm volatile ("mrs   %0, basepri  \n\t"                                                                           "mov   r1, %1       \n\t"                                                                           "msr   basepri, r1  \n\t"                                                                           : "=r" (_SEGGER_RTT__LockState)                                                                                  : "i"(SEGGER_RTT_MAX_INTERRUPT_PRIORITY)                                                            : "r1", "cc"                                                                                        );
S
S    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   basepri, %0  \n\t"                         \
S                                                  :                                                 \
S                                                  : "r" (_SEGGER_RTT__LockState)                                 \
S                                                  :                                                 \
S                                                  );                                                \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   basepri, %0  \n\t"                                                                           :                                                                                                   : "r" (_SEGGER_RTT__LockState)                                                                                   :                                                                                                   );                                                                                }
S
S  #elif defined(__ARM_ARCH_7A__)
S    #define SEGGER_RTT_LOCK() {                                                \
S                                 unsigned int _SEGGER_RTT__LockState;                       \
S                                 __asm volatile ("mrs r1, CPSR \n\t"           \
S                                                 "mov %0, r1 \n\t"             \
S                                                 "orr r1, r1, #0xC0 \n\t"      \
S                                                 "msr CPSR_c, r1 \n\t"         \
S                                                 : "=r" (_SEGGER_RTT__LockState)            \
S                                                 :                             \
S                                                 : "r1", "cc"                  \
S                                                 );
X    #define SEGGER_RTT_LOCK() {                                                                                 unsigned int _SEGGER_RTT__LockState;                                                        __asm volatile ("mrs r1, CPSR \n\t"                                                            "mov %0, r1 \n\t"                                                              "orr r1, r1, #0xC0 \n\t"                                                       "msr CPSR_c, r1 \n\t"                                                          : "=r" (_SEGGER_RTT__LockState)                                                             :                                                                              : "r1", "cc"                                                                   );
S
S    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"              \
S                                                "mrs r1, CPSR \n\t"            \
S                                                "bic r1, r1, #0xC0 \n\t"       \
S                                                "and r0, r0, #0xC0 \n\t"       \
S                                                "orr r1, r1, r0 \n\t"          \
S                                                "msr CPSR_c, r1 \n\t"          \
S                                                :                              \
S                                                : "r" (_SEGGER_RTT__LockState)              \
S                                                : "r0", "r1", "cc"             \
S                                                );                             \
S                            }
X    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"                                                              "mrs r1, CPSR \n\t"                                                            "bic r1, r1, #0xC0 \n\t"                                                       "and r0, r0, #0xC0 \n\t"                                                       "orr r1, r1, r0 \n\t"                                                          "msr CPSR_c, r1 \n\t"                                                          :                                                                              : "r" (_SEGGER_RTT__LockState)                                                              : "r0", "r1", "cc"                                                             );                                                         }
S  #elif defined(__riscv) || defined(__riscv_xlen)
S    #define SEGGER_RTT_LOCK()  {                                               \
S                                 unsigned int _SEGGER_RTT__LockState;                       \
S                                 __asm volatile ("csrr  %0, mstatus  \n\t"     \
S                                                 "csrci mstatus, 8   \n\t"     \
S                                                 "andi  %0, %0,  8   \n\t"     \
S                                                 : "=r" (_SEGGER_RTT__LockState)            \
S                                                 :                             \
S                                                 :                             \
S                                                );
X    #define SEGGER_RTT_LOCK()  {                                                                                unsigned int _SEGGER_RTT__LockState;                                                        __asm volatile ("csrr  %0, mstatus  \n\t"                                                      "csrci mstatus, 8   \n\t"                                                      "andi  %0, %0,  8   \n\t"                                                      : "=r" (_SEGGER_RTT__LockState)                                                             :                                                                              :                                                                             );
S
S  #define SEGGER_RTT_UNLOCK()    __asm volatile ("csrr  a1, mstatus  \n\t"     \
S                                                 "or    %0, %0, a1   \n\t"     \
S                                                 "csrs  mstatus, %0  \n\t"     \
S                                                 :                             \
S                                                 : "r"  (_SEGGER_RTT__LockState)            \
S                                                 : "a1"                        \
S                                                );                             \
S                               }
X  #define SEGGER_RTT_UNLOCK()    __asm volatile ("csrr  a1, mstatus  \n\t"                                                      "or    %0, %0, a1   \n\t"                                                      "csrs  mstatus, %0  \n\t"                                                      :                                                                              : "r"  (_SEGGER_RTT__LockState)                                                             : "a1"                                                                        );                                                            }
S  #else
S    #define SEGGER_RTT_LOCK()
S    #define SEGGER_RTT_UNLOCK()
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for IAR EWARM
N*/
N#ifdef __ICCARM__
S  #if (defined (__ARM6M__)          && (__CORE__ == __ARM6M__))             ||                      \
S      (defined (__ARM8M_BASELINE__) && (__CORE__ == __ARM8M_BASELINE__))
X  #if (defined (__ARM6M__)          && (__CORE__ == __ARM6M__))             ||                            (defined (__ARM8M_BASELINE__) && (__CORE__ == __ARM8M_BASELINE__))
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int _SEGGER_RTT__LockState;                                           \
S                                  _SEGGER_RTT__LockState = __get_PRIMASK();                                      \
S                                  __set_PRIMASK(1);
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int _SEGGER_RTT__LockState;                                                                             _SEGGER_RTT__LockState = __get_PRIMASK();                                                                        __set_PRIMASK(1);
S
S    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(_SEGGER_RTT__LockState);                                         \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(_SEGGER_RTT__LockState);                                                                         }
S  #elif (defined (__ARM7EM__)         && (__CORE__ == __ARM7EM__))          ||                      \
S        (defined (__ARM7M__)          && (__CORE__ == __ARM7M__))           ||                      \
S        (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))  ||                      \
S        (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))
X  #elif (defined (__ARM7EM__)         && (__CORE__ == __ARM7EM__))          ||                              (defined (__ARM7M__)          && (__CORE__ == __ARM7M__))           ||                              (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))  ||                              (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int _SEGGER_RTT__LockState;                                           \
S                                  _SEGGER_RTT__LockState = __get_BASEPRI();                                      \
S                                  __set_BASEPRI(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int _SEGGER_RTT__LockState;                                                                             _SEGGER_RTT__LockState = __get_BASEPRI();                                                                        __set_BASEPRI(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
S
S    #define SEGGER_RTT_UNLOCK()   __set_BASEPRI(_SEGGER_RTT__LockState);                                         \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __set_BASEPRI(_SEGGER_RTT__LockState);                                                                         }
S  #elif (defined (__ARM7A__) && (__CORE__ == __ARM7A__))                    ||                      \
S        (defined (__ARM7R__) && (__CORE__ == __ARM7R__))
X  #elif (defined (__ARM7A__) && (__CORE__ == __ARM7A__))                    ||                              (defined (__ARM7R__) && (__CORE__ == __ARM7R__))
S    #define SEGGER_RTT_LOCK() {                                                                     \
S                                 unsigned int _SEGGER_RTT__LockState;                                            \
S                                 __asm volatile ("mrs r1, CPSR \n\t"                                \
S                                                 "mov %0, r1 \n\t"                                  \
S                                                 "orr r1, r1, #0xC0 \n\t"                           \
S                                                 "msr CPSR_c, r1 \n\t"                              \
S                                                 : "=r" (_SEGGER_RTT__LockState)                                 \
S                                                 :                                                  \
S                                                 : "r1", "cc"                                       \
S                                                 );
X    #define SEGGER_RTT_LOCK() {                                                                                                      unsigned int _SEGGER_RTT__LockState;                                                                             __asm volatile ("mrs r1, CPSR \n\t"                                                                                 "mov %0, r1 \n\t"                                                                                   "orr r1, r1, #0xC0 \n\t"                                                                            "msr CPSR_c, r1 \n\t"                                                                               : "=r" (_SEGGER_RTT__LockState)                                                                                  :                                                                                                   : "r1", "cc"                                                                                        );
S
S    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"                                   \
S                                                "mrs r1, CPSR \n\t"                                 \
S                                                "bic r1, r1, #0xC0 \n\t"                            \
S                                                "and r0, r0, #0xC0 \n\t"                            \
S                                                "orr r1, r1, r0 \n\t"                               \
S                                                "msr CPSR_c, r1 \n\t"                               \
S                                                :                                                   \
S                                                : "r" (_SEGGER_RTT__LockState)                                   \
S                                                : "r0", "r1", "cc"                                  \
S                                                );                                                  \
S                            }
X    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"                                                                                   "mrs r1, CPSR \n\t"                                                                                 "bic r1, r1, #0xC0 \n\t"                                                                            "and r0, r0, #0xC0 \n\t"                                                                            "orr r1, r1, r0 \n\t"                                                                               "msr CPSR_c, r1 \n\t"                                                                               :                                                                                                   : "r" (_SEGGER_RTT__LockState)                                                                                   : "r0", "r1", "cc"                                                                                  );                                                                              }
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for IAR RX
N*/
N#ifdef __ICCRX__
S  #define SEGGER_RTT_LOCK()   {                                                                     \
S                                unsigned long _SEGGER_RTT__LockState;                                            \
S                                _SEGGER_RTT__LockState = __get_interrupt_state();                                \
S                                __disable_interrupt();
X  #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned long _SEGGER_RTT__LockState;                                                                            _SEGGER_RTT__LockState = __get_interrupt_state();                                                                __disable_interrupt();
S
S  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(_SEGGER_RTT__LockState);                                   \
S                              }
X  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(_SEGGER_RTT__LockState);                                                                 }
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for IAR RL78
N*/
N#ifdef __ICCRL78__
S  #define SEGGER_RTT_LOCK()   {                                                                     \
S                                __istate_t _SEGGER_RTT__LockState;                                               \
S                                _SEGGER_RTT__LockState = __get_interrupt_state();                                \
S                                __disable_interrupt();
X  #define SEGGER_RTT_LOCK()   {                                                                                                     __istate_t _SEGGER_RTT__LockState;                                                                               _SEGGER_RTT__LockState = __get_interrupt_state();                                                                __disable_interrupt();
S
S  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(_SEGGER_RTT__LockState);                                   \
S                              }
X  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(_SEGGER_RTT__LockState);                                                                 }
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for KEIL ARM
N*/
N#ifdef __CC_ARM
N  #if (defined __TARGET_ARCH_6S_M)
X  #if (1L)
N    #define SEGGER_RTT_LOCK()   {                                                                   \
N                                  unsigned int _SEGGER_RTT__LockState;                                           \
N                                  register unsigned char _SEGGER_RTT__PRIMASK __asm( "primask");                 \
N                                  _SEGGER_RTT__LockState = _SEGGER_RTT__PRIMASK;                                              \
N                                  _SEGGER_RTT__PRIMASK = 1u;                                                     \
N                                  __schedule_barrier();
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int _SEGGER_RTT__LockState;                                                                             register unsigned char _SEGGER_RTT__PRIMASK __asm( "primask");                                                   _SEGGER_RTT__LockState = _SEGGER_RTT__PRIMASK;                                                                                _SEGGER_RTT__PRIMASK = 1u;                                                                                       __schedule_barrier();
N
N    #define SEGGER_RTT_UNLOCK()   _SEGGER_RTT__PRIMASK = _SEGGER_RTT__LockState;                                              \
N                                  __schedule_barrier();                                             \
N                                }
X    #define SEGGER_RTT_UNLOCK()   _SEGGER_RTT__PRIMASK = _SEGGER_RTT__LockState;                                                                                __schedule_barrier();                                                                             }
N  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
X  #elif (0L || 0L)
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int _SEGGER_RTT__LockState;                                           \
S                                  register unsigned char BASEPRI __asm( "basepri");                 \
S                                  _SEGGER_RTT__LockState = BASEPRI;                                              \
S                                  BASEPRI = SEGGER_RTT_MAX_INTERRUPT_PRIORITY;                      \
S                                  __schedule_barrier();
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int _SEGGER_RTT__LockState;                                                                             register unsigned char BASEPRI __asm( "basepri");                                                   _SEGGER_RTT__LockState = BASEPRI;                                                                                BASEPRI = SEGGER_RTT_MAX_INTERRUPT_PRIORITY;                                                        __schedule_barrier();
S
S    #define SEGGER_RTT_UNLOCK()   BASEPRI = _SEGGER_RTT__LockState;                                              \
S                                  __schedule_barrier();                                             \
S                                }
X    #define SEGGER_RTT_UNLOCK()   BASEPRI = _SEGGER_RTT__LockState;                                                                                __schedule_barrier();                                                                             }
N  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for TI ARM
N*/
N#ifdef __TI_ARM__
S  #if defined (__TI_ARM_V6M0__)
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int _SEGGER_RTT__LockState;                                           \
S                                  _SEGGER_RTT__LockState = __get_PRIMASK();                                      \
S                                  __set_PRIMASK(1);
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int _SEGGER_RTT__LockState;                                                                             _SEGGER_RTT__LockState = __get_PRIMASK();                                                                        __set_PRIMASK(1);
S
S    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(_SEGGER_RTT__LockState);                                         \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(_SEGGER_RTT__LockState);                                                                         }
S  #elif (defined (__TI_ARM_V7M3__) || defined (__TI_ARM_V7M4__))
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int _SEGGER_RTT__LockState;                                           \
S                                  _SEGGER_RTT__LockState = _set_interrupt_priority(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int _SEGGER_RTT__LockState;                                                                             _SEGGER_RTT__LockState = _set_interrupt_priority(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
S
S    #define SEGGER_RTT_UNLOCK()   _set_interrupt_priority(_SEGGER_RTT__LockState);                               \
S                                }
X    #define SEGGER_RTT_UNLOCK()   _set_interrupt_priority(_SEGGER_RTT__LockState);                                                               }
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for CCRX
N*/
N#ifdef __RX
S  #include <machine.h>
S  #define SEGGER_RTT_LOCK()   {                                                                     \
S                                unsigned long _SEGGER_RTT__LockState;                                            \
S                                _SEGGER_RTT__LockState = get_psw() & 0x010000;                                   \
S                                clrpsw_i();
X  #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned long _SEGGER_RTT__LockState;                                                                            _SEGGER_RTT__LockState = get_psw() & 0x010000;                                                                   clrpsw_i();
S
S  #define SEGGER_RTT_UNLOCK()   set_psw(get_psw() | _SEGGER_RTT__LockState);                                     \
S                              }
X  #define SEGGER_RTT_UNLOCK()   set_psw(get_psw() | _SEGGER_RTT__LockState);                                                                   }
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for embOS Simulation on Windows
N*       (Can also be used for generic RTT locking with embOS)
N*/
N#if defined(WIN32) || defined(SEGGER_RTT_LOCK_EMBOS)
X#if 0L || 0L
S
Svoid OS_SIM_EnterCriticalSection(void);
Svoid OS_SIM_LeaveCriticalSection(void);
S
S#define SEGGER_RTT_LOCK()       {                                                                   \
S                                  OS_SIM_EnterCriticalSection();
X#define SEGGER_RTT_LOCK()       {                                                                                                     OS_SIM_EnterCriticalSection();
S
S#define SEGGER_RTT_UNLOCK()       OS_SIM_LeaveCriticalSection();                                    \
S                                }
X#define SEGGER_RTT_UNLOCK()       OS_SIM_LeaveCriticalSection();                                                                    }
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration fallback
N*/
N#ifndef   SEGGER_RTT_LOCK
S  #define SEGGER_RTT_LOCK()                // Lock RTT (nestable)   (i.e. disable interrupts)
N#endif
N
N#ifndef   SEGGER_RTT_UNLOCK
S  #define SEGGER_RTT_UNLOCK()              // Unlock RTT (nestable) (i.e. enable previous interrupt lock state)
N#endif
N
N#endif
N/*************************** End of file ****************************/
L 62 ".\RTE\SEGGER\SEGGER_RTT.h" 2
N
N/*********************************************************************
N*
N*       Defines, defaults
N*
N**********************************************************************
N*/
N#ifndef RTT_USE_ASM
N  #if (defined __SES_ARM)                       // SEGGER Embedded Studio
X  #if (0L)                       
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
S  #elif (defined __CROSSWORKS_ARM)              // Rowley Crossworks
X  #elif (0L)              
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
N  #elif (defined __ARMCC_VERSION)               // ARM compiler
X  #elif (1L)               
N        #if (__ARMCC_VERSION >= 6000000)        // ARM compiler V6.0 and later is clang based
X        #if (5060960 >= 6000000)        
S      #define _CC_HAS_RTT_ASM_SUPPORT 1
N        #else
N      #define _CC_HAS_RTT_ASM_SUPPORT 0
N        #endif
N  #elif (defined __GNUC__)                      // GCC
X  #elif (1L)                      
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
S  #elif (defined __clang__)                     // Clang compiler
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
S  #elif ((defined __IASMARM__) || (defined __ICCARM__))  // IAR assembler/compiler
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
S  #else
S    #define _CC_HAS_RTT_ASM_SUPPORT 0
N  #endif
N  #if ((defined __IASMARM__) || (defined __ICCARM__))  // IAR assembler/compiler
X  #if ((0L) || (0L))  
S    //
S    // IAR assembler / compiler
S    //
S    #if (__VER__ < 6300000)
S      #define VOLATILE
S    #else
S      #define VOLATILE volatile
S    #endif
S    #if (defined __ARM7M__)                            // Needed for old versions that do not know the define yet
S      #if (__CORE__ == __ARM7M__)                      // Cortex-M3
S        #define _CORE_HAS_RTT_ASM_SUPPORT 1
S      #endif
S    #endif
S    #if (defined __ARM7EM__)                           // Needed for old versions that do not know the define yet
S      #if (__CORE__ == __ARM7EM__)                     // Cortex-M4/M7
S        #define _CORE_HAS_RTT_ASM_SUPPORT 1
S        #define _CORE_NEEDS_DMB 1
S        #define RTT__DMB() asm VOLATILE ("DMB");
S      #endif
S    #endif
S    #if (defined __ARM8M_BASELINE__)                   // Needed for old versions that do not know the define yet
S      #if (__CORE__ == __ARM8M_BASELINE__)             // Cortex-M23
S        #define _CORE_HAS_RTT_ASM_SUPPORT 0
S        #define _CORE_NEEDS_DMB 1
S        #define RTT__DMB() asm VOLATILE ("DMB");
S      #endif
S    #endif
S    #if (defined __ARM8M_MAINLINE__)                   // Needed for old versions that do not know the define yet
S      #if (__CORE__ == __ARM8M_MAINLINE__)             // Cortex-M33
S        #define _CORE_HAS_RTT_ASM_SUPPORT 1
S        #define _CORE_NEEDS_DMB 1
S        #define RTT__DMB() asm VOLATILE ("DMB");
S      #endif
S    #endif
N  #else
N    //
N    // GCC / Clang
N    //
N    #if (defined __ARM_ARCH_7M__)                 // Cortex-M3
X    #if (0L)                 
S      #define _CORE_HAS_RTT_ASM_SUPPORT 1
S    #elif (defined __ARM_ARCH_7EM__)              // Cortex-M4/M7
X    #elif (0L)              
S      #define _CORE_HAS_RTT_ASM_SUPPORT 1
S      #define _CORE_NEEDS_DMB           1
S      #define RTT__DMB() __asm volatile ("dmb\n" : : :);
S    #elif (defined __ARM_ARCH_8M_BASE__)          // Cortex-M23
X    #elif (0L)          
S      #define _CORE_HAS_RTT_ASM_SUPPORT 0
S      #define _CORE_NEEDS_DMB           1
S      #define RTT__DMB() __asm volatile ("dmb\n" : : :);
S    #elif (defined __ARM_ARCH_8M_MAIN__)          // Cortex-M33
X    #elif (0L)          
S      #define _CORE_HAS_RTT_ASM_SUPPORT 1
S      #define _CORE_NEEDS_DMB           1
S      #define RTT__DMB() __asm volatile ("dmb\n" : : :);
N    #else
N      #define _CORE_HAS_RTT_ASM_SUPPORT 0
N    #endif
N  #endif
N  //
N  // If IDE and core support the ASM version, enable ASM version by default
N  //
N  #ifndef _CORE_HAS_RTT_ASM_SUPPORT
S    #define _CORE_HAS_RTT_ASM_SUPPORT 0              // Default for unknown cores
N  #endif
N  #if (_CC_HAS_RTT_ASM_SUPPORT && _CORE_HAS_RTT_ASM_SUPPORT)
X  #if (0 && 0)
S    #define RTT_USE_ASM                           (1)
N  #else
N    #define RTT_USE_ASM                           (0)
N  #endif
N#endif
N
N//
N// We need to know if a DMB is needed to make sure that on Cortex-M7 etc.
N// the order of accesses to the ring buffers is guaranteed
N// Needed for: Cortex-M7, Cortex-M23, Cortex-M33
N//
N#ifndef _CORE_NEEDS_DMB
N  #define _CORE_NEEDS_DMB 0
N#endif
N
N#ifndef RTT__DMB
N  #if _CORE_NEEDS_DMB
X  #if 0
S    #error "Don't know how to place inline assembly for DMB"
N  #else
N    #define RTT__DMB()
N  #endif
N#endif
N
N#ifndef SEGGER_RTT_CPU_CACHE_LINE_SIZE
N  #define SEGGER_RTT_CPU_CACHE_LINE_SIZE (0)   // On most target systems where RTT is used, we do not have a CPU cache, therefore 0 is a good default here
N#endif
N
N#ifndef SEGGER_RTT_UNCACHED_OFF
N  #if SEGGER_RTT_CPU_CACHE_LINE_SIZE
X  #if (0)
S    #error "SEGGER_RTT_UNCACHED_OFF must be defined when setting SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
N  #else
N    #define SEGGER_RTT_UNCACHED_OFF (0)
N  #endif
N#endif
N#if RTT_USE_ASM
X#if (0)
S  #if SEGGER_RTT_CPU_CACHE_LINE_SIZE
S    #error "RTT_USE_ASM is not available if SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
S  #endif
N#endif
N
N#ifndef SEGGER_RTT_ASM  // defined when SEGGER_RTT.h is included from assembly file
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060044
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
X  #elif !0L
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !1L
S#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 0L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 195 ".\RTE\SEGGER\SEGGER_RTT.h" 2
N#include <stdarg.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
N     /* be cooperative with glibc */
N     typedef __CLIBNS va_list __gnuc_va_list;
X     typedef  va_list __gnuc_va_list;
N     #define __GNUC_VA_LIST
N     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 196 ".\RTE\SEGGER\SEGGER_RTT.h" 2
N
N/*********************************************************************
N*
N*       Defines, fixed
N*
N**********************************************************************
N*/
N
N//
N// Determine how much we must pad the control block to make it a multiple of a cache line in size
N// Assuming: U8 = 1B
N//           U16 = 2B
N//           U32 = 4B
N//           U8/U16/U32* = 4B
N//
N#if SEGGER_RTT_CPU_CACHE_LINE_SIZE    // Avoid division by zero in case we do not have any cache
X#if (0)    
S  #define SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(NumBytes) (((NumBytes + SEGGER_RTT_CPU_CACHE_LINE_SIZE - 1) / SEGGER_RTT_CPU_CACHE_LINE_SIZE) * SEGGER_RTT_CPU_CACHE_LINE_SIZE)
N#else
N  #define SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(NumBytes) (NumBytes)
N#endif
N#define SEGGER_RTT__CB_SIZE                              (16 + 4 + 4 + (SEGGER_RTT_MAX_NUM_UP_BUFFERS * 24) + (SEGGER_RTT_MAX_NUM_DOWN_BUFFERS * 24))
N#define SEGGER_RTT__CB_PADDING                           (SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(SEGGER_RTT__CB_SIZE) - SEGGER_RTT__CB_SIZE)
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N
N//
N// Description for a circular buffer (also called "ring buffer")
N// which is used as up-buffer (T->H)
N//
Ntypedef struct {
N  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
N            char*    pBuffer;       // Pointer to start of buffer
N            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
N            unsigned WrOff;         // Position of next item to be written by either target.
N  volatile  unsigned RdOff;         // Position of next item to be read by host. Must be volatile since it may be modified by host.
N            unsigned Flags;         // Contains configuration flags
N} SEGGER_RTT_BUFFER_UP;
N
N//
N// Description for a circular buffer (also called "ring buffer")
N// which is used as down-buffer (H->T)
N//
Ntypedef struct {
N  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
N            char*    pBuffer;       // Pointer to start of buffer
N            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
N  volatile  unsigned WrOff;         // Position of next item to be written by host. Must be volatile since it may be modified by host.
N            unsigned RdOff;         // Position of next item to be read by target (down-buffer).
N            unsigned Flags;         // Contains configuration flags
N} SEGGER_RTT_BUFFER_DOWN;
N
N//
N// RTT control block which describes the number of buffers available
N// as well as the configuration for each buffer
N//
N//
Ntypedef struct {
N  char                    acID[16];                                 // Initialized to "SEGGER RTT"
N  int                     MaxNumUpBuffers;                          // Initialized to SEGGER_RTT_MAX_NUM_UP_BUFFERS (type. 2)
N  int                     MaxNumDownBuffers;                        // Initialized to SEGGER_RTT_MAX_NUM_DOWN_BUFFERS (type. 2)
N  SEGGER_RTT_BUFFER_UP    aUp[SEGGER_RTT_MAX_NUM_UP_BUFFERS];       // Up buffers, transferring information up from target via debug probe to host
X  SEGGER_RTT_BUFFER_UP    aUp[(1)];       
N  SEGGER_RTT_BUFFER_DOWN  aDown[SEGGER_RTT_MAX_NUM_DOWN_BUFFERS];   // Down buffers, transferring information down from host via debug probe to target
X  SEGGER_RTT_BUFFER_DOWN  aDown[(1)];   
N#if SEGGER_RTT__CB_PADDING
X#if (((16 + 4 + 4 + ((1) * 24) + ((1) * 24))) - (16 + 4 + 4 + ((1) * 24) + ((1) * 24)))
S  unsigned char           aDummy[SEGGER_RTT__CB_PADDING];
N#endif
N} SEGGER_RTT_CB;
N
N/*********************************************************************
N*
N*       Global data
N*
N**********************************************************************
N*/
Nextern SEGGER_RTT_CB _SEGGER_RTT;
N
N/*********************************************************************
N*
N*       RTT API functions
N*
N**********************************************************************
N*/
N#ifdef __cplusplus
S  extern "C" {
N#endif
Nint          SEGGER_RTT_AllocDownBuffer         (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_AllocUpBuffer           (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_ConfigUpBuffer          (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_ConfigDownBuffer        (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_GetKey                  (void);
Nunsigned     SEGGER_RTT_HasData                 (unsigned BufferIndex);
Nint          SEGGER_RTT_HasKey                  (void);
Nunsigned     SEGGER_RTT_HasDataUp               (unsigned BufferIndex);
Nvoid         SEGGER_RTT_Init                    (void);
Nunsigned     SEGGER_RTT_Read                    (unsigned BufferIndex,       void* pBuffer, unsigned BufferSize);
Nunsigned     SEGGER_RTT_ReadNoLock              (unsigned BufferIndex,       void* pData,   unsigned BufferSize);
Nint          SEGGER_RTT_SetNameDownBuffer       (unsigned BufferIndex, const char* sName);
Nint          SEGGER_RTT_SetNameUpBuffer         (unsigned BufferIndex, const char* sName);
Nint          SEGGER_RTT_SetFlagsDownBuffer      (unsigned BufferIndex, unsigned Flags);
Nint          SEGGER_RTT_SetFlagsUpBuffer        (unsigned BufferIndex, unsigned Flags);
Nint          SEGGER_RTT_WaitKey                 (void);
Nunsigned     SEGGER_RTT_Write                   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteNoLock             (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteSkipNoLock         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_ASM_WriteSkipNoLock     (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteString             (unsigned BufferIndex, const char* s);
Nvoid         SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_PutChar                 (unsigned BufferIndex, char c);
Nunsigned     SEGGER_RTT_PutCharSkip             (unsigned BufferIndex, char c);
Nunsigned     SEGGER_RTT_PutCharSkipNoLock       (unsigned BufferIndex, char c);
Nunsigned     SEGGER_RTT_GetAvailWriteSpace      (unsigned BufferIndex);
Nunsigned     SEGGER_RTT_GetBytesInBuffer        (unsigned BufferIndex);
N//
N// Function macro for performance optimization
N//
N#define      SEGGER_RTT_HASDATA(n)       (((SEGGER_RTT_BUFFER_DOWN*)((char*)&_SEGGER_RTT.aDown[n] + SEGGER_RTT_UNCACHED_OFF))->WrOff - ((SEGGER_RTT_BUFFER_DOWN*)((char*)&_SEGGER_RTT.aDown[n] + SEGGER_RTT_UNCACHED_OFF))->RdOff)
N
N#if RTT_USE_ASM
X#if (0)
S  #define SEGGER_RTT_WriteSkipNoLock  SEGGER_RTT_ASM_WriteSkipNoLock
N#endif
N
N/*********************************************************************
N*
N*       RTT transfer functions to send RTT data via other channels.
N*
N**********************************************************************
N*/
Nunsigned     SEGGER_RTT_ReadUpBuffer            (unsigned BufferIndex, void* pBuffer, unsigned BufferSize);
Nunsigned     SEGGER_RTT_ReadUpBufferNoLock      (unsigned BufferIndex, void* pData, unsigned BufferSize);
Nunsigned     SEGGER_RTT_WriteDownBuffer         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteDownBufferNoLock   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
N
N#define      SEGGER_RTT_HASDATA_UP(n)    (((SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[n] + SEGGER_RTT_UNCACHED_OFF))->WrOff - ((SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[n] + SEGGER_RTT_UNCACHED_OFF))->RdOff)   // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
N
N/*********************************************************************
N*
N*       RTT "Terminal" API functions
N*
N**********************************************************************
N*/
Nint     SEGGER_RTT_SetTerminal        (unsigned char TerminalId);
Nint     SEGGER_RTT_TerminalOut        (unsigned char TerminalId, const char* s);
Nint     SEGGER_RTT_TerminalPrintf     (unsigned TerminalId, const char * sFormat, ...);
N
N/*********************************************************************
N*
N*       RTT printf functions (require SEGGER_RTT_printf.c)
N*
N**********************************************************************
N*/
Nint SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...);
Nint SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList);
N
N#ifdef __cplusplus
S  }
N#endif
N
N#endif // ifndef(SEGGER_RTT_ASM)
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N
N//
N// Operating modes. Define behavior if buffer is full (not enough space for entire message)
N//
N#define SEGGER_RTT_MODE_NO_BLOCK_SKIP         (0)     // Skip. Do not block, output nothing. (Default)
N#define SEGGER_RTT_MODE_NO_BLOCK_TRIM         (1)     // Trim: Do not block, output as much as fits.
N#define SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL    (2)     // Block: Wait until there is space in the buffer.
N#define SEGGER_RTT_MODE_MASK                  (3)
N
N//
N// Control sequences, based on ANSI.
N// Can be used to control color, and clear the screen
N//
N#define RTT_CTRL_RESET                "\x1B[0m"         // Reset to default colors
N#define RTT_CTRL_CLEAR                "\x1B[2J"         // Clear screen, reposition cursor to top left
N
N#define RTT_CTRL_TEXT_BLACK           "\x1B[2;30m"
N#define RTT_CTRL_TEXT_RED             "\x1B[2;31m"
N#define RTT_CTRL_TEXT_GREEN           "\x1B[2;32m"
N#define RTT_CTRL_TEXT_YELLOW          "\x1B[2;33m"
N#define RTT_CTRL_TEXT_BLUE            "\x1B[2;34m"
N#define RTT_CTRL_TEXT_MAGENTA         "\x1B[2;35m"
N#define RTT_CTRL_TEXT_CYAN            "\x1B[2;36m"
N#define RTT_CTRL_TEXT_WHITE           "\x1B[2;37m"
N
N#define RTT_CTRL_TEXT_BRIGHT_BLACK    "\x1B[1;30m"
N#define RTT_CTRL_TEXT_BRIGHT_RED      "\x1B[1;31m"
N#define RTT_CTRL_TEXT_BRIGHT_GREEN    "\x1B[1;32m"
N#define RTT_CTRL_TEXT_BRIGHT_YELLOW   "\x1B[1;33m"
N#define RTT_CTRL_TEXT_BRIGHT_BLUE     "\x1B[1;34m"
N#define RTT_CTRL_TEXT_BRIGHT_MAGENTA  "\x1B[1;35m"
N#define RTT_CTRL_TEXT_BRIGHT_CYAN     "\x1B[1;36m"
N#define RTT_CTRL_TEXT_BRIGHT_WHITE    "\x1B[1;37m"
N
N#define RTT_CTRL_BG_BLACK             "\x1B[24;40m"
N#define RTT_CTRL_BG_RED               "\x1B[24;41m"
N#define RTT_CTRL_BG_GREEN             "\x1B[24;42m"
N#define RTT_CTRL_BG_YELLOW            "\x1B[24;43m"
N#define RTT_CTRL_BG_BLUE              "\x1B[24;44m"
N#define RTT_CTRL_BG_MAGENTA           "\x1B[24;45m"
N#define RTT_CTRL_BG_CYAN              "\x1B[24;46m"
N#define RTT_CTRL_BG_WHITE             "\x1B[24;47m"
N
N#define RTT_CTRL_BG_BRIGHT_BLACK      "\x1B[4;40m"
N#define RTT_CTRL_BG_BRIGHT_RED        "\x1B[4;41m"
N#define RTT_CTRL_BG_BRIGHT_GREEN      "\x1B[4;42m"
N#define RTT_CTRL_BG_BRIGHT_YELLOW     "\x1B[4;43m"
N#define RTT_CTRL_BG_BRIGHT_BLUE       "\x1B[4;44m"
N#define RTT_CTRL_BG_BRIGHT_MAGENTA    "\x1B[4;45m"
N#define RTT_CTRL_BG_BRIGHT_CYAN       "\x1B[4;46m"
N#define RTT_CTRL_BG_BRIGHT_WHITE      "\x1B[4;47m"
N
N
N#endif
N
N/*************************** End of file ****************************/
L 6 "src\includes.h" 2
N#include "init_section.h"
L 1 "src\init_section.h" 1
N#ifndef __INIT_SECTION_H__
N#define __INIT_SECTION_H__
N
N
Ntypedef void (*init_fn_t)(void);
N
N#define INIT_EXPORT(fn, level)  __attribute__((used)) const init_fn_t __stan_init_##fn  __attribute__((section(".init_fn." level))) = fn
N
N#define EXTERN_FUNC_NAME(fn)  extern const init_fn_t __stan_init_##fn
N
N//
N#define INIT_BOARD_EXPORT(fn)           		INIT_EXPORT(fn, "1") 
N#define INIT_PREV_EXPORT(fn)       					INIT_EXPORT(fn, "2")
N#define INIT_DEVICE_EXPORT(fn)       				INIT_EXPORT(fn, "3")
N
N//,
N#define INIT_COMPONENT_EXPORT(fn)           INIT_EXPORT(fn, "4")
N#define INIT_ENV_EXPORT(fn)           			INIT_EXPORT(fn, "5")
N#define INIT_APP_EXPORT(fn)           			INIT_EXPORT(fn, "6")
N
N#define INIT_APP_LOOP_EXPORT(fn)      			INIT_EXPORT(fn, "7")
N
N
NEXTERN_FUNC_NAME(init_board_start); 
Xextern const init_fn_t __stan_init_init_board_start; 
NEXTERN_FUNC_NAME(init_app_end); 
Xextern const init_fn_t __stan_init_init_app_end; 
N
N
Nextern __inline void auto_loop(void);
Nextern void auto_init(void);
N
N#endif
L 7 "src\includes.h" 2
N
N#define LC_INCLUDE "lc-addrlabels.h"
N#include "pt.h"
L 1 ".\src\pt\pt.h" 1
N/*
N * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the Contiki operating system.
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N * $Id: pt.h,v 1.7 2006/10/02 07:52:56 adam Exp $
N */
N
N/**
N * \addtogroup pt
N * @{
N */
N
N/**
N * \file
N * Protothreads implementation.
N * \author
N * Adam Dunkels <adam@sics.se>
N *
N */
N
N#ifndef __PT_H__
N#define __PT_H__
N
N#include "lc.h"
L 1 ".\src\pt\lc.h" 1
N/*
N * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the protothreads library.
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N * $Id: lc.h,v 1.2 2005/02/24 10:36:59 adam Exp $
N */
N
N/**
N * \addtogroup pt
N * @{
N */
N
N/**
N * \defgroup lc Local continuations
N * @{
N *
N * Local continuations form the basis for implementing protothreads. A
N * local continuation can be <i>set</i> in a specific function to
N * capture the state of the function. After a local continuation has
N * been set can be <i>resumed</i> in order to restore the state of the
N * function at the point where the local continuation was set.
N *
N *
N */
N
N/**
N * \file lc.h
N * Local continuations
N * \author
N * Adam Dunkels <adam@sics.se>
N *
N */
N
N#ifdef DOXYGEN
S    /**
S    * Initialize a local continuation.
S    *
S    * This operation initializes the local continuation, thereby
S    * unsetting any previously set continuation state.
S    *
S    * \hideinitializer
S    */
S    #define LC_INIT(lc)
S
S    /**
S    * Set a local continuation.
S    *
S    * The set operation saves the state of the function at the point
S    * where the operation is executed. As far as the set operation is
S    * concerned, the state of the function does <b>not</b> include the
S    * call-stack or local (automatic) variables, but only the program
S    * counter and such CPU registers that needs to be saved.
S    *
S    * \hideinitializer
S    */
S    #define LC_SET(lc)
S
S    /**
S    * Resume a local continuation.
S    *
S    * The resume operation resumes a previously set local continuation, thus
S    * restoring the state in which the function was when the local
S    * continuation was set. If the local continuation has not been
S    * previously set, the resume operation does nothing.
S    *
S    * \hideinitializer
S    */
S    #define LC_RESUME(lc)
S
S    /**
S    * Mark the end of local continuation usage.
S    *
S    * The end operation signifies that local continuations should not be
S    * used any more in the function. This operation is not needed for
S    * most implementations of local continuation, but is required by a
S    * few implementations.
S    *
S    * \hideinitializer
S    */
S    #define LC_END(lc)
S
S    /**
S    * \var typedef lc_t;
S    *
S    * The local continuation type.
S    *
S    * \hideinitializer
S    */
N#endif /* DOXYGEN */
N
N#ifndef __LC_H__
N    #define __LC_H__
N
N
N    #ifdef LC_INCLUDE
N        #include LC_INCLUDE
X        #include "lc-addrlabels.h"
L 1 ".\src\pt\lc-addrlabels.h" 1
N/*
N * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the Contiki operating system.
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N * $Id: lc-addrlabels.h,v 1.4 2006/06/03 11:29:43 adam Exp $
N */
N
N/**
N * \addtogroup lc
N * @{
N */
N
N/**
N * \file
N * Implementation of local continuations based on the "Labels as
N * values" feature of gcc
N * \author
N * Adam Dunkels <adam@sics.se>
N *
N * This implementation of local continuations is based on a special
N * feature of the GCC C compiler called "labels as values". This
N * feature allows assigning pointers with the address of the code
N * corresponding to a particular C label.
N *
N * For more information, see the GCC documentation:
N * http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html
N *
N */
N
N#ifndef __LC_ADDRLABELS_H__
N#define __LC_ADDRLABELS_H__
N
N/** \hideinitializer */
Ntypedef void *lc_t;
N
N#define LC_INIT(s) s = NULL
N
N#define LC_RESUME(s)                \
N    do {                      \
N        if(s != NULL) {             \
N            goto *s;                  \
N        }                       \
N    } while(0)
X#define LC_RESUME(s)                    do {                              if(s != NULL) {                         goto *s;                          }                           } while(0)
N
N#define LC_CONCAT2(s1, s2) s1##s2
N#define LC_CONCAT(s1, s2) LC_CONCAT2(s1, s2)
N
N#define LC_SET(s)               \
N    do {                      \
N        LC_CONCAT(LC_LABEL, __LINE__):              \
N            (s) = &&LC_CONCAT(LC_LABEL, __LINE__);  \
N    } while(0)
X#define LC_SET(s)                   do {                              LC_CONCAT(LC_LABEL, __LINE__):                          (s) = &&LC_CONCAT(LC_LABEL, __LINE__);      } while(0)
N
N#define LC_END(s)
N
N#endif /* __LC_ADDRLABELS_H__ */
N/** @} */
L 125 ".\src\pt\lc.h" 2
N    #else
S        #include "lc-switch.h"
N    #endif /* LC_INCLUDE */
N
N#endif /* __LC_H__ */
N
N/** @} */
N/** @} */
L 53 ".\src\pt\pt.h" 2
N
Nstruct pt
N{
N    lc_t lc;
N};
N
N#define PT_WAITING 0
N#define PT_YIELDED 1
N#define PT_EXITED  2
N#define PT_ENDED   3
N
N/**
N * \name Initialization
N * @{
N */
N
N/**
N * Initialize a protothread.
N *
N * Initializes a protothread. Initialization must be done prior to
N * starting to execute the protothread.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \sa PT_SPAWN()
N *
N * \hideinitializer
N */
N#define PT_INIT(pt)   LC_INIT((pt)->lc)
N
N/** @} */
N
N/**
N * \name Declaration and definition
N * @{
N */
N
N/**
N * Declaration of a protothread.
N *
N * This macro is used to declare a protothread. All protothreads must
N * be declared with this macro.
N *
N * \param name_args The name and arguments of the C function
N * implementing the protothread.
N *
N * \hideinitializer
N */
N#define PT_THREAD(name_args) char name_args
N
N/**
N * Declare the start of a protothread inside the C function
N * implementing the protothread.
N *
N * This macro is used to declare the starting point of a
N * protothread. It should be placed at the start of the function in
N * which the protothread runs. All C statements above the PT_BEGIN()
N * invokation will be executed each time the protothread is scheduled.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_BEGIN(pt) { char PT_YIELD_FLAG = 1; PT_YIELD_FLAG = PT_YIELD_FLAG; LC_RESUME((pt)->lc)
N#define PT_INFINITE_LOOP_END(pt)  }
N/**
N * Declare the end of a protothread.
N *
N * This macro is used for declaring that a protothread ends. It must
N * always be used together with a matching PT_BEGIN() macro.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_END(pt) LC_END((pt)->lc); PT_YIELD_FLAG = 0; \
N    PT_INIT(pt); return PT_ENDED; }
X#define PT_END(pt) LC_END((pt)->lc); PT_YIELD_FLAG = 0;     PT_INIT(pt); return PT_ENDED; }
N
N/** @} */
N
N/**
N * \name Blocked wait
N * @{
N */
N
N/**
N * Block and wait until condition is true.
N *
N * This macro blocks the protothread until the specified condition is
N * true.
N *
N * \param pt A pointer to the protothread control structure.
N * \param condition The condition.
N *
N * \hideinitializer
N */
N#define PT_WAIT_UNTIL(pt, condition)            \
N    do {                      \
N        LC_SET((pt)->lc);               \
N        if(!(condition)) {              \
N            return PT_WAITING;            \
N        }                       \
N    } while(0)
X#define PT_WAIT_UNTIL(pt, condition)                do {                              LC_SET((pt)->lc);                       if(!(condition)) {                          return PT_WAITING;                    }                           } while(0)
N
N/**
N * Block and wait while condition is true.
N *
N * This function blocks and waits while condition is true. See
N * PT_WAIT_UNTIL().
N *
N * \param pt A pointer to the protothread control structure.
N * \param cond The condition.
N *
N * \hideinitializer
N */
N#define PT_WAIT_WHILE(pt, cond)  PT_WAIT_UNTIL((pt), !(cond))
N
N/** @} */
N
N/**
N * \name Hierarchical protothreads
N * @{
N */
N
N/**
N * Block and wait until a child protothread completes.
N *
N * This macro schedules a child protothread. The current protothread
N * will block until the child protothread completes.
N *
N * \note The child protothread must be manually initialized with the
N * PT_INIT() function before this function is used.
N *
N * \param pt A pointer to the protothread control structure.
N * \param thread The child protothread with arguments
N *
N * \sa PT_SPAWN()
N *
N * \hideinitializer
N */
N#define PT_WAIT_THREAD(pt, thread) PT_WAIT_WHILE((pt), PT_SCHEDULE(thread))
N
N/**
N * Spawn a child protothread and wait until it exits.
N *
N * This macro spawns a child protothread and waits until it exits. The
N * macro can only be used within a protothread.
N *
N * \param pt A pointer to the protothread control structure.
N * \param child A pointer to the child protothread's control structure.
N * \param thread The child protothread with arguments
N *
N * \hideinitializer
N */
N#define PT_SPAWN(pt, child, thread)     \
N    do {                      \
N        PT_INIT((child));               \
N        PT_WAIT_THREAD((pt), (thread));     \
N    } while(0)
X#define PT_SPAWN(pt, child, thread)         do {                              PT_INIT((child));                       PT_WAIT_THREAD((pt), (thread));         } while(0)
N
N/** @} */
N
N/**
N * \name Exiting and restarting
N * @{
N */
N
N/**
N * Restart the protothread.
N *
N * This macro will block and cause the running protothread to restart
N * its execution at the place of the PT_BEGIN() call.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_RESTART(pt)              \
N    do {                      \
N        PT_INIT(pt);                \
N        return PT_WAITING;          \
N    } while(0)
X#define PT_RESTART(pt)                  do {                              PT_INIT(pt);                        return PT_WAITING;              } while(0)
N
N/**
N * Exit the protothread.
N *
N * This macro causes the protothread to exit. If the protothread was
N * spawned by another protothread, the parent protothread will become
N * unblocked and can continue to run.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_EXIT(pt)             \
N    do {                      \
N        PT_INIT(pt);                \
N        return PT_EXITED;           \
N    } while(0)
X#define PT_EXIT(pt)                 do {                              PT_INIT(pt);                        return PT_EXITED;               } while(0)
N
N/** @} */
N
N/**
N * \name Calling a protothread
N * @{
N */
N
N/**
N * Schedule a protothread.
N *
N * This function shedules a protothread. The return value of the
N * function is non-zero if the protothread is running or zero if the
N * protothread has exited.
N *
N * \param f The call to the C function implementing the protothread to
N * be scheduled
N *
N * \hideinitializer
N */
N#define PT_SCHEDULE(f) ((f) < PT_EXITED)
N
N/** @} */
N
N/**
N * \name Yielding from a protothread
N * @{
N */
N
N/**
N * Yield from the current protothread.
N *
N * This function will yield the protothread, thereby allowing other
N * processing to take place in the system.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_YIELD(pt)                \
N    do {                      \
N        PT_YIELD_FLAG = 0;              \
N        LC_SET((pt)->lc);               \
N        if(PT_YIELD_FLAG == 0) {            \
N            return PT_YIELDED;            \
N        }                       \
N    } while(0)
X#define PT_YIELD(pt)                    do {                              PT_YIELD_FLAG = 0;                      LC_SET((pt)->lc);                       if(PT_YIELD_FLAG == 0) {                        return PT_YIELDED;                    }                           } while(0)
N
N/**
N * \brief      Yield from the protothread until a condition occurs.
N * \param pt   A pointer to the protothread control structure.
N * \param cond The condition.
N *
N *             This function will yield the protothread, until the
N *             specified condition evaluates to true.
N *
N *
N * \hideinitializer
N */
N#define PT_YIELD_UNTIL(pt, cond)        \
N    do {                      \
N        PT_YIELD_FLAG = 0;              \
N        LC_SET((pt)->lc);               \
N        if((PT_YIELD_FLAG == 0) || !(cond)) {   \
N            return PT_YIELDED;            \
N        }                       \
N    } while(0)
X#define PT_YIELD_UNTIL(pt, cond)            do {                              PT_YIELD_FLAG = 0;                      LC_SET((pt)->lc);                       if((PT_YIELD_FLAG == 0) || !(cond)) {               return PT_YIELDED;                    }                           } while(0)
N
N/** @} */
N
N#endif /* __PT_H__ */
N
N/** @} */
L 10 "src\includes.h" 2
N
N#define PT_DELAY_MS(pt, ms)                             \
N    {                                                     \
N        time = systick_ms + (ms);                           \
N        PT_WAIT_UNTIL(pt, ((int)(systick_ms - time) >= 0)); \
N    }
X#define PT_DELAY_MS(pt, ms)                                 {                                                             time = systick_ms + (ms);                                   PT_WAIT_UNTIL(pt, ((int)(systick_ms - time) >= 0));     }
N
N#define PT_LOOP(pt)    \
N    do                   \
N    {                    \
N        LC_SET((pt)->lc);  \
N        return PT_WAITING; \
N    } while (0)
X#define PT_LOOP(pt)        do                       {                            LC_SET((pt)->lc);          return PT_WAITING;     } while (0)
N
N#include "config.h"
L 1 "src\config.h" 1
N#ifndef __CONFIF_H__
N#define __CONFIF_H__
N
N#include "OrderConfig.h"
L 1 "src\OrderConfig.h" 1
N#ifndef __ORDER_CONFIF_H__
N#define __ORDER_CONFIF_H__
N
N#include "defs.h"
L 1 "src\defs.h" 1
N#ifndef __DEFS_H__
N#define __DEFS_H__
N
N
N//
N#define TYPE_RES_10K    10000 //
N#define TYPE_RES    		1000 //
N#define	TYPE_VOL    		0  //
N
N#endif
L 5 "src\OrderConfig.h" 2
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N#define NORMAL_QRWD  		100001   //  B40 
N#define NORMAL_VOL  		100002   //  B40 
N#define NORMAL_RES 			100003   //   1K B40 
N#define NORMAL_RES_10K 	100004   //   10K B40 
N#define NORMAL_QRWD_vol 100005   //  B40 
N
N/***************************************************************************************************/
N// <c1> 
N// <i> 
N//#define DEBUG
N// </c>
N
N//6A4ONACC
N// <c1> 
N// <i> 
N//#define  PROTECTION_MAX_RETRY_COUNT_RESET   
N// </c>
N
N//<s>
N// <i> 6
N#include "220801.h" 
L 1 ".\config\220801.h" 1
N
N#include "../src/defs.h"
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N/***************************************************************************************************/
N//<o> 
N// <i> 
N// <100001-999999>
N#define ORDER_VERSION  220801
N
N//<c1> PWM
N// <i> 0x6FXPWM
N//#define PWMTIME_SET_ENABLE
N//</c>
N
N
N//<c1> 
N// <i> 
N//#define CURRENT_SEND  
N//</c>
N
N#undef PLUSE
N//<o> 
N// <i>  999
N// <0000-9999>
N#define PLUSE 4800
N
N
N//<o>A25 
N// <i> 
N// <0=> 
N// <1000=> 
N// <10000=> 10K
N#define SENSE_SER1_P25_SET  1000
N
N//<o>A40 
N// <i> 
N// <0=> 
N// <1000=> 
N// <10000=> 10K
N#define SENSE_SER2_P40_SET  1000
N
N//<e>
N// <i>
N#define SUPPORT_WIPER 1
N
N//<c1> CAN
N// <i> , 0x06A4byte7.bit21,1A1A9
N//#define WIPER_DISABLE_BY_CAN  
N//</c>
N//</e>
N
N//<e>
N#define NORMAL_OUT 1
N#if NORMAL_OUT > 0
X#if 1 > 0
N	//<e>1
N	//<s>1
N	//<i>A05 A07 A42
N	#define NORMAL_MOD1 1
N	#if NORMAL_MOD1 > 0
X	#if 1 > 0
N		#define NORMOL_OUTS_MOD1 "A07 A12"
N	#endif
N	//</e>
N
N	//<e>2
N	//<s>2
N	//<i>A05 A07 A42
N	#define NORMAL_MOD2 0
N	#if NORMAL_MOD2 > 0
X	#if 0 > 0
S		#define NORMOL_OUTS_MOD2 ""
N	#endif
N	//</e>
N
N	//<e>3
N	//<s>3
N	//<i>A05 A07 A42
N	#define NORMAL_MOD3 0
N	#if NORMAL_MOD3 > 0
X	#if 0 > 0
S		#define NORMOL_OUTS_MOD3 ""
N	#endif
N	//</e>
N	
N	//<e>42
N	//<s>42
N	//<i>A05 A07 A42
N	#define NORMAL_MOD4 0
N	#if NORMAL_MOD4 > 0
X	#if 0 > 0
S		#define NORMOL_OUTS_MOD4 ""
N	#endif
N	//</e>
N#endif
N//</e>
N
N//<e>
N#define SELF_CONTROL 1
N#if SELF_CONTROL > 0
X#if 1 > 0
N//<h> 
N	//<c> 1
N	//#define MOD1_SW_DATA
N	//</c>
N	//<c> 2
N	//#define MOD2_SW_DATA
N	//</c>
N	//<c> 3
N	#define MOD3_SW_DATA
N	//</c>
N	//<c> 4
N	//#define MOD4_SW_DATA
N	//</c>
N//</h>
N
N//<h>
N	//<e>1
N	//<s>1
N	//<i>A05 A07 A42
N	#define LOGIC_MOD1 0
N	#if LOGIC_MOD1 > 0
X	#if 0 > 0
S		#define LOGIC_OUTS_MOD1 "A05 A07 A42"
N	#endif
N	//</e>
N
N	//<e>2
N	//<s>2
N	//<i>A05 A07 A42
N	#define LOGIC_MOD2 0
N	#if LOGIC_MOD2 > 0
X	#if 0 > 0
S		#define LOGIC_OUTS_MOD2 "A05 A07 A42"
N	#endif
N	//</e>
N
N	//<e>3
N	//<s>3
N	//<i>A05 A07 A42
N	#define LOGIC_MOD3 1
N	#if LOGIC_MOD3 > 0
X	#if 1 > 0
N		#define LOGIC_OUTS_MOD3 "A02 A13"
N	#endif
N	//</e>
N	
N	//<e>42
N	//<s>42
N	//<i>A05 A07 A42
N	#define LOGIC_MOD4 0
N	#if LOGIC_MOD4 > 0
X	#if 0 > 0
S		#define LOGIC_OUTS_MOD4 "A05 A07 A42"
N	#endif
N	//</e>
N//</h>
N
N//<h> 
N//<i> 
N//<o> 
N// <i> door control logic enable
N// <0=> 1
N// <1=> 2
N// <2=> 3
N// <4=> 4
N// <5=> 220801
N#define LOGIC_S  5
N
N#if LOGIC_S == 0
X#if 5 == 0
S#define LOGIC
S#elif  LOGIC_S == 1
X#elif  5 == 1
S#define LOGIC1
S#elif  LOGIC_S == 2
X#elif  5 == 2
S#define LOGIC2
S#elif  LOGIC_S == 4
X#elif  5 == 4
S#define LOGIC4
N#elif  LOGIC_S == 5
X#elif  5 == 5
N#define LOGIC5
N#endif
N
N//<c1> 3 A1A8825
N// <i> 
N//#define LOGIC3
N//</c>
N//</h>
N
N#ifdef LOGIC5
N	#define KEY_SOS_ENABLE
N#endif
N
N#endif
N//</e>
N
N
N//*** <<< end of configuration section >>>    ***
N
L 29 "src\OrderConfig.h" 2
N//#include "config_experiment.h" 
N
N
N//../config
N
N//*** <<< end of configuration section >>>    ***
N
N#endif
N
L 5 "src\config.h" 2
N
N/***************************************************************************************************/
N//
N//#define DEBUG //
N
N#ifdef DEBUG
S		//#define ADC_DEBUG
S    //#define PLUSE_TEST
S		//#define PLUSE_DEBUG
S    //#define RAIN_TEST
S    #define MAIN_TEST //
S		//#define TEMP_TEST
N#endif
N
N
N/***************************************************************************************************/
N//B40 6.0  2.41
N//PTC7 
N//PTF4  
N//PTF3 
N//PTD1 
N#define B40V60
N
N//B40 6.0 6143D, B40V60  
N#define B40V60_BTS6143D
N
N
N/********************************************4*******************************************************/
N#if defined MOD4_HF  // 
X#if 0L  
S	#define MOD4
S	#define MOD4_BYTE_START  2
S#elif defined MOD4_CD  // 
X#elif 0L  
S	#define MOD4
S	#define MOD4_BYTE_START  0
N#endif
N
N/***************************************************************************************************/
N#define OC_THRESHOLD2					180     //50085
N#define OC_THRESHOLD  				150  		//0.1A
N#define OC_TIME_THRESHOLD_MS  5000   	// ms
N
N#define SC_TIME_THRESHOLD_MS  500   	// ms
N
N/*********************************************************************************************************/
N//0x6A4data[6]&0x40
N//==0x00PA9
N//==0x40
N
N#if SUPPORT_WIPER == 1
X#if 1 == 1
N	#define WIPER_OUTS "A01 A09"  //
N	#define WIPER_AT_RESET()  (ADD1_IN() == 0)   //1
N	
N	#ifndef  WIPER_DISABLE_BY_CAN 
N	#define WIPER_DISABLE 0
N	#else
S	#undef WIPER_DISABLE
N	#endif
N#endif
N
N/*********************************************************************************************************/
N//#if (defined LOGIC_OUTS_MOD1) || (defined LOGIC_OUTS_MOD2) || (defined LOGIC_OUTS_MOD3) || ((defined MOD4) && (defined LOGIC_OUTS_MOD4))
N//	#if (!defined LOGIC) && (!defined LOGIC1) && (!defined LOGIC2) && (!defined LOGIC4) && (!defined LOGIC5)
N//		#error "mast defined LOGICX!"
N//	#endif
N//#endif
N
N/*********************************************************************************************************/
N//TYPE_RESTYPE_VOL
N//B40 V6.0 
N//
N
N
N
N#endif
N
L 25 "src\includes.h" 2
N
N
Nextern volatile uint32_t systick_ms;
Nextern uint8_t mod_addr;
Nextern uint8_t mod_addr_s0;
N
N#define ADDR1_MOD   1  //
N#define ADDR2_MOD   2  //
N#define ADDR3_MOD   3  //
N#define ADDR4_MOD   4  //
N
N#define MOD_ADDR 	mod_addr //
N#define MOD_ADDR_S0 	mod_addr_s0 //
N
N
N#define ID_BOOTLOADER   0X0526
N#define ID_FW_UPDATE    0x06B0
N#define ID_TX_TEST      0x0610
N		
N#define ID_FRT_PRO      0x0550
N#define ID_REAR_PRO     0x0551
N#define ID_TOP_PRO      0x0552
N
N#define ID_TX_SW        0x0680
N#define ID_TX_AD        0x0670
N#define ID_TX_AD_ALL    0x0690
N#define ID_TX_ST        0x0560
N#define ID_TX_MILE      0x0450
N
N#define ID_TX_CURRENT   0X0690
N
N#define ID_RX_PWM       0x06E4
N#define ID_RX_DASH      0x06A4
N#define ID_RX_SET       0x0610
N#define ID_ADD_DASH     0x06B4
N#define ID_PWMTIME_SET  0x06F0
N
N#endif
L 5 "src\rain.h" 2
N#include "power_out.h"
L 1 "src\power_out.h" 1
N#ifndef __POWER_ON_H__
N#define __POWER_ON_H__
N
N#include "includes.h"
N
Ntypedef enum
N{
N    PS_Off = 0,
N    PS_Start,
N    PS_On,
N    PS_Err,
N		PS_Idle
N} PoutStatus;
N
Ntypedef struct
N{
N    char name[8];
N    uint32_t gpio_periph;
N    uint32_t magic; //shift = 23
N	
N    uint32_t time;
N	
N    uint32_t oc_time;
N    uint16_t oct_threshold;
N	
N    uint32_t sc_time;
N    uint16_t sct_threshold;
N
N    uint16_t cur_100ma;
N    uint16_t oc_threshold;
N    uint16_t sc_threshold; 
N
N    uint8_t pin;
N    uint8_t adc_ch;
N
N    uint8_t cmd;
N    uint8_t diag;
N    uint8_t rt_diag; //
N    PoutStatus status;
N    uint8_t errcount;
N
N    uint8_t pwmable;   // PWM 
N    uint8_t pwmfixed;   // PWM  can
N    uint8_t pwmstart;   
N    uint8_t pwmend;  
N    uint8_t pwmi;   	
N
N} PoutControl;
N
N
Nenum{
N	A1,
N	A9,
N	A2,
N	A10,
N	A3,
N	A11,
N	A4,
N	A12,
N	A5,
N	A13,
N	A6,
N	A14,
N	A7,
N	A42,
N	A8,
N};
N
N//cacl current for VND5T016  K = 4200
N//Iout = v/r*k; r = 510 k = 4200 v = adc/4096 *5
N//Iout = adc/4096*5/510*4200 = adc / 99.4742857 = adc * 0.01 A
N//Iout(100mA) = Iout(A) * 10  = adc * 0.1 = adc /10;
N
N//cacl current for BTT6010 K = 3900
N//Iout = v/r*k; r = 510 k = 3900 v = adc/4096 *5
N//Iout = adc/4096*5/510*3900 = adc / 107.126153846 = adc * 0.0093347886 A
N//Iout(100mA) = Iout(A) * 10  = adc * 0.093347886 = adc /10;
N
N#define POUT_COUNT 15
N	
Nextern PoutControl PoutS[POUT_COUNT];
Xextern PoutControl PoutS[15];
Nextern uint8_t rain_int_cmd;
N
N
N#define OD_OUT(level) gpio_bit_write(GPIOF, GPIO_PIN_6, (FlagStatus)(level))
N
N//extern void power_out_init (void);
N//extern void power_out (void);
N
N#endif
L 6 "src\rain.h" 2
N
N//extern void rain_init (void);
Nextern inline void rain_cmd_parse (uint16_t cmd);
N//extern void rain (void);
N
N#endif
L 2 "src\rain.c" 2
N#include "switch.h"
L 1 "src\switch.h" 1
N#ifndef __SWITCH_H__
N#define __SWITCH_H__
N
N#include "includes.h"
N
Nextern uint8_t in_sw[3];
N
N#define OD_IN() ((GPIO_PTD(GPIOF)&(GPIO_PIN_6)) != 0x00U)//gpio_bit_get(GPIOF, GPIO_PIN_6)
N#define ADD1_IN() ((GPIO_PTD(GPIOE)&(GPIO_PIN_4)) != 0x00U)//gpio_bit_get(GPIOE, GPIO_PIN_4)
N#define KH1_IN() ((GPIO_PTD(GPIOE)&(GPIO_PIN_3)) != 0x00U)//gpio_bit_get(GPIOE, GPIO_PIN_3)  
N
N
Nextern void mod_addr_init (void);
N
N//extern void din_init (void);
N//extern void din_app (void);
N
N#endif
L 3 "src\rain.c" 2
N
N#if SUPPORT_WIPER == 1
X#if 1 == 1
N
N#define RAIN_FAST_POUT PoutS[0]
N#define RAIN_SLOW_POUT PoutS[1]
N#define RAIN_Spray_POUT PoutS[2]
N
N#define LOW_ON()    gpio_bit_set(GPIOG, GPIO_PIN_3)
N#define LOW_OFF()   gpio_bit_reset(GPIOG, GPIO_PIN_3)
N
N
Ntypedef enum
N{
N    None,
N    Inter,
N    Fast,
N    Slow,
N} RainCmd;
N
N
Ntypedef enum
N{
N    RainNone,
N    RainOp,
N    RainWaitReset,
N    RainLowEnable,
N    RainInterDelay,
N		RainOpEnd,
N} RainState;
N
N
Nstatic RainState status;
N
Ntypedef enum
N{
N    Disable,
N    Enable
N} RainSprayCmd;
N
Nstatic RainCmd rain_cmd;
Nstatic RainSprayCmd rain_spray_cmd;
Nstatic uint8_t rain_spray_time = 0;
Nstatic uint32_t start_time_stamp = 0;
N
Nstatic uint8_t wiper_brake_enable = 1;
Nstatic uint8_t wiper_brake_delay_ms = 20;
N
Nstatic uint8_t wiper_brake_pwm_enable = 0;
N
N
N//
N//
N//0x06A4  Byte6 bit6   // 6A4
N//PWM0x06A4  Byte7 bit1 
N//0x06A4  Byte7 bit0 
N//0x06A4  Byte7 bit4-7 20ms20ms20ms
N
N
N//20RPM
N//
Ninline void rain_cmd_parse(uint16_t cmd)
N{
N    uint8_t fast;
N    uint8_t slow;
N    uint8_t inter; //
N
N    if(cmd & 0x30)
N    {
N        fast = (cmd & 1) == 0x01;
N        slow = (cmd & 2) == 0x02;
N        inter = (cmd & 8) == 0x08; //
N        rain_spray_cmd = (RainSprayCmd)((cmd & 4) == 0x04);  //
N    }
N    else
N    {
N        fast = 0;
N        slow = 0;
N        inter = 0; //
N        rain_spray_cmd = Disable; //
N    }
N
N    if((cmd & 0x40) == 0)
N    {
N        RAIN_Spray_POUT.cmd = (rain_spray_cmd == Enable);
X        PoutS[2].cmd = (rain_spray_cmd == Enable);
N    }
N
N    if(fast)
N    {
N        rain_cmd = Fast;
N    }
N    else if(slow)
N    {
N        rain_cmd = Slow;
N    }
N    else if(inter)
N    {
N        rain_cmd = Inter;
N    }
N    else
N    {
N        rain_cmd = None;
N    }
N		wiper_brake_pwm_enable = (cmd & 0x200) > 0;
N		wiper_brake_enable = (cmd & 0x100) > 0;
N		wiper_brake_delay_ms = (cmd >> 12) * 20;
N		wiper_brake_delay_ms = wiper_brake_delay_ms > 20 ? wiper_brake_delay_ms : 20;
N}
N
N#define Mos_on LOW_ON
N#define Mos_off LOW_OFF
N
Ninline  bool IsResetPostion()
N{
N    return (bool) WIPER_AT_RESET();
X    return (bool) (((((*((volatile uint32_t *)((uint32_t)((((((uint32_t)0x50000000) + (uint32_t)0xA0000) + (uint32_t)0x0064)) + 0x00U)))))&(((uint32_t)(0x01UL<<((uint8_t)(4)))))) != 0x00U) == 0);
N}
N
N
Nint protothread_rain(struct pt *pt)
N{
N    static uint32_t time = 0;
N    static uint32_t slow_start_time = 0;
N    PT_BEGIN(pt);
X    { char PT_YIELD_FLAG = 1; PT_YIELD_FLAG = PT_YIELD_FLAG; do { if((pt)->lc != 0) { goto *(pt)->lc; } } while(0);
N
N    while(1)
N    {
N        switch(status)
N        {
N            case RainNone://null
N                PT_WAIT_UNTIL(pt, (rain_cmd != None) || (rain_spray_cmd != Disable));
X                do { do { LC_LABEL131: ((pt)->lc) = &&LC_LABEL131; } while(0); if(!((rain_cmd != None) || (rain_spray_cmd != Disable))) { return 0; } } while(0);
N                status = RainOp;
N                break;
N
N            case RainOp://op
N							
N                if(rain_spray_cmd == Enable)
N                {
N                    rain_spray_time = 3;
N                }
N                if(rain_cmd == Fast)
N                {
N                    RAIN_FAST_POUT.cmd = 1;
X                    PoutS[0].cmd = 1;
N                    RAIN_SLOW_POUT.cmd = 0;
X                    PoutS[1].cmd = 0;
N                }
N                else
N                {
N                    RAIN_FAST_POUT.cmd = 0;
X                    PoutS[0].cmd = 0;
N                    RAIN_SLOW_POUT.cmd = 1;
X                    PoutS[1].cmd = 1;
N                    slow_start_time = systick_ms;
N                }
N                start_time_stamp = systick_ms;
N
N                PT_WAIT_UNTIL(pt, (!IsResetPostion()));
X                do { do { LC_LABEL154: ((pt)->lc) = &&LC_LABEL154; } while(0); if(!((!IsResetPostion()))) { return 0; } } while(0);
N																
N                PT_DELAY_MS(pt, 10);
X                { time = systick_ms + (10); do { do { LC_LABEL156: ((pt)->lc) = &&LC_LABEL156; } while(0); if(!(((int)(systick_ms - time) >= 0))) { return 0; } } while(0); };
N                PT_WAIT_UNTIL(pt, (!IsResetPostion()));
X                do { do { LC_LABEL157: ((pt)->lc) = &&LC_LABEL157; } while(0); if(!((!IsResetPostion()))) { return 0; } } while(0);
N
N                status = RainWaitReset;
N
N                break;
N
N            case RainWaitReset://wait reset
N                {
N                    static RainSprayCmd last;
N                    static RainCmd lastc;
N                    PT_WAIT_UNTIL(pt, (rain_spray_cmd != last) || (rain_cmd != lastc) || (IsResetPostion()));
X                    do { do { LC_LABEL167: ((pt)->lc) = &&LC_LABEL167; } while(0); if(!((rain_spray_cmd != last) || (rain_cmd != lastc) || (IsResetPostion()))) { return 0; } } while(0);
N
N                    if((rain_spray_cmd == last) && (rain_cmd == lastc))
N                    {
N                        if(rain_spray_time > 0)
N                        {
N                            rain_spray_time --;
N                        }
N                        else if(rain_cmd <= Inter)
N                        {
N                            if((systick_ms - slow_start_time) > 300)
N                            {
N																//PT_DELAY_MS(pt, 10);//10ms
N															  status = wiper_brake_enable ? RainLowEnable : RainOpEnd;
N                                break;
N                            }														
N                        }
N                    }
N
N                    last = rain_spray_cmd;
N                    lastc = rain_cmd;
N
N                    status = RainOp;
N
N                }
N                break;
N								
N						case RainOpEnd:						
N								RAIN_FAST_POUT.cmd = 0;
X								PoutS[0].cmd = 0;
N								RAIN_SLOW_POUT.cmd = 0;
X								PoutS[1].cmd = 0;
N
N								PT_DELAY_MS(pt, 10);
X								{ time = systick_ms + (10); do { do { LC_LABEL198: ((pt)->lc) = &&LC_LABEL198; } while(0); if(!(((int)(systick_ms - time) >= 0))) { return 0; } } while(0); };
N						
N								if(rain_cmd == None)
N								{
N										status = RainNone;
N								}
N								else if(rain_cmd == Inter)
N								{
N										status = RainInterDelay;
N								}
N								else
N								{
N										status = RainOp;
N								}
N								break;
N
N            case RainLowEnable://wen sha?
N                {									
N                    RAIN_FAST_POUT.cmd = 0;
X                    PoutS[0].cmd = 0;
N                    RAIN_SLOW_POUT.cmd = 0;
X                    PoutS[1].cmd = 0;
N
N                    PT_DELAY_MS(pt, wiper_brake_delay_ms);// 1ms 20ms						
X                    { time = systick_ms + (wiper_brake_delay_ms); do { do { LC_LABEL219: ((pt)->lc) = &&LC_LABEL219; } while(0); if(!(((int)(systick_ms - time) >= 0))) { return 0; } } while(0); };
N
N										if(wiper_brake_pwm_enable)
N                    {
N                        extern uint32_t pwmtime;
N                        static uint8_t i;
N                        time = pwmtime;
N                        for(i = 0; i < 50; i +=5 )
N                        {
N														//50*10*0.1ms = 50ms
N                            time += i;
N                            Mos_on();  
X                            gpio_bit_set(((((uint32_t)0x50000000) + (uint32_t)0xA0000) + (uint32_t)0x0084), ((uint32_t)(0x01UL<<((uint8_t)(3)))));  
N
N                            PT_WAIT_UNTIL(pt, ((int)(pwmtime - time) >= 0));
X                            do { do { LC_LABEL232: ((pt)->lc) = &&LC_LABEL232; } while(0); if(!(((int)(pwmtime - time) >= 0))) { return 0; } } while(0);
N
N                            time += 50 - i;
N                            Mos_off();
X                            gpio_bit_reset(((((uint32_t)0x50000000) + (uint32_t)0xA0000) + (uint32_t)0x0084), ((uint32_t)(0x01UL<<((uint8_t)(3)))));
N
N                            PT_WAIT_UNTIL(pt, ((int)(pwmtime - time) >= 0));
X                            do { do { LC_LABEL237: ((pt)->lc) = &&LC_LABEL237; } while(0); if(!(((int)(pwmtime - time) >= 0))) { return 0; } } while(0);
N                        }
N                    }
N                }
N
N                Mos_on();
X                gpio_bit_set(((((uint32_t)0x50000000) + (uint32_t)0xA0000) + (uint32_t)0x0084), ((uint32_t)(0x01UL<<((uint8_t)(3)))));
N                time = systick_ms + 500;
N                PT_WAIT_UNTIL(pt, ((int)(systick_ms - time) >= 0) || (rain_cmd > Inter) || (rain_spray_cmd != Disable));
X                do { do { LC_LABEL244: ((pt)->lc) = &&LC_LABEL244; } while(0); if(!(((int)(systick_ms - time) >= 0) || (rain_cmd > Inter) || (rain_spray_cmd != Disable))) { return 0; } } while(0);
N                Mos_off();
X                gpio_bit_reset(((((uint32_t)0x50000000) + (uint32_t)0xA0000) + (uint32_t)0x0084), ((uint32_t)(0x01UL<<((uint8_t)(3)))));
N
N                PT_DELAY_MS(pt, 10);
X                { time = systick_ms + (10); do { do { LC_LABEL247: ((pt)->lc) = &&LC_LABEL247; } while(0); if(!(((int)(systick_ms - time) >= 0))) { return 0; } } while(0); };
N
N                if(rain_cmd == None)
N                {
N                    status = RainNone;
N                }
N                else if(rain_cmd == Inter)
N                {
N                    status = RainInterDelay;
N                }
N                else
N                {
N                    status = RainOp;
N                }
N                break;
N
N            case RainInterDelay://inter delay
N                time = (start_time_stamp == 0) ? systick_ms : start_time_stamp + 5000;
N                PT_WAIT_UNTIL(pt, ((int)(systick_ms - time) >= 0) || (rain_cmd != Inter) || (rain_spray_cmd != Disable));
X                do { do { LC_LABEL265: ((pt)->lc) = &&LC_LABEL265; } while(0); if(!(((int)(systick_ms - time) >= 0) || (rain_cmd != Inter) || (rain_spray_cmd != Disable))) { return 0; } } while(0);
N                if(rain_cmd != None)
N                {
N                    status = RainOp;
N                }
N                else
N                {
N                    status = RainNone;
N                }
N                break;
N        }
N        PT_YIELD(pt);
X        do { PT_YIELD_FLAG = 0; do { LC_LABEL276: ((pt)->lc) = &&LC_LABEL276; } while(0); if(PT_YIELD_FLAG == 0) { return 1; } } while(0);
N    }
N
N    PT_INFINITE_LOOP_END(pt);
X    };
N}
N
N#ifdef RAIN_TEST
Sstatic struct pt pt_test;
S
Suint8_t rain_test_delay = 0; //0-500
Sint protothread_rain_test(struct pt *pt)
S{
S    static uint32_t time;
S    int i;
S    PT_BEGIN(pt);
S    while(1)
S    {
S        rain_cmd  = Fast;
S        for(i = 0; i < POUT_COUNT; i++)
S        {
S            PoutS[i].cmd = 1;
S        }
S
S        PT_DELAY_MS(pt, 800 + (((uint16_t)rain_test_delay)));  //fast is 1.2s, and rest is 0.1s, run is 1.1s, slow is 2.1s
S        //950+65*2 = 1080, 1200-150=1050, 1200-300 = 900;
S        rain_cmd  = None;
S
S        PT_DELAY_MS(pt, 2000);
S        for(i = 0; i < POUT_COUNT; i++)
S        {
S            PoutS[i].cmd = 0;
S        }
S
S        PT_DELAY_MS(pt, 2000);
S    }
S    PT_END(pt);
S}
N#endif
N
Nstatic struct pt pt_rain;
N
Nstatic void rain_init()
N{
N    LOW_OFF();
X    gpio_bit_reset(((((uint32_t)0x50000000) + (uint32_t)0xA0000) + (uint32_t)0x0084), ((uint32_t)(0x01UL<<((uint8_t)(3)))));
N    PT_INIT(&pt_rain);
X    (&pt_rain)->lc = 0;
N#ifdef RAIN_TEST
S    PT_INIT(&pt_test);
N#endif
N}
NINIT_PREV_EXPORT(rain_init);
X__attribute__((used)) const init_fn_t __stan_init_rain_init __attribute__((section(".init_fn." "2"))) = rain_init;
N
N#ifndef WIPER_DISABLE
Sextern uint8_t WIPER_DISABLE;
N#endif
N
Nvoid rain()
N{
N		if ((WIPER_DISABLE == 0) && (MOD_ADDR == ADDR1_MOD))
X		if ((0 == 0) && (mod_addr == 1))
N    {
N        protothread_rain(&pt_rain);
N#ifdef RAIN_TEST
S        protothread_rain_test(&pt_test);
N#endif
N    }
N}
N
N//INIT_APP_LOOP_EXPORT(rain);
N
N#endif //SUPPORT_WIPER
