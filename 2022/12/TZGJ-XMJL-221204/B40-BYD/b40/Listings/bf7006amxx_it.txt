; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave --gnu -o.\obj\bf7006amxx_it.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\obj\bf7006amxx_it.d --cpu=Cortex-M0 --apcs=interwork -Otime --diag_suppress=9931 -I.\src\pt -I.\src -I.\config -I.\RTE\CMSIS\BF7006AM64 -I.\RTE\Device\BF7006AM64 -I.\RTE\SEGGER -I.\RTE\Startup\BF7006AM64 -I.\RTE\_b40 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\BYD\BYDMicro_DFP\1.1.0\Device\Include\BF7006AMxx -D__UVISION_VERSION=536 -D_RTE_ -D_RTE_ --omf_browse=.\obj\bf7006amxx_it.crf src\BF7006AMxx_it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NMI_Handler PROC
;;;48     */
;;;49     void NMI_Handler (void)
000000  b510              PUSH     {r4,lr}
;;;50     {
;;;51         clr_nmi_interrupt_flag();
000002  f7fffffe          BL       clr_nmi_interrupt_flag
;;;52     }
000006  bd10              POP      {r4,pc}
;;;53     #endif
                          ENDP

                  HardFault_Handler PROC
                  |L1.8|
;;;60     */
;;;61     void HardFault_Handler (void)
000008  e7fe              B        |L1.8|
;;;62     {
;;;63         /* if Hard Fault exception occurs, go to infinite loop */
;;;64         while (1)
;;;65         {
;;;66         }
;;;67     }
;;;68     
                          ENDP

                  SVC_Handler PROC
;;;74     */
;;;75     void SVC_Handler (void)
00000a  4770              BX       lr
;;;76     {
;;;77     
;;;78     }
;;;79     
                          ENDP

                  PendSV_Handler PROC
;;;85     */
;;;86     void PendSV_Handler (void)
00000c  4770              BX       lr
;;;87     {
;;;88     
;;;89     }
;;;90     
                          ENDP

                  SysTick_Handler PROC
;;;96     */
;;;97     void SysTick_Handler (void)
00000e  4770              BX       lr
;;;98     {
;;;99     }
;;;100    
                          ENDP

                  SYS_IRQHandler PROC
;;;106    */
;;;107    void SYS_IRQHandler (void)
000010  495a              LDR      r1,|L1.380|
;;;108    {
;;;109        uint32_t state = SYS_INTFLG;
000012  6888              LDR      r0,[r1,#8]
;;;110        /* eeprom protect range illegal access */
;;;111        if ((state & SYS_INTFLG_EPOT) != 0x00U)
;;;112        {
;;;113        }
;;;114        /* flash protect range illegal access */
;;;115        if ((state & SYS_INTFLG_FPOT) != 0x00U)
;;;116        {
;;;117        }
;;;118        /* xtal initialize fail state */
;;;119        if ((state & SYS_INTFLG_XTALINIT) != 0x00U)
000014  07c2              LSLS     r2,r0,#31
000016  d002              BEQ      |L1.30|
;;;120        {
;;;121            xtal_timeout = 1;
000018  4a59              LDR      r2,|L1.384|
00001a  2301              MOVS     r3,#1
00001c  7013              STRB     r3,[r2,#0]
                  |L1.30|
;;;122        }
;;;123        /* xtal invalid check state */
;;;124        if ((state & SYS_INTFLG_XTALCHK) != 0x00U)
00001e  0782              LSLS     r2,r0,#30
000020  d507              BPL      |L1.50|
;;;125        {
;;;126            if ((SYS_XTAL_CHK & SYS_XTAL_CHK_RSTEN) == 0x00U)
000022  68ca              LDR      r2,[r1,#0xc]
000024  0792              LSLS     r2,r2,#30
000026  d404              BMI      |L1.50|
;;;127            {
;;;128                SYS_XTAL_CTRL &= ~SYS_XTAL_CTRL_EN;
000028  4a56              LDR      r2,|L1.388|
00002a  6853              LDR      r3,[r2,#4]
00002c  085b              LSRS     r3,r3,#1
00002e  005b              LSLS     r3,r3,#1
000030  6053              STR      r3,[r2,#4]
                  |L1.50|
;;;129            }
;;;130        }
;;;131        SYS_INTFLG = state;
000032  6088              STR      r0,[r1,#8]
;;;132    }
000034  4770              BX       lr
;;;133    
                          ENDP

                  LVDT_IRQHandler PROC
;;;139    */
;;;140    void LVDT_IRQHandler (void)
000036  b510              PUSH     {r4,lr}
;;;141    {
;;;142        uint8_t int_flag;
;;;143        int_flag = lvdt_int_flag_get();
000038  f7fffffe          BL       lvdt_int_flag_get
;;;144        lvdt_int_flag_clr (int_flag);
00003c  f7fffffe          BL       lvdt_int_flag_clr
;;;145    }
000040  bd10              POP      {r4,pc}
;;;146    
                          ENDP

                  TIMER0_IRQHandler PROC
;;;347    */
;;;348    void TIMER0_IRQHandler (void)
000042  b510              PUSH     {r4,lr}
;;;349    {
;;;350        //1KHz, for sys tick
;;;351        extern volatile uint32_t systick_ms;
;;;352        systick_ms ++;
000044  4850              LDR      r0,|L1.392|
000046  6801              LDR      r1,[r0,#0]  ; systick_ms
000048  1c49              ADDS     r1,r1,#1
00004a  6001              STR      r1,[r0,#0]  ; systick_ms
;;;353        timer_intflag_clr (TIMER0);
00004c  484f              LDR      r0,|L1.396|
00004e  f7fffffe          BL       timer_intflag_clr
;;;354    }
000052  bd10              POP      {r4,pc}
;;;355    
                          ENDP

                  TIMER1_IRQHandler PROC
;;;361    */
;;;362    void TIMER1_IRQHandler (void)
000054  b510              PUSH     {r4,lr}
;;;363    {
;;;364        //10KHz, for soft pwm, 100us
;;;365        extern volatile uint32_t pwmtime; //5day
;;;366        pwmtime ++;
000056  484e              LDR      r0,|L1.400|
000058  6801              LDR      r1,[r0,#0]  ; pwmtime
00005a  1c49              ADDS     r1,r1,#1
00005c  6001              STR      r1,[r0,#0]  ; pwmtime
;;;367        timer_intflag_clr (TIMER1);
00005e  484d              LDR      r0,|L1.404|
000060  f7fffffe          BL       timer_intflag_clr
;;;368    }
000064  bd10              POP      {r4,pc}
;;;369    #endif
                          ENDP

                  PWM_TOF_IRQHandler PROC
;;;377    */
;;;378    void PWM_TOF_IRQHandler (void)
000066  b510              PUSH     {r4,lr}
;;;379    {
;;;380        pwm_tof_clr();
000068  f7fffffe          BL       pwm_tof_clr
;;;381    }
00006c  bd10              POP      {r4,pc}
;;;382    
                          ENDP

                  PWM_CH0_IRQHandler PROC
;;;388    */
;;;389    void PWM_CH0_IRQHandler (void)
00006e  b510              PUSH     {r4,lr}
;;;390    {
;;;391        pwm_ch0_if_clr();
000070  f7fffffe          BL       pwm_ch0_if_clr
;;;392    }
000074  bd10              POP      {r4,pc}
;;;393    
                          ENDP

                  PWM_CH1_IRQHandler PROC
;;;399    */
;;;400    void PWM_CH1_IRQHandler (void)
000076  b510              PUSH     {r4,lr}
;;;401    {
;;;402        pwm_ch1_if_clr();
000078  f7fffffe          BL       pwm_ch1_if_clr
;;;403    }
00007c  bd10              POP      {r4,pc}
;;;404    
                          ENDP

                  PWM_CH2_IRQHandler PROC
;;;410    */
;;;411    void PWM_CH2_IRQHandler (void)
00007e  b510              PUSH     {r4,lr}
;;;412    {
;;;413        pwm_ch2_if_clr();
000080  f7fffffe          BL       pwm_ch2_if_clr
;;;414    }
000084  bd10              POP      {r4,pc}
;;;415    
                          ENDP

                  PWM_CH3_IRQHandler PROC
;;;421    */
;;;422    void PWM_CH3_IRQHandler (void)
000086  b510              PUSH     {r4,lr}
;;;423    {
;;;424        pwm_ch3_if_clr();
000088  f7fffffe          BL       pwm_ch3_if_clr
;;;425    }
00008c  bd10              POP      {r4,pc}
;;;426    
                          ENDP

                  PWM_CH4_IRQHandler PROC
;;;432    */
;;;433    void PWM_CH4_IRQHandler (void)
00008e  b510              PUSH     {r4,lr}
;;;434    {
;;;435        pwm_ch4_if_clr();
000090  f7fffffe          BL       pwm_ch4_if_clr
;;;436    }
000094  bd10              POP      {r4,pc}
;;;437    
                          ENDP

                  PWM_CH5_IRQHandler PROC
;;;443    */
;;;444    void PWM_CH5_IRQHandler (void)
000096  b510              PUSH     {r4,lr}
;;;445    {
;;;446        pwm_ch5_if_clr();
000098  f7fffffe          BL       pwm_ch5_if_clr
;;;447    }
00009c  bd10              POP      {r4,pc}
;;;448    #endif
                          ENDP

                  RTC_IRQHandler PROC
;;;457    
;;;458    void RTC_IRQHandler (void)
00009e  b570              PUSH     {r4-r6,lr}
;;;459    {
;;;460        extern uint16_t pluse_100ms;
;;;461        extern uint16_t pluse_count;
;;;462        extern  uint8_t pluse_flag;
;;;463        rtc_int_flag_clr();
0000a0  f7fffffe          BL       rtc_int_flag_clr
0000a4  2101              MOVS     r1,#1
0000a6  483c              LDR      r0,|L1.408|
0000a8  058c              LSLS     r4,r1,#22
0000aa  6004              STR      r4,[r0,#0]
0000ac  f3bf8f4f          DSB      
0000b0  f3bf8f6f          ISB      
;;;464    
;;;465        NVIC_DisableIRQ (GPIO_IRQn);
;;;466        pluse_100ms += pluse_count;
0000b4  4a39              LDR      r2,|L1.412|
0000b6  483a              LDR      r0,|L1.416|
0000b8  8813              LDRH     r3,[r2,#0]  ; pluse_100ms
0000ba  8805              LDRH     r5,[r0,#0]  ; pluse_count
0000bc  195b              ADDS     r3,r3,r5
0000be  8013              STRH     r3,[r2,#0]
;;;467        pluse_count = 0;
0000c0  2200              MOVS     r2,#0
0000c2  8002              STRH     r2,[r0,#0]
0000c4  4837              LDR      r0,|L1.420|
0000c6  6004              STR      r4,[r0,#0]
;;;468        NVIC_EnableIRQ (GPIO_IRQn);
;;;469    
;;;470        pluse_flag = 1;
0000c8  4837              LDR      r0,|L1.424|
0000ca  7001              STRB     r1,[r0,#0]
;;;471    }
0000cc  bd70              POP      {r4-r6,pc}
;;;472    #endif
                          ENDP

                  CAN_WAKE_IRQHandler PROC
;;;480    */
;;;481    void CAN_WAKE_IRQHandler (void)
0000ce  b510              PUSH     {r4,lr}
;;;482    {
;;;483        (void)can_interrupt_flag_get();
0000d0  f7fffffe          BL       can_interrupt_flag_get
;;;484        can_int_flag_clr (CAN_IF_WUPI);
0000d4  2010              MOVS     r0,#0x10
0000d6  f7fffffe          BL       can_int_flag_clr
;;;485    }
0000da  bd10              POP      {r4,pc}
;;;486    
                          ENDP

                  Can_ReInit PROC
;;;487    void Can_ReInit()
0000dc  b510              PUSH     {r4,lr}
;;;488    {
;;;489    	extern void can_config(void);
;;;490    	can_config();
0000de  f7fffffe          BL       can_config
;;;491    }
0000e2  bd10              POP      {r4,pc}
;;;492    
                          ENDP

                  CAN_ERR_IRQHandler PROC
;;;498    */
;;;499    void CAN_ERR_IRQHandler (void)
0000e4  b510              PUSH     {r4,lr}
;;;500    {
;;;501        uint8_t state;
;;;502        state = can_interrupt_flag_get();
0000e6  f7fffffe          BL       can_interrupt_flag_get
0000ea  4604              MOV      r4,r0
;;;503        (void)can_read_frame_error_code();
0000ec  f7fffffe          BL       can_read_frame_error_code
;;;504        if ((state & CAN_IF_BEI) != 0x00U)          /* bus error */
0000f0  0620              LSLS     r0,r4,#24
0000f2  d502              BPL      |L1.250|
;;;505        {
;;;506            can_int_flag_clr (CAN_IF_BEI);
0000f4  2080              MOVS     r0,#0x80
0000f6  f7fffffe          BL       can_int_flag_clr
                  |L1.250|
;;;507        }
;;;508        if ((state & CAN_IF_ALI) != 0x00U)          /* arbitration lost */
0000fa  0660              LSLS     r0,r4,#25
0000fc  d504              BPL      |L1.264|
;;;509        {
;;;510            (void)can_read_arbitration_lost_code();
0000fe  f7fffffe          BL       can_read_arbitration_lost_code
;;;511            can_int_flag_clr (CAN_IF_ALI);
000102  2040              MOVS     r0,#0x40
000104  f7fffffe          BL       can_int_flag_clr
                  |L1.264|
;;;512        }
;;;513        if ((state & CAN_IF_EPI) != 0x00U)          /* error passive */
000108  06a0              LSLS     r0,r4,#26
00010a  d504              BPL      |L1.278|
;;;514        {
;;;515            can_transmit_abort();
00010c  f7fffffe          BL       can_transmit_abort
;;;516            can_int_flag_clr (CAN_IF_EPI);
000110  2020              MOVS     r0,#0x20
000112  f7fffffe          BL       can_int_flag_clr
                  |L1.278|
;;;517        }
;;;518        if ((state & CAN_IF_DOI) != 0x00U)          /* data overflow */
000116  0720              LSLS     r0,r4,#28
000118  d502              BPL      |L1.288|
;;;519        {
;;;520            can_int_flag_clr (CAN_IF_DOI);
00011a  2008              MOVS     r0,#8
00011c  f7fffffe          BL       can_int_flag_clr
                  |L1.288|
;;;521        }
;;;522        if ((state & CAN_IF_EI) != 0x00U)           /* error interrupt or bus state change */
000120  0760              LSLS     r0,r4,#29
000122  d508              BPL      |L1.310|
;;;523        {
;;;524            if ((can_status_get() & CAN_SR_BS) == CAN_BUS_OFF)  //can bus off
000124  f7fffffe          BL       can_status_get
000128  09c0              LSRS     r0,r0,#7
00012a  d001              BEQ      |L1.304|
00012c  f7fffffe          BL       can_config
                  |L1.304|
;;;525            {					
;;;526    						Can_ReInit();
;;;527            }
;;;528            can_int_flag_clr (CAN_IF_EI);
000130  2004              MOVS     r0,#4
000132  f7fffffe          BL       can_int_flag_clr
                  |L1.310|
;;;529        }
;;;530    }
000136  bd10              POP      {r4,pc}
;;;531    
                          ENDP

                  CAN_RX_IRQHandler PROC
;;;537    */
;;;538    void CAN_RX_IRQHandler (void)
000138  b510              PUSH     {r4,lr}
;;;539    {
;;;540    		extern void can_isr(void);
;;;541        (void)can_interrupt_flag_get();
00013a  f7fffffe          BL       can_interrupt_flag_get
;;;542    		can_isr();
00013e  f7fffffe          BL       can_isr
;;;543        can_int_flag_clr (CAN_IF_RI);
000142  2001              MOVS     r0,#1
000144  f7fffffe          BL       can_int_flag_clr
;;;544    }
000148  bd10              POP      {r4,pc}
;;;545    
                          ENDP

                  CAN_TX_IRQHandler PROC
;;;551    */
;;;552    void CAN_TX_IRQHandler (void)
00014a  b510              PUSH     {r4,lr}
;;;553    {
;;;554        (void)can_interrupt_flag_get();
00014c  f7fffffe          BL       can_interrupt_flag_get
;;;555        can_int_flag_clr (CAN_IF_TI);
000150  2002              MOVS     r0,#2
000152  f7fffffe          BL       can_int_flag_clr
;;;556    }
000156  bd10              POP      {r4,pc}
;;;557    #endif
                          ENDP

                  GPIO_IRQHandler PROC
;;;565    */
;;;566    void GPIO_IRQHandler (void)
000158  b510              PUSH     {r4,lr}
;;;567    {
;;;568        extern uint16_t pluse_count;
;;;569        uint8_t stateD = get_gpio_port_interrupt_state ((uint32_t)GPIOD);
00015a  4c14              LDR      r4,|L1.428|
00015c  4620              MOV      r0,r4
00015e  f7fffffe          BL       get_gpio_port_interrupt_state
;;;570    
;;;571        // count pluse
;;;572        pluse_count ++;
000162  4b0f              LDR      r3,|L1.416|
;;;573    
;;;574        clr_gpio_interrupt_state ((uint32_t)GPIOD, stateD);
000164  4601              MOV      r1,r0
000166  881a              LDRH     r2,[r3,#0]            ;572  ; pluse_count
000168  4620              MOV      r0,r4
00016a  1c52              ADDS     r2,r2,#1              ;572
00016c  801a              STRH     r2,[r3,#0]            ;572
00016e  f7fffffe          BL       clr_gpio_interrupt_state
;;;575    }
000172  bd10              POP      {r4,pc}
;;;576    #endif
                          ENDP

                  ADC_IRQHandler PROC
;;;584    */
;;;585    void ADC_IRQHandler (void)
000174  b510              PUSH     {r4,lr}
;;;586    {
;;;587        uint16_t temp = adc_data_get();
000176  f7fffffe          BL       adc_data_get
;;;588    }
00017a  bd10              POP      {r4,pc}
;;;589    #endif
                          ENDP

                  |L1.380|
                          DCD      0x50010100
                  |L1.384|
                          DCD      xtal_timeout
                  |L1.388|
                          DCD      0x50010000
                  |L1.392|
                          DCD      systick_ms
                  |L1.396|
                          DCD      0x500b0000
                  |L1.400|
                          DCD      pwmtime
                  |L1.404|
                          DCD      0x500b4000
                  |L1.408|
                          DCD      0xe000e180
                  |L1.412|
                          DCD      pluse_100ms
                  |L1.416|
                          DCD      pluse_count
                  |L1.420|
                          DCD      0xe000e100
                  |L1.424|
                          DCD      pluse_flag
                  |L1.428|
                          DCD      0x500a0048

;*** Start embedded assembler ***

#line 1 "src\\BF7006AMxx_it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_BF7006AMxx_it_c_bb8ca80c____REV16|
#line 447 ".\\RTE\\CMSIS\\BF7006AM64\\cmsis_armcc.h"
|__asm___15_BF7006AMxx_it_c_bb8ca80c____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_BF7006AMxx_it_c_bb8ca80c____REVSH|
#line 462
|__asm___15_BF7006AMxx_it_c_bb8ca80c____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
